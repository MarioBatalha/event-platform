import {
  require_react
} from "./chunk-HN56VSZG.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5CYG367S.js";

// node_modules/@seznam/compose-react-refs/composeRefs.js
var require_composeRefs = __commonJS({
  "node_modules/@seznam/compose-react-refs/composeRefs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function composeRefs2() {
      var refs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
      }
      if (refs.length === 2) {
        return composeTwoRefs(refs[0], refs[1]) || null;
      }
      var composedRef = refs.slice(1).reduce(function(semiCombinedRef, refToInclude) {
        return composeTwoRefs(semiCombinedRef, refToInclude);
      }, refs[0]);
      return composedRef || null;
    }
    exports.default = composeRefs2;
    var composedRefCache = /* @__PURE__ */ new WeakMap();
    function composeTwoRefs(ref1, ref2) {
      if (ref1 && ref2) {
        var ref1Cache = composedRefCache.get(ref1) || /* @__PURE__ */ new WeakMap();
        composedRefCache.set(ref1, ref1Cache);
        var composedRef = ref1Cache.get(ref2) || function(instance) {
          updateRef(ref1, instance);
          updateRef(ref2, instance);
        };
        ref1Cache.set(ref2, composedRef);
        return composedRef;
      }
      if (!ref1) {
        return ref2;
      } else {
        return ref1;
      }
    }
    function updateRef(ref, instance) {
      if (typeof ref === "function") {
        ref(instance);
      } else {
        ref.current = instance;
      }
    }
  }
});

// node_modules/@stencil/core/internal/app-data/index.js
var BUILD = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  appendChildSlotFix: false,
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  safari10: false,
  scriptDataOpts: false,
  shadowDomShim: false,
  slotChildNodesFix: false,
  propBoolean: true,
  propNumber: true,
  propString: true,
  cssVarShim: false,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  dynamicImportShim: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true
};
var NAMESPACE = "app";

// node_modules/@stencil/core/internal/client/index.js
var scopeId;
var contentRef;
var hostTagName;
var customError;
var i = 0;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var renderingRef = null;
var queueCongestion = 0;
var queuePending = false;
var win = typeof window !== "undefined" ? window : {};
var CSS = BUILD.cssVarShim ? win.CSS : null;
var doc = win.document || { head: {} };
var H = win.HTMLElement || class {
};
var plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
var supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom ? (() => (doc.head.attachShadow + "").indexOf("[native") > -1)() : true;
var supportsListenerOptions = (() => {
  let supportsListenerOptions2 = false;
  try {
    doc.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        supportsListenerOptions2 = true;
      }
    }));
  } catch (e) {
  }
  return supportsListenerOptions2;
})();
var promiseResolve = (v) => Promise.resolve(v);
var supportsConstructibleStylesheets = BUILD.constructableCSS ? (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replace === "function";
  } catch (e) {
  }
  return false;
})() : false;
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (BUILD.hostListener && listeners) {
    if (BUILD.hostListenerTargetParent) {
      if (attachParentListeners) {
        listeners = listeners.filter(([flags]) => flags & 32);
      } else {
        listeners = listeners.filter(([flags]) => !(flags & 32));
      }
    }
    listeners.map(([flags, name, method]) => {
      const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
var hostListenerProxy = (hostRef, methodName) => (ev) => {
  try {
    if (BUILD.lazyLoad) {
      if (hostRef.$flags$ & 256) {
        hostRef.$lazyInstance$[methodName](ev);
      } else {
        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
      }
    } else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e) {
    consoleError(e);
  }
};
var getHostListenerTarget = (elm, flags) => {
  if (BUILD.hostListenerTargetDocument && flags & 4)
    return doc;
  if (BUILD.hostListenerTargetWindow && flags & 8)
    return win;
  if (BUILD.hostListenerTargetBody && flags & 16)
    return doc.body;
  if (BUILD.hostListenerTargetParent && flags & 32)
    return elm.parentElement;
  return elm;
};
var hostListenerOpts = (flags) => supportsListenerOptions ? {
  passive: (flags & 1) !== 0,
  capture: (flags & 2) !== 0
} : (flags & 2) !== 0;
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var HYDRATE_ID = "s-id";
var HYDRATED_STYLE_ID = "sty-id";
var HYDRATE_CHILD_ID = "c-id";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var createTime = (fnName, tagName = "") => {
  if (BUILD.profile && performance.mark) {
    const key2 = `st:${fnName}:${tagName}:${i++}`;
    performance.mark(key2);
    return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key2);
  } else {
    return () => {
      return;
    };
  }
};
var uniqueTime = (key2, measureText) => {
  if (BUILD.profile && performance.mark) {
    if (performance.getEntriesByName(key2).length === 0) {
      performance.mark(key2);
    }
    return () => {
      if (performance.getEntriesByName(measureText).length === 0) {
        performance.measure(measureText, key2);
      }
    };
  } else {
    return () => {
      return;
    };
  }
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructibleStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    style.replace(cssText);
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
  let scopeId2 = getScopeId(cmpMeta, mode);
  let style = styles.get(scopeId2);
  if (!BUILD.attachStyles) {
    return scopeId2;
  }
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        if (BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
          styleElm.innerHTML = style;
        } else {
          if (BUILD.cssVarShim && plt.$cssShim$) {
            styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId2, style, !!(cmpMeta.$flags$ & 10));
            const newScopeId = styleElm["s-sc"];
            if (newScopeId) {
              scopeId2 = newScopeId;
              appliedStyles = null;
            }
          } else {
            styleElm = doc.createElement("style");
            styleElm.innerHTML = style;
          }
          if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {
            styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
var attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);
  if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (BUILD.scoped && flags & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
var getScopeId = (cmp, mode) => "sc-" + (BUILD.mode && mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m) => !!m);
var EMPTY_OBJ = {};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var isDef = (v) => v != null;
var isComplexType = (o) => {
  o = typeof o;
  return o === "object" || o === "function";
};
var h = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key2 = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  let vNodeChildren = [];
  const walk = (c) => {
    for (let i2 = 0; i2 < c.length; i2++) {
      child = c[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        } else if (BUILD.isDev && typeof nodeName !== "function" && child.$flags$ === void 0) {
          consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (BUILD.isDev && nodeName === "input") {
      validateInputProperties(vnodeData);
    }
    if (BUILD.vdomKey && vnodeData.key) {
      key2 = vnodeData.key;
    }
    if (BUILD.slotRelocation && vnodeData.name) {
      slotName = vnodeData.name;
    }
    if (BUILD.vdomClass) {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
      }
    }
  }
  if (BUILD.isDev && vNodeChildren.some(isHost)) {
    consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
  }
  if (BUILD.vdomFunctional && typeof nodeName === "function") {
    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  if (BUILD.vdomKey) {
    vnode.$key$ = key2;
  }
  if (BUILD.slotRelocation) {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  if (BUILD.vdomAttribute) {
    vnode.$attrs$ = null;
  }
  if (BUILD.vdomKey) {
    vnode.$key$ = null;
  }
  if (BUILD.slotRelocation) {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host = {};
var isHost = (node) => node && node.$tag$ === Host;
var vdomFnUtils = {
  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
var convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = Object.assign({}, node.vattrs);
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
var validateInputProperties = (vnodeData) => {
  const props = Object.keys(vnodeData);
  const typeIndex = props.indexOf("type");
  const minIndex = props.indexOf("min");
  const maxIndex = props.indexOf("max");
  const stepIndex = props.indexOf("min");
  const value = props.indexOf("value");
  if (value === -1) {
    return;
  }
  if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
    consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
  }
};
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln = memberName.toLowerCase();
    if (BUILD.vdomClass && memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
    } else if (BUILD.vdomStyle && memberName === "style") {
      if (BUILD.updatable) {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (!BUILD.hydrateServerSide && prop.includes("-")) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = "";
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          if (!BUILD.hydrateServerSide && prop.includes("-")) {
            elm.style.setProperty(prop, newValue[prop]);
          } else {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (BUILD.vdomKey && memberName === "key")
      ;
    else if (BUILD.vdomRef && memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (BUILD.vdomListener && (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln)) {
        memberName = ln.slice(2);
      } else {
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue) {
        plt.rel(elm, memberName, oldValue, false);
      }
      if (newValue) {
        plt.ael(elm, memberName, newValue, false);
      }
    } else if (BUILD.vdomPropOrAttr) {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            let n = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n) {
              elm[memberName] = n;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e) {
        }
      }
      let xlink = false;
      if (BUILD.vdomXlink) {
        if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
          memberName = ln;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (BUILD.vdomXlink && xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (BUILD.vdomXlink && xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
var parseClassListRegex = /\s/;
var parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
var updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  if (BUILD.updatable) {
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (memberName in newVnodeAttrs) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  let newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (BUILD.slotRelocation && !useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? 2 : 1;
    }
  }
  if (BUILD.isDev && newVNode2.$elm$) {
    consoleDevError(`The JSX ${newVNode2.$text$ !== null ? `"${newVNode2.$text$}" text` : `"${newVNode2.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
  }
  if (BUILD.vdomText && newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
  } else if (BUILD.slotRelocation && newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode2) : doc.createTextNode("");
  } else {
    if (BUILD.svg && !isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = BUILD.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$) : doc.createElement(BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
    if (BUILD.svg && isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    if (BUILD.vdomAttribute) {
      updateElement(null, newVNode2, isSvgMode);
    }
    if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm(oldParentVNode, newVNode2, i2, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    if (BUILD.svg) {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  if (BUILD.slotRelocation) {
    elm["s-hn"] = hostTagName;
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        putBackInOriginalLocation(oldParentVNode.$elm$, false);
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = BUILD.slotRelocation && parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);
      }
    }
  }
};
var removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnode = vnodes[startIdx]) {
      elm = vnode.$elm$;
      callNodeRefs(vnode);
      if (BUILD.slotRelocation) {
        checkSlotFallbackVisibility = true;
        if (elm["s-ol"]) {
          elm["s-ol"].remove();
        } else {
          putBackInOriginalLocation(elm, true);
        }
      }
      elm.remove();
    }
  }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode)) {
      patch(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode)) {
      patch(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode)) {
      if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode)) {
      if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      if (BUILD.vdomKey) {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (BUILD.vdomKey && idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        if (BUILD.slotRelocation) {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        } else {
          oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
  } else if (BUILD.updatable && newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode = (vnode1, vnode2) => {
  if (vnode1.$tag$ === vnode2.$tag$) {
    if (BUILD.slotRelocation && vnode1.$tag$ === "slot") {
      return vnode1.$name$ === vnode2.$name$;
    }
    if (BUILD.vdomKey) {
      return vnode1.$key$ === vnode2.$key$;
    }
    return true;
  }
  return false;
};
var referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
var parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (!BUILD.vdomText || text === null) {
    if (BUILD.svg) {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    if (BUILD.vdomAttribute || BUILD.reflect) {
      if (BUILD.slot && tag === "slot")
        ;
      else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (BUILD.updatable && oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren);
    } else if (newChildren !== null) {
      if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (BUILD.updatable && oldChildren !== null) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (BUILD.svg && isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm["s-cr"])) {
    defaultHolder.parentNode.textContent = text;
  } else if (BUILD.vdomText && oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var updateFallbackSlotVisibility = (elm) => {
  let childNodes = elm.childNodes;
  let childNode;
  let i2;
  let ilen;
  let j;
  let slotNameAttr;
  let nodeType;
  for (i2 = 0, ilen = childNodes.length; i2 < ilen; i2++) {
    childNode = childNodes[i2];
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        slotNameAttr = childNode["s-sn"];
        childNode.hidden = false;
        for (j = 0; j < ilen; j++) {
          nodeType = childNodes[j].nodeType;
          if (childNodes[j]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
            if (nodeType === 1 && slotNameAttr === childNodes[j].getAttribute("slot")) {
              childNode.hidden = true;
              break;
            }
          } else {
            if (nodeType === 1 || nodeType === 3 && childNodes[j].textContent.trim() !== "") {
              childNode.hidden = true;
              break;
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
var relocateNodes = [];
var relocateSlotContent = (elm) => {
  let childNode;
  let node;
  let hostContentNodes;
  let slotNameAttr;
  let relocateNodeData;
  let j;
  let i2 = 0;
  let childNodes = elm.childNodes;
  let ilen = childNodes.length;
  for (; i2 < ilen; i2++) {
    childNode = childNodes[i2];
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      slotNameAttr = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
          if (isNodeLocatedInSlot(node, slotNameAttr)) {
            relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotNameAttr;
            if (relocateNodeData) {
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      relocateSlotContent(childNode);
    }
  }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotNameAttr) {
    return true;
  }
  return slotNameAttr === "";
};
var callNodeRefs = (vNode) => {
  if (BUILD.vdomRef) {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(callNodeRefs);
  }
};
var renderVdom = (hostRef, renderFnResults) => {
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
    throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
  }
  if (BUILD.reflect && cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;
  if (BUILD.scoped || BUILD.shadowDom) {
    scopeId = hostElm["s-sc"];
  }
  if (BUILD.slotRelocation) {
    contentRef = hostElm["s-cr"];
    useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1) !== 0;
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode);
  if (BUILD.slotRelocation) {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      relocateSlotContent(rootVnode.$elm$);
      let relocateData;
      let nodeToRelocate;
      let orgLocationNode;
      let parentNodeRef;
      let insertBeforeNode;
      let refNode;
      let i2 = 0;
      for (; i2 < relocateNodes.length; i2++) {
        relocateData = relocateNodes[i2];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          orgLocationNode = BUILD.isDebug || BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (i2 = 0; i2 < relocateNodes.length; i2++) {
        relocateData = relocateNodes[i2];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (relocateData.$slotRefNode$) {
          parentNodeRef = relocateData.$slotRefNode$.parentNode;
          insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
          orgLocationNode = nodeToRelocate["s-ol"];
          while (orgLocationNode = orgLocationNode.previousSibling) {
            refNode = orgLocationNode["s-nr"];
            if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
              refNode = refNode.nextSibling;
              if (!refNode || !refNode["s-nr"]) {
                insertBeforeNode = refNode;
                break;
              }
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
            }
          }
        } else {
          if (nodeToRelocate.nodeType === 1) {
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1;
    relocateNodes.length = 0;
  }
};
var slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`);
var originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate["s-hn"]})` : `[${nodeToRelocate.textContent}]`));
var getElement = (ref) => BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;
var createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      if (BUILD.isDev && !elm.isConnected) {
        consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
      }
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4),
        composed: !!(flags & 2),
        cancelable: !!(flags & 1),
        detail
      });
    }
  };
};
var emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var attachToAncestor = (hostRef, ancestorComponent) => {
  if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
    ancestorComponent["s-p"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));
  }
};
var scheduleUpdate = (hostRef, isInitialLoad) => {
  if (BUILD.taskQueue && BUILD.updatable) {
    hostRef.$flags$ |= 16;
  }
  if (BUILD.asyncLoading && hostRef.$flags$ & 4) {
    hostRef.$flags$ |= 512;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
var dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
  let promise;
  if (isInitialLoad) {
    if (BUILD.lazyLoad && BUILD.hostListener) {
      hostRef.$flags$ |= 256;
      if (hostRef.$queuedListeners$) {
        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
        hostRef.$queuedListeners$ = null;
      }
    }
    emitLifecycleEvent(elm, "componentWillLoad");
    if (BUILD.cmpWillLoad) {
      promise = safeCall(instance, "componentWillLoad");
    }
  } else {
    emitLifecycleEvent(elm, "componentWillUpdate");
    if (BUILD.cmpWillUpdate) {
      promise = safeCall(instance, "componentWillUpdate");
    }
  }
  emitLifecycleEvent(elm, "componentWillRender");
  if (BUILD.cmpWillRender) {
    promise = then(promise, () => safeCall(instance, "componentWillRender"));
  }
  endSchedule();
  return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
var updateComponent = async (hostRef, instance, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  const rc = elm["s-rc"];
  if (BUILD.style && isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  if (BUILD.isDev) {
    hostRef.$flags$ |= 1024;
  }
  if (BUILD.hydrateServerSide) {
    await callRender(hostRef, instance, elm);
  } else {
    callRender(hostRef, instance, elm);
  }
  if (BUILD.cssVarShim && plt.$cssShim$) {
    plt.$cssShim$.updateHost(elm);
  }
  if (BUILD.isDev) {
    hostRef.$renderCount$++;
    hostRef.$flags$ &= ~1024;
  }
  if (BUILD.hydrateServerSide) {
    try {
      serverSideConnected(elm);
      if (isInitialLoad) {
        if (hostRef.$cmpMeta$.$flags$ & 1) {
          elm["s-en"] = "";
        } else if (hostRef.$cmpMeta$.$flags$ & 2) {
          elm["s-en"] = "c";
        }
      }
    } catch (e) {
      consoleError(e, elm);
    }
  }
  if (BUILD.asyncLoading && rc) {
    rc.map((cb) => cb());
    elm["s-rc"] = void 0;
  }
  endRender();
  endUpdate();
  if (BUILD.asyncLoading) {
    const childrenPromises = elm["s-p"];
    const postUpdate = () => postUpdateComponent(hostRef);
    if (childrenPromises.length === 0) {
      postUpdate();
    } else {
      Promise.all(childrenPromises).then(postUpdate);
      hostRef.$flags$ |= 4;
      childrenPromises.length = 0;
    }
  } else {
    postUpdateComponent(hostRef);
  }
};
var callRender = (hostRef, instance, elm) => {
  const allRenderFn = BUILD.allRenderFn ? true : false;
  const lazyLoad = BUILD.lazyLoad ? true : false;
  const taskQueue = BUILD.taskQueue ? true : false;
  const updatable = BUILD.updatable ? true : false;
  try {
    renderingRef = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD.hasRenderFn || BUILD.reflect) {
      if (BUILD.vdomRender || BUILD.reflect) {
        if (BUILD.hydrateServerSide) {
          return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));
        } else {
          renderVdom(hostRef, instance);
        }
      } else {
        elm.textContent = instance;
      }
    }
  } catch (e) {
    consoleError(e, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
var getRenderingRef = () => renderingRef;
var postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
  const ancestorComponent = hostRef.$ancestorComponent$;
  if (BUILD.cmpDidRender) {
    if (BUILD.isDev) {
      hostRef.$flags$ |= 1024;
    }
    safeCall(instance, "componentDidRender");
    if (BUILD.isDev) {
      hostRef.$flags$ &= ~1024;
    }
  }
  emitLifecycleEvent(elm, "componentDidRender");
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    if (BUILD.asyncLoading && BUILD.cssAnnotations) {
      addHydratedFlag(elm);
    }
    if (BUILD.cmpDidLoad) {
      if (BUILD.isDev) {
        hostRef.$flags$ |= 2048;
      }
      safeCall(instance, "componentDidLoad");
      if (BUILD.isDev) {
        hostRef.$flags$ &= ~2048;
      }
    }
    emitLifecycleEvent(elm, "componentDidLoad");
    endPostUpdate();
    if (BUILD.asyncLoading) {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad(tagName);
      }
    }
  } else {
    if (BUILD.cmpDidUpdate) {
      if (BUILD.isDev) {
        hostRef.$flags$ |= 1024;
      }
      safeCall(instance, "componentDidUpdate");
      if (BUILD.isDev) {
        hostRef.$flags$ &= ~1024;
      }
    }
    emitLifecycleEvent(elm, "componentDidUpdate");
    endPostUpdate();
  }
  if (BUILD.hotModuleReplacement) {
    elm["s-hmr-load"] && elm["s-hmr-load"]();
  }
  if (BUILD.method && BUILD.lazyLoad) {
    hostRef.$onInstanceResolve$(elm);
  }
  if (BUILD.asyncLoading) {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = void 0;
    }
    if (hostRef.$flags$ & 512) {
      nextTick(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= ~(4 | 512);
  }
};
var appDidLoad = (who) => {
  if (BUILD.cssAnnotations) {
    addHydratedFlag(doc.documentElement);
  }
  if (BUILD.asyncQueue) {
    plt.$flags$ |= 2;
  }
  nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
  if (BUILD.profile && performance.measure) {
    performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, "st:app:start");
  }
};
var safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e) {
      consoleError(e);
    }
  }
  return void 0;
};
var then = (promise, thenFn) => {
  return promise && promise.then ? promise.then(thenFn) : thenFn();
};
var emitLifecycleEvent = (elm, lifecycleName) => {
  if (BUILD.lifecycleDOMEvents) {
    emitEvent(elm, "stencil_" + lifecycleName, {
      bubbles: true,
      composed: true,
      detail: {
        namespace: NAMESPACE
      }
    });
  }
};
var addHydratedFlag = (elm) => BUILD.hydratedClass ? elm.classList.add("hydrated") : BUILD.hydratedAttribute ? elm.setAttribute("hydrated", "") : void 0;
var serverSideConnected = (elm) => {
  const children = elm.children;
  if (children != null) {
    for (let i2 = 0, ii = children.length; i2 < ii; i2++) {
      const childElm = children[i2];
      if (typeof childElm.connectedCallback === "function") {
        childElm.connectedCallback();
      }
      serverSideConnected(childElm);
    }
  }
};
var initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
  const endHydrate = createTime("hydrateClient", tagName);
  const shadowRoot = hostElm.shadowRoot;
  const childRenderNodes = [];
  const slotNodes = [];
  const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;
  const vnode = hostRef.$vnode$ = newVNode(tagName, null);
  if (!plt.$orgLocNodes$) {
    initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
  }
  hostElm[HYDRATE_ID] = hostId;
  hostElm.removeAttribute(HYDRATE_ID);
  clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
  childRenderNodes.map((c) => {
    const orgLocationId = c.$hostId$ + "." + c.$nodeId$;
    const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
    const node = c.$elm$;
    if (orgLocationNode && supportsShadow && orgLocationNode["s-en"] === "") {
      orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
    }
    if (!shadowRoot) {
      node["s-hn"] = tagName;
      if (orgLocationNode) {
        node["s-ol"] = orgLocationNode;
        node["s-ol"]["s-nr"] = node;
      }
    }
    plt.$orgLocNodes$.delete(orgLocationId);
  });
  if (BUILD.shadowDom && shadowRoot) {
    shadowRootNodes.map((shadowRootNode) => {
      if (shadowRootNode) {
        shadowRoot.appendChild(shadowRootNode);
      }
    });
  }
  endHydrate();
};
var clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {
  let childNodeType;
  let childIdSplt;
  let childVNode;
  let i2;
  if (node.nodeType === 1) {
    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
    if (childNodeType) {
      childIdSplt = childNodeType.split(".");
      if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
        childVNode = {
          $flags$: 0,
          $hostId$: childIdSplt[0],
          $nodeId$: childIdSplt[1],
          $depth$: childIdSplt[2],
          $index$: childIdSplt[3],
          $tag$: node.tagName.toLowerCase(),
          $elm$: node,
          $attrs$: null,
          $children$: null,
          $key$: null,
          $name$: null,
          $text$: null
        };
        childRenderNodes.push(childVNode);
        node.removeAttribute(HYDRATE_CHILD_ID);
        if (!parentVNode.$children$) {
          parentVNode.$children$ = [];
        }
        parentVNode.$children$[childVNode.$index$] = childVNode;
        parentVNode = childVNode;
        if (shadowRootNodes && childVNode.$depth$ === "0") {
          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
        }
      }
    }
    for (i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
      clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i2], hostId);
    }
    if (node.shadowRoot) {
      for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {
        clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i2], hostId);
      }
    }
  } else if (node.nodeType === 8) {
    childIdSplt = node.nodeValue.split(".");
    if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
      childNodeType = childIdSplt[0];
      childVNode = {
        $flags$: 0,
        $hostId$: childIdSplt[1],
        $nodeId$: childIdSplt[2],
        $depth$: childIdSplt[3],
        $index$: childIdSplt[4],
        $elm$: node,
        $attrs$: null,
        $children$: null,
        $key$: null,
        $name$: null,
        $tag$: null,
        $text$: null
      };
      if (childNodeType === TEXT_NODE_ID) {
        childVNode.$elm$ = node.nextSibling;
        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3) {
          childVNode.$text$ = childVNode.$elm$.textContent;
          childRenderNodes.push(childVNode);
          node.remove();
          if (!parentVNode.$children$) {
            parentVNode.$children$ = [];
          }
          parentVNode.$children$[childVNode.$index$] = childVNode;
          if (shadowRootNodes && childVNode.$depth$ === "0") {
            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
          }
        }
      } else if (childVNode.$hostId$ === hostId) {
        if (childNodeType === SLOT_NODE_ID) {
          childVNode.$tag$ = "slot";
          if (childIdSplt[5]) {
            node["s-sn"] = childVNode.$name$ = childIdSplt[5];
          } else {
            node["s-sn"] = "";
          }
          node["s-sr"] = true;
          if (BUILD.shadowDom && shadowRootNodes) {
            childVNode.$elm$ = doc.createElement(childVNode.$tag$);
            if (childVNode.$name$) {
              childVNode.$elm$.setAttribute("name", childVNode.$name$);
            }
            node.parentNode.insertBefore(childVNode.$elm$, node);
            node.remove();
            if (childVNode.$depth$ === "0") {
              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
            }
          }
          slotNodes.push(childVNode);
          if (!parentVNode.$children$) {
            parentVNode.$children$ = [];
          }
          parentVNode.$children$[childVNode.$index$] = childVNode;
        } else if (childNodeType === CONTENT_REF_ID) {
          if (BUILD.shadowDom && shadowRootNodes) {
            node.remove();
          } else if (BUILD.slotRelocation) {
            hostElm["s-cr"] = node;
            node["s-cn"] = true;
          }
        }
      }
    }
  } else if (parentVNode && parentVNode.$tag$ === "style") {
    const vnode = newVNode(null, node.textContent);
    vnode.$elm$ = node;
    vnode.$index$ = "0";
    parentVNode.$children$ = [vnode];
  }
};
var initializeDocumentHydrate = (node, orgLocNodes) => {
  if (node.nodeType === 1) {
    let i2 = 0;
    for (; i2 < node.childNodes.length; i2++) {
      initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);
    }
    if (node.shadowRoot) {
      for (i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++) {
        initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
      }
    }
  } else if (node.nodeType === 8) {
    const childIdSplt = node.nodeValue.split(".");
    if (childIdSplt[0] === ORG_LOCATION_ID) {
      orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
      node.nodeValue = "";
      node["s-en"] = childIdSplt[3];
    }
  }
};
var parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (BUILD.propBoolean && propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (BUILD.propNumber && propType & 2) {
      return parseFloat(propValue);
    }
    if (BUILD.propString && propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  if ((!BUILD.lazyLoad || !(flags & 8) || oldVal === void 0) && newVal !== oldVal) {
    hostRef.$instanceValues$.set(propName, newVal);
    if (BUILD.isDev) {
      if (hostRef.$flags$ & 1024) {
        consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
      } else if (hostRef.$flags$ & 2048) {
        consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
      }
    }
    if (!BUILD.lazyLoad || instance) {
      if (BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e) {
              consoleError(e, elm);
            }
          });
        }
      }
      if (BUILD.updatable && (flags & (2 | 16)) === 2) {
        if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
var proxyComponent = (Cstr, cmpMeta, flags) => {
  if (BUILD.member && cmpMeta.$members$) {
    if (BUILD.watchCallback && Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    const prototype = Cstr.prototype;
    members.map(([memberName, [memberFlags]]) => {
      if ((BUILD.prop || BUILD.state) && (memberFlags & 31 || (!BUILD.lazyLoad || flags & 2) && memberFlags & 32)) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue(this, memberName);
          },
          set(newValue) {
            if (BUILD.isDev) {
              const ref = getHostRef(this);
              if ((flags & 1) === 0 && (ref.$flags$ & 8) === 0 && (memberFlags & 31) !== 0 && (memberFlags & 1024) === 0) {
                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`);
              }
            }
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      } else if (BUILD.lazyLoad && BUILD.method && flags & 1 && memberFlags & 64) {
        Object.defineProperty(prototype, memberName, {
          value(...args) {
            const ref = getHostRef(this);
            return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
          }
        });
      }
    });
    if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags & 1)) {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
        plt.jmp(() => {
          const propName = attrNameToPropName.get(attrName);
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = members.filter(([_, m]) => m[0] & 15).map(([propName, m]) => {
        const attrName = m[1] || propName;
        attrNameToPropName.set(attrName, propName);
        if (BUILD.reflect && m[0] & 512) {
          cmpMeta.$attrsToReflect$.push([propName, attrName]);
        }
        return attrName;
      });
    }
  }
  return Cstr;
};
var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
  if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) && (hostRef.$flags$ & 32) === 0) {
    if (BUILD.lazyLoad || BUILD.hydrateClientSide) {
      hostRef.$flags$ |= 32;
      Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
      if (Cstr.then) {
        const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
        Cstr = await Cstr;
        endLoad();
      }
      if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {
        throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
      }
      if (BUILD.member && !Cstr.isProxied) {
        if (BUILD.watchCallback) {
          cmpMeta.$watchers$ = Cstr.watchers;
        }
        proxyComponent(Cstr, cmpMeta, 2);
        Cstr.isProxied = true;
      }
      const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
      if (BUILD.member) {
        hostRef.$flags$ |= 8;
      }
      try {
        new Cstr(hostRef);
      } catch (e) {
        consoleError(e);
      }
      if (BUILD.member) {
        hostRef.$flags$ &= ~8;
      }
      if (BUILD.watchCallback) {
        hostRef.$flags$ |= 128;
      }
      endNewInstance();
      fireConnectedCallback(hostRef.$lazyInstance$);
    } else {
      Cstr = elm.constructor;
      hostRef.$flags$ |= 128 | 32;
    }
    if (BUILD.style && Cstr.style) {
      let style = Cstr.style;
      if (BUILD.mode && typeof style !== "string") {
        style = style[hostRef.$modeName$ = computeMode(elm)];
        if (BUILD.hydrateServerSide && hostRef.$modeName$) {
          elm.setAttribute("s-mode", hostRef.$modeName$);
        }
      }
      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        if (!BUILD.hydrateServerSide && BUILD.shadowDom && BUILD.shadowDomShim && cmpMeta.$flags$ & 8) {
          style = await import("./shadow-css-TIFINN2P.js").then((m) => m.scopeCss(style, scopeId2, false));
        }
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  const ancestorComponent = hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  if (BUILD.asyncLoading && ancestorComponent && ancestorComponent["s-rc"]) {
    ancestorComponent["s-rc"].push(schedule);
  } else {
    schedule();
  }
};
var fireConnectedCallback = (instance) => {
  if (BUILD.lazyLoad && BUILD.connectedCallback) {
    safeCall(instance, "connectedCallback");
  }
};
var connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (BUILD.hostListenerTargetParent) {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
    }
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      let hostId;
      if (BUILD.hydrateClientSide) {
        hostId = elm.getAttribute(HYDRATE_ID);
        if (hostId) {
          if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1) {
            const scopeId2 = BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute("s-mode")) : addStyle(elm.shadowRoot, cmpMeta);
            elm.classList.remove(scopeId2 + "-h", scopeId2 + "-s");
          }
          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
        }
      }
      if (BUILD.slotRelocation && !hostId) {
        if (BUILD.hydrateServerSide || (BUILD.slot || BUILD.shadowDom) && cmpMeta.$flags$ & (4 | 8)) {
          setContentReference(elm);
        }
      }
      if (BUILD.asyncLoading) {
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          if (BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      if (BUILD.prop && BUILD.lazyLoad && !BUILD.hydrateServerSide && cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      if (BUILD.initializeNextTick) {
        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));
      } else {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
      fireConnectedCallback(hostRef.$lazyInstance$);
    }
    endConnected();
  }
};
var setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : "");
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
var disconnectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    if (BUILD.hostListener) {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
    if (BUILD.cssVarShim && plt.$cssShim$) {
      plt.$cssShim$.removeHost(elm);
    }
    if (BUILD.lazyLoad && BUILD.disconnectedCallback) {
      safeCall(instance, "disconnectedCallback");
    }
    if (BUILD.cmpDidUnload) {
      safeCall(instance, "componentDidUnload");
    }
  }
};
var proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  if (BUILD.member) {
    cmpMeta.$members$ = compactMeta[2];
  }
  if (BUILD.hostListener) {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  if (BUILD.watchCallback) {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  if (BUILD.reflect) {
    cmpMeta.$attrsToReflect$ = [];
  }
  if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1) {
    cmpMeta.$flags$ |= 8;
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      connectedCallback(this);
      if (BUILD.connectedCallback && originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (BUILD.disconnectedCallback && originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(Cstr, cmpMeta, 1 | 2);
};
var attachShadow = (el) => {
  if (supportsShadow) {
    el.attachShadow({ mode: "open" });
  } else {
    el.shadowRoot = el;
  }
};
var Fragment = (_, children) => children;
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref) => hostRefs.get(ref);
var registerHost = (elm, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: elm,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  if (BUILD.isDev) {
    hostRef.$renderCount$ = 0;
  }
  if (BUILD.method && BUILD.lazyLoad) {
    hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);
  }
  if (BUILD.asyncLoading) {
    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
    elm["s-p"] = [];
    elm["s-rc"] = [];
  }
  addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
  return hostRefs.set(elm, hostRef);
};
var isMemberInElement = (elm, memberName) => memberName in elm;
var consoleError = (e, el) => (customError || console.error)(e, el);
var STENCIL_DEV_MODE = BUILD.isTesting ? ["STENCIL:"] : ["%cstencil", "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"];
var consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);
var consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);
var cmpModules = /* @__PURE__ */ new Map();
var loadModule = (cmpMeta, hostRef, hmrVersionId) => {
  const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
  const bundleId = cmpMeta.$lazyBundleId$;
  if (BUILD.isDev && typeof bundleId !== "string") {
    consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
    return void 0;
  }
  const module = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
  if (module) {
    return module[exportName];
  }
  return import(
    /* webpackInclude: /\.entry\.js$/ */
    /* webpackExclude: /\.system\.entry\.js$/ */
    /* webpackMode: "lazy" */
    `./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? "?s-hmr=" + hmrVersionId : ""}`
  ).then((importedModule) => {
    if (!BUILD.hotModuleReplacement) {
      cmpModules.set(bundleId, importedModule);
    }
    return importedModule[exportName];
  }, consoleError);
};
var styles = /* @__PURE__ */ new Map();
var modeResolutionChain = [];
var queueDomReads = [];
var queueDomWrites = [];
var queueDomWritesLow = [];
var queueTask = (queue, write) => (cb) => {
  queue.push(cb);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4) {
      nextTick(flush);
    } else {
      plt.raf(flush);
    }
  }
};
var consume = (queue) => {
  for (let i2 = 0; i2 < queue.length; i2++) {
    try {
      queue[i2](performance.now());
    } catch (e) {
      consoleError(e);
    }
  }
  queue.length = 0;
};
var consumeTimeout = (queue, timeout) => {
  let i2 = 0;
  let ts = 0;
  while (i2 < queue.length && (ts = performance.now()) < timeout) {
    try {
      queue[i2++](ts);
    } catch (e) {
      consoleError(e);
    }
  }
  if (i2 === queue.length) {
    queue.length = 0;
  } else if (i2 !== 0) {
    queue.splice(0, i2);
  }
};
var flush = () => {
  if (BUILD.asyncQueue) {
    queueCongestion++;
  }
  consume(queueDomReads);
  if (BUILD.asyncQueue) {
    const timeout = (plt.$flags$ & 6) === 2 ? performance.now() + 14 * Math.ceil(queueCongestion * (1 / 10)) : Infinity;
    consumeTimeout(queueDomWrites, timeout);
    consumeTimeout(queueDomWritesLow, timeout);
    if (queueDomWrites.length > 0) {
      queueDomWritesLow.push(...queueDomWrites);
      queueDomWrites.length = 0;
    }
    if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
      plt.raf(flush);
    } else {
      queueCongestion = 0;
    }
  } else {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
var nextTick = (cb) => promiseResolve().then(cb);
var readTask = queueTask(queueDomReads, false);
var writeTask = queueTask(queueDomWrites, true);
var Build = {
  isDev: BUILD.isDev ? true : false,
  isBrowser: true,
  isServer: false,
  isTesting: BUILD.isTesting ? true : false
};

// node_modules/@vime/core/dist/custom-elements/index.js
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function fireEventAndRetry(el, event, onFail, interval = 300, maxRetries = 10) {
  let timeout;
  let attempt = 0;
  let found = false;
  function retry() {
    if (found)
      return;
    timeout = setTimeout(() => {
      if (attempt === maxRetries) {
        onFail === null || onFail === void 0 ? void 0 : onFail();
        return;
      }
      el.dispatchEvent(event);
      attempt += 1;
      retry();
    }, interval);
  }
  retry();
  return () => {
    window.clearTimeout(timeout);
    found = true;
  };
}
var isColliding = (a, b, translateAx = 0, translateAy = 0, translateBx = 0, translateBy = 0) => {
  const aRect = a.getBoundingClientRect();
  const bRect = b.getBoundingClientRect();
  return aRect.left + translateAx < bRect.right + translateBx && aRect.right + translateAx > bRect.left + translateBx && aRect.top + translateAy < bRect.bottom + translateBy && aRect.bottom + translateAy > bRect.top + translateBy;
};
var noop = (..._) => {
};
var isNull = (value) => value === null;
var isUndefined = (value) => typeof value === "undefined";
var isNil = (value) => isNull(value) || isUndefined(value);
var getConstructor = (value) => !isNil(value) ? value.constructor : void 0;
var isObject = (value) => getConstructor(value) === Object;
var isNumber = (value) => getConstructor(value) === Number && !Number.isNaN(value);
var isString = (value) => getConstructor(value) === String;
var isBoolean = (value) => getConstructor(value) === Boolean;
var isFunction = (value) => getConstructor(value) === Function;
var isArray = (value) => Array.isArray(value);
var isInstanceOf = (value, constructor) => Boolean(value && constructor && value instanceof constructor);
var deferredPromise = () => {
  let resolve = noop;
  let reject = noop;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
function wrapStencilHook(component, lifecycle, hook) {
  const prevHook = component[lifecycle];
  component[lifecycle] = function() {
    hook();
    return prevHook ? prevHook.call(component) : void 0;
  };
}
function createStencilHook(component, onConnect, onDisconnect) {
  let hasLoaded = false;
  if (!isUndefined(onConnect)) {
    wrapStencilHook(component, "componentWillLoad", () => {
      onConnect();
      hasLoaded = true;
    });
    wrapStencilHook(component, "connectedCallback", () => {
      if (hasLoaded)
        onConnect();
    });
  }
  if (!isUndefined(onDisconnect)) {
    wrapStencilHook(component, "disconnectedCallback", () => {
      onDisconnect();
    });
  }
}
var FIND_PLAYER_EVENT = "vmFindPlayer";
function withFindPlayer(player) {
  const el = getElement(player);
  let off;
  createStencilHook(player, () => {
    off = listen(el, FIND_PLAYER_EVENT, (event) => {
      event.stopPropagation();
      event.detail(el);
    });
  }, () => {
    off === null || off === void 0 ? void 0 : off();
  });
}
var findPlayer = (ref, interval = 300, maxRetries = 10) => {
  const el = isInstanceOf(ref, HTMLElement) ? ref : getElement(ref);
  const search = deferredPromise();
  let stopFiring;
  const event = new CustomEvent(FIND_PLAYER_EVENT, {
    bubbles: true,
    composed: true,
    detail: (player) => {
      search.resolve(player);
      stopFiring();
    }
  });
  stopFiring = fireEventAndRetry(el, event, () => {
    search.reject(`Could not find player for ${el.nodeName}`);
  }, interval, maxRetries);
  return search.promise;
};
var MediaType;
(function(MediaType2) {
  MediaType2["Audio"] = "audio";
  MediaType2["Video"] = "video";
})(MediaType || (MediaType = {}));
var STATE_CHANGE_EVENT = "vmStateChange";
var createDispatcher = (ref) => (prop, value) => {
  const el = isInstanceOf(ref, HTMLElement) ? ref : getElement(ref);
  const event = new CustomEvent(STATE_CHANGE_EVENT, {
    bubbles: true,
    composed: true,
    detail: { by: el, prop, value }
  });
  el.dispatchEvent(event);
};
var en = {
  play: "Play",
  pause: "Pause",
  playback: "Playback",
  scrubber: "Scrubber",
  scrubberLabel: "{currentTime} of {duration}",
  played: "Played",
  duration: "Duration",
  buffered: "Buffered",
  close: "Close",
  currentTime: "Current time",
  live: "LIVE",
  volume: "Volume",
  mute: "Mute",
  unmute: "Unmute",
  audio: "Audio",
  default: "Default",
  captions: "Captions",
  subtitlesOrCc: "Subtitles/CC",
  enableCaptions: "Enable subtitles/captions",
  disableCaptions: "Disable subtitles/captions",
  auto: "Auto",
  fullscreen: "Fullscreen",
  enterFullscreen: "Enter fullscreen",
  exitFullscreen: "Exit fullscreen",
  settings: "Settings",
  seekForward: "Seek forward",
  seekBackward: "Seek backward",
  seekTotal: "Seek total",
  normal: "Normal",
  none: "None",
  playbackRate: "Playback Rate",
  playbackQuality: "Playback Quality",
  loop: "Loop",
  disabled: "Disabled",
  off: "Off",
  enabled: "Enabled",
  pip: "Picture-in-Picture",
  enterPiP: "Miniplayer",
  exitPiP: "Expand"
};
var initialState = {
  theme: void 0,
  paused: true,
  playing: false,
  duration: -1,
  currentProvider: void 0,
  mediaTitle: void 0,
  currentSrc: void 0,
  currentPoster: void 0,
  textTracks: [],
  currentTextTrack: -1,
  audioTracks: [],
  currentAudioTrack: -1,
  isTextTrackVisible: true,
  shouldRenderNativeTextTracks: true,
  icons: "vime",
  currentTime: 0,
  autoplay: false,
  ready: false,
  playbackReady: false,
  loop: false,
  muted: false,
  buffered: 0,
  playbackRate: 1,
  playbackRates: [1],
  playbackQuality: void 0,
  playbackQualities: [],
  seeking: false,
  debug: false,
  playbackStarted: false,
  playbackEnded: false,
  buffering: false,
  controls: false,
  isControlsActive: false,
  volume: 50,
  isFullscreenActive: false,
  aspectRatio: "16:9",
  viewType: void 0,
  isAudioView: false,
  isVideoView: false,
  mediaType: void 0,
  isAudio: false,
  isVideo: false,
  isMobile: false,
  isTouch: false,
  isSettingsActive: false,
  isLive: false,
  isPiPActive: false,
  autopause: true,
  playsinline: false,
  language: "en",
  languages: ["en"],
  translations: { en },
  i18n: en
};
var writableProps = /* @__PURE__ */ new Set([
  "autoplay",
  "autopause",
  "aspectRatio",
  "controls",
  "theme",
  "debug",
  "paused",
  "currentTime",
  "language",
  "loop",
  "translations",
  "playbackQuality",
  "muted",
  "playbackRate",
  "playsinline",
  "volume",
  "isSettingsActive",
  "isControlsActive",
  "shouldRenderNativeTextTracks"
]);
var isWritableProp = (prop) => writableProps.has(prop);
var resetableProps = /* @__PURE__ */ new Set([
  "paused",
  "currentTime",
  "duration",
  "buffered",
  "seeking",
  "playing",
  "buffering",
  "playbackReady",
  "textTracks",
  "currentTextTrack",
  "audioTracks",
  "currentAudioTrack",
  "mediaTitle",
  "currentSrc",
  "currentPoster",
  "playbackRate",
  "playbackRates",
  "playbackStarted",
  "playbackEnded",
  "playbackQuality",
  "playbackQualities",
  "mediaType"
]);
var shouldPropResetOnMediaChange = (prop) => resetableProps.has(prop);
var ViewType;
(function(ViewType2) {
  ViewType2["Audio"] = "audio";
  ViewType2["Video"] = "video";
})(ViewType || (ViewType = {}));
var Disposal = class {
  constructor(dispose = []) {
    this.dispose = dispose;
  }
  add(callback) {
    this.dispose.push(callback);
  }
  empty() {
    this.dispose.forEach((fn) => fn());
    this.dispose = [];
  }
};
var __awaiter$y = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PLAYER_KEY = Symbol("vmPlayerKey");
var COMPONENT_NAME_KEY = Symbol("vmNameKey");
var REGISTRY_KEY = Symbol("vmRegistryKey");
var REGISTRATION_KEY = Symbol("vmRegistrationKey");
var REGISTER_COMPONENT_EVENT = "vmComponentRegister";
var COMPONENT_REGISTERED_EVENT = "vmComponentRegistered";
var COMPONENT_DEREGISTERED_EVENT = "vmComponentDeregistered";
var getRegistrant = (ref) => isInstanceOf(ref, HTMLElement) ? ref : getElement(ref);
function withComponentRegistry(ref, name) {
  const registryId = Symbol("vmRegistryId");
  const registrant = getRegistrant(ref);
  registrant[COMPONENT_NAME_KEY] = name !== null && name !== void 0 ? name : registrant.nodeName.toLowerCase();
  registrant[REGISTRATION_KEY] = registryId;
  const buildEvent = (eventName) => new CustomEvent(eventName, {
    bubbles: true,
    composed: true,
    detail: registrant
  });
  const registerEvent = buildEvent(REGISTER_COMPONENT_EVENT);
  createStencilHook(ref, () => {
    registrant.dispatchEvent(registerEvent);
  });
}
function withComponentRegistrar(player) {
  const el = getElement(player);
  const registry2 = /* @__PURE__ */ new Map();
  const disposal = new Disposal();
  el[REGISTRY_KEY] = registry2;
  function onDeregister(registrant) {
    delete registrant[PLAYER_KEY];
    delete registrant[REGISTRY_KEY];
    registry2.delete(registrant[REGISTRATION_KEY]);
    el.dispatchEvent(new CustomEvent(COMPONENT_DEREGISTERED_EVENT, { detail: registrant }));
  }
  function onRegister(e) {
    const ref = e.detail;
    const registrant = getRegistrant(ref);
    registrant[PLAYER_KEY] = el;
    registrant[REGISTRY_KEY] = registry2;
    registry2.set(registrant[REGISTRATION_KEY], registrant);
    el.dispatchEvent(new CustomEvent(COMPONENT_REGISTERED_EVENT, { detail: registrant }));
    createStencilHook(ref, void 0, () => onDeregister(registrant));
  }
  createStencilHook(player, () => {
    disposal.add(listen(el, REGISTER_COMPONENT_EVENT, onRegister));
  }, () => {
    registry2.clear();
    disposal.empty();
    delete player[REGISTRY_KEY];
  });
}
function isComponentRegistered(ref, name) {
  var _a2;
  const registrant = getRegistrant(ref);
  const registry2 = registrant[REGISTRY_KEY];
  return Array.from((_a2 = registry2 === null || registry2 === void 0 ? void 0 : registry2.values()) !== null && _a2 !== void 0 ? _a2 : []).some((r) => r[COMPONENT_NAME_KEY] === name);
}
function getPlayerFromRegistry(ref) {
  const registrant = getRegistrant(ref);
  return registrant[PLAYER_KEY];
}
function getComponentFromRegistry(ref, name) {
  var _a2, _b2;
  const registrant = getRegistrant(ref);
  return Array.from((_b2 = (_a2 = registrant[REGISTRY_KEY]) === null || _a2 === void 0 ? void 0 : _a2.values()) !== null && _b2 !== void 0 ? _b2 : []).filter((r) => r[COMPONENT_NAME_KEY] === name);
}
function watchComponentRegistry(ref, name, onChange) {
  var _a2;
  return __awaiter$y(this, void 0, void 0, function* () {
    const player = yield findPlayer(ref);
    const disposal = new Disposal();
    const registry2 = getRegistrant(ref)[REGISTRY_KEY];
    function listener(e) {
      if (e.detail[COMPONENT_NAME_KEY] === name)
        onChange === null || onChange === void 0 ? void 0 : onChange(getComponentFromRegistry(player, name));
    }
    Array.from((_a2 = registry2 === null || registry2 === void 0 ? void 0 : registry2.values()) !== null && _a2 !== void 0 ? _a2 : []).forEach((reg) => listener(new CustomEvent("", { detail: reg })));
    if (!isUndefined(player)) {
      disposal.add(listen(player, COMPONENT_REGISTERED_EVENT, listener));
      disposal.add(listen(player, COMPONENT_DEREGISTERED_EVENT, listener));
    }
    createStencilHook(ref, () => {
    }, () => {
      disposal.empty();
    });
    return () => {
      disposal.empty();
    };
  });
}
var createDeferredPromise = function() {
  var resolve;
  var promise = new Promise(function(res) {
    resolve = res;
  });
  return { promise, resolve };
};
var openWormhole = function(Component, props, isBlocking) {
  if (isBlocking === void 0) {
    isBlocking = true;
  }
  var isConstructor = Component.constructor.name === "Function";
  var Proto = isConstructor ? Component.prototype : Component;
  var componentWillLoad = Proto.componentWillLoad;
  Proto.componentWillLoad = function() {
    var _this = this;
    var el = getElement(this);
    var onOpen = createDeferredPromise();
    var event = new CustomEvent("openWormhole", {
      bubbles: true,
      composed: true,
      detail: {
        consumer: this,
        fields: props,
        updater: function(prop, value) {
          var target = prop in el ? el : _this;
          target[prop] = value;
        },
        onOpen
      }
    });
    el.dispatchEvent(event);
    var willLoad = function() {
      if (componentWillLoad) {
        return componentWillLoad.call(_this);
      }
    };
    return isBlocking ? onOpen.promise.then(function() {
      return willLoad();
    }) : willLoad();
  };
};
var multiverse = /* @__PURE__ */ new Map();
var updateConsumer = function(_a2, state) {
  var fields = _a2.fields, updater = _a2.updater;
  fields.forEach(function(field) {
    updater(field, state[field]);
  });
};
var Universe = {
  create: function(creator, initialState2) {
    var el = getElement(creator);
    var wormholes = /* @__PURE__ */ new Map();
    var universe = { wormholes, state: initialState2 };
    multiverse.set(creator, universe);
    var connectedCallback2 = creator.connectedCallback;
    creator.connectedCallback = function() {
      multiverse.set(creator, universe);
      if (connectedCallback2) {
        connectedCallback2.call(creator);
      }
    };
    var disconnectedCallback2 = creator.disconnectedCallback;
    creator.disconnectedCallback = function() {
      multiverse.delete(creator);
      if (disconnectedCallback2) {
        disconnectedCallback2.call(creator);
      }
    };
    el.addEventListener("openWormhole", function(event) {
      event.stopPropagation();
      var _a2 = event.detail, consumer = _a2.consumer, onOpen = _a2.onOpen;
      if (wormholes.has(consumer))
        return;
      if (typeof consumer !== "symbol") {
        var connectedCallback_1 = consumer.connectedCallback, disconnectedCallback_1 = consumer.disconnectedCallback;
        consumer.connectedCallback = function() {
          wormholes.set(consumer, event.detail);
          if (connectedCallback_1) {
            connectedCallback_1.call(consumer);
          }
        };
        consumer.disconnectedCallback = function() {
          wormholes.delete(consumer);
          if (disconnectedCallback_1) {
            disconnectedCallback_1.call(consumer);
          }
        };
      }
      wormholes.set(consumer, event.detail);
      updateConsumer(event.detail, universe.state);
      onOpen === null || onOpen === void 0 ? void 0 : onOpen.resolve(function() {
        wormholes.delete(consumer);
      });
    });
    el.addEventListener("closeWormhole", function(event) {
      var consumer = event.detail;
      wormholes.delete(consumer);
    });
  },
  Provider: function(_a2, children) {
    var state = _a2.state;
    var creator = getRenderingRef();
    if (multiverse.has(creator)) {
      var universe = multiverse.get(creator);
      universe.state = state;
      universe.wormholes.forEach(function(opening) {
        updateConsumer(opening, state);
      });
    }
    return children;
  }
};
var LOAD_START_EVENT = "vmLoadStart";
var isToggleStateEvent = /* @__PURE__ */ new Set([
  "isFullscreenActive",
  "isControlsActive",
  "isTextTrackVisible",
  "isPiPActive",
  "isLive",
  "isTouch",
  "isAudio",
  "isVideo",
  "isAudioView",
  "isVideoView"
]);
var hasShortenedEventName = /* @__PURE__ */ new Set([
  "ready",
  "playbackStarted",
  "playbackEnded",
  "playbackReady"
]);
var getEventName = (prop) => {
  if (isToggleStateEvent.has(prop)) {
    return `vm${prop.replace("is", "").replace("Active", "")}Change`;
  }
  if (hasShortenedEventName.has(prop)) {
    return `vm${prop.charAt(0).toUpperCase()}${prop.slice(1)}`;
  }
  return `vm${prop.charAt(0).toUpperCase()}${prop.slice(1)}Change`;
};
function firePlayerEvent(el, prop, newValue, oldValue) {
  const events = [];
  events.push(new CustomEvent(getEventName(prop), { detail: newValue }));
  if (prop === "paused" && !newValue)
    events.push(new CustomEvent("vmPlay"));
  if (prop === "seeking" && oldValue && !newValue)
    events.push(new CustomEvent("vmSeeked"));
  events.forEach((event) => {
    el.dispatchEvent(event);
  });
}
var __awaiter$x = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var withPlayerContext = (component, props) => openWormhole(component, props);
var usePlayerContext = (ref, props, updater, playerRef2) => __awaiter$x(void 0, void 0, void 0, function* () {
  const player = playerRef2 !== null && playerRef2 !== void 0 ? playerRef2 : yield findPlayer(ref);
  const listeners = !isUndefined(player) ? props.map((prop) => {
    const event = getEventName(prop);
    return listen(player, event, () => {
      updater(prop, player[prop]);
    });
  }) : [];
  return () => {
    listeners.forEach((off) => off());
  };
});
var Provider;
(function(Provider2) {
  Provider2["Audio"] = "audio";
  Provider2["Video"] = "video";
  Provider2["HLS"] = "hls";
  Provider2["Dash"] = "dash";
  Provider2["YouTube"] = "youtube";
  Provider2["Vimeo"] = "vimeo";
  Provider2["Dailymotion"] = "dailymotion";
})(Provider || (Provider = {}));
var audioRegex = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
var videoRegex = /\.(mp4|og[gv]|webm|mov|m4v)($|\?)/i;
var hlsRegex = /\.(m3u8)($|\?)/i;
var hlsTypeRegex = /^application\/(x-mpegURL|vnd\.apple\.mpegURL)$/i;
var dashRegex = /\.(mpd)($|\?)/i;
var PROVIDER_CHANGE_EVENT = "vmProviderChange";
var createProviderDispatcher = (ref) => (prop, value) => {
  const el = isInstanceOf(ref, HTMLElement) ? ref : getElement(ref);
  const event = new CustomEvent(PROVIDER_CHANGE_EVENT, {
    bubbles: true,
    composed: true,
    detail: { by: el, prop, value }
  });
  el.dispatchEvent(event);
};
var providerWritableProps = /* @__PURE__ */ new Set([
  "ready",
  "playing",
  "playbackReady",
  "playbackStarted",
  "playbackEnded",
  "seeking",
  "buffered",
  "buffering",
  "duration",
  "viewType",
  "mediaTitle",
  "mediaType",
  "currentSrc",
  "currentPoster",
  "playbackRates",
  "playbackQualities",
  "textTracks",
  "currentTextTrack",
  "isTextTrackVisible",
  "audioTracks",
  "currentAudioTrack",
  "isPiPActive",
  "isFullscreenActive"
]);
var isProviderWritableProp = (prop) => isWritableProp(prop) || providerWritableProps.has(prop);
var __awaiter$w = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PROVIDER_CACHE_KEY = Symbol("vmProviderCache");
var PROVIDER_CONNECT_EVENT = "vmMediaProviderConnect";
var PROVIDER_DISCONNECT_EVENT = "vmMediaProviderDisconnect";
function buildProviderConnectEvent(name, host) {
  return new CustomEvent(name, {
    bubbles: true,
    composed: true,
    detail: host
  });
}
function withProviderHost(connector) {
  const el = getElement(connector);
  const disposal = new Disposal();
  const cache = /* @__PURE__ */ new Map();
  connector[PROVIDER_CACHE_KEY] = cache;
  function initCache() {
    Object.keys(connector).forEach((prop) => {
      cache.set(prop, connector[prop]);
    });
  }
  function onDisconnect() {
    writeTask(() => __awaiter$w(this, void 0, void 0, function* () {
      var _a2;
      connector.ready = false;
      connector.provider = void 0;
      cache.clear();
      (_a2 = connector.onProviderDisconnect) === null || _a2 === void 0 ? void 0 : _a2.call(connector);
      el.dispatchEvent(buildProviderConnectEvent(PROVIDER_DISCONNECT_EVENT));
    }));
  }
  function onConnect(event) {
    event.stopImmediatePropagation();
    initCache();
    const hostRef = event.detail;
    const host = getElement(event.detail);
    if (connector.provider === host)
      return;
    const name = host === null || host === void 0 ? void 0 : host.nodeName.toLowerCase().replace("vm-", "");
    writeTask(() => __awaiter$w(this, void 0, void 0, function* () {
      connector.provider = host;
      connector.currentProvider = Object.values(Provider).find((provider) => name === provider);
      createStencilHook(hostRef, void 0, () => onDisconnect());
    }));
  }
  function onChange(event) {
    var _a2;
    event.stopImmediatePropagation();
    const { by, prop, value } = event.detail;
    if (!isProviderWritableProp(prop)) {
      (_a2 = connector.logger) === null || _a2 === void 0 ? void 0 : _a2.warn(`${by.nodeName} tried to change \`${prop}\` but it is readonly.`);
      return;
    }
    writeTask(() => {
      cache.set(prop, value);
      connector[prop] = value;
    });
  }
  createStencilHook(connector, () => {
    disposal.add(listen(el, PROVIDER_CONNECT_EVENT, onConnect));
    disposal.add(listen(el, PROVIDER_CHANGE_EVENT, onChange));
  }, () => {
    disposal.empty();
    cache.clear();
  });
}
function withProviderConnect(ref) {
  const connectEvent = buildProviderConnectEvent(PROVIDER_CONNECT_EVENT, ref);
  createStencilHook(ref, () => {
    getElement(ref).dispatchEvent(connectEvent);
  });
}
var __awaiter$v = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Audio = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.willAttach = false;
    this.preload = "metadata";
    withComponentRegistry(this);
    if (!this.willAttach)
      withProviderConnect(this);
  }
  getAdapter() {
    var _a2, _b2;
    return __awaiter$v(this, void 0, void 0, function* () {
      const adapter = (_b2 = yield (_a2 = this.fileProvider) === null || _a2 === void 0 ? void 0 : _a2.getAdapter()) !== null && _b2 !== void 0 ? _b2 : {};
      adapter.canPlay = (type) => __awaiter$v(this, void 0, void 0, function* () {
        return isString(type) && audioRegex.test(type);
      });
      return adapter;
    });
  }
  render() {
    return h("vm-file", { noConnect: true, willAttach: this.willAttach, crossOrigin: this.crossOrigin, preload: this.preload, disableRemotePlayback: this.disableRemotePlayback, mediaTitle: this.mediaTitle, viewType: ViewType.Audio, ref: (el) => {
      this.fileProvider = el;
    } }, h("slot", null));
  }
};
var captionControlCss = ":host([hidden]){display:none}";
var __awaiter$u = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CaptionControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.canToggleCaptionVisibility = false;
    this.showIcon = "captions-on";
    this.hideIcon = "captions-off";
    this.tooltipPosition = "top";
    this.hideTooltip = false;
    this.keys = "c";
    this.i18n = {};
    this.playbackReady = false;
    this.textTracks = [];
    this.isTextTrackVisible = false;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "i18n",
      "textTracks",
      "isTextTrackVisible",
      "playbackReady"
    ]);
  }
  onTextTracksChange() {
    var _a2;
    return __awaiter$u(this, void 0, void 0, function* () {
      const player = getPlayerFromRegistry(this);
      this.canToggleCaptionVisibility = this.textTracks.length > 0 && ((_a2 = yield player === null || player === void 0 ? void 0 : player.canSetTextTrackVisibility()) !== null && _a2 !== void 0 ? _a2 : false);
    });
  }
  componentDidLoad() {
    this.onTextTracksChange();
  }
  onClick() {
    var _a2;
    const player = getPlayerFromRegistry(this);
    (_a2 = player === null || player === void 0 ? void 0 : player.setTextTrackVisibility) === null || _a2 === void 0 ? void 0 : _a2.call(player, !this.isTextTrackVisible);
  }
  render() {
    const tooltip = this.isTextTrackVisible ? this.i18n.disableCaptions : this.i18n.enableCaptions;
    const tooltipWithHint = !isUndefined(this.keys) ? `${tooltip} (${this.keys})` : tooltip;
    return h(Host, { hidden: !this.canToggleCaptionVisibility }, h("vm-control", { label: this.i18n.captions, keys: this.keys, hidden: !this.canToggleCaptionVisibility, pressed: this.isTextTrackVisible, onClick: this.onClick.bind(this) }, h("vm-icon", { name: this.isTextTrackVisible ? this.showIcon : this.hideIcon, library: this.icons }), h("vm-tooltip", { hidden: this.hideTooltip, position: this.tooltipPosition, direction: this.tooltipDirection }, tooltipWithHint)));
  }
  static get watchers() {
    return {
      "textTracks": ["onTextTracksChange"],
      "playbackReady": ["onTextTracksChange"]
    };
  }
  static get style() {
    return captionControlCss;
  }
};
var watch$1 = /* @__PURE__ */ new Set();
var controls = /* @__PURE__ */ new Set();
var collisions = /* @__PURE__ */ new Map();
function update() {
  writeTask(() => {
    controls.forEach((controlsEl) => {
      const controlsHeight = parseFloat(window.getComputedStyle(controlsEl).height);
      watch$1.forEach((watchedEl) => {
        const watchedElCollisions = collisions.get(watchedEl);
        const hasCollided = isColliding(watchedEl, controlsEl);
        const willCollide = isColliding(watchedEl, controlsEl, 0, controlsHeight) || isColliding(watchedEl, controlsEl, 0, -controlsHeight);
        watchedElCollisions.set(controlsEl, hasCollided || willCollide ? controlsHeight : 0);
      });
    });
    watch$1.forEach((watchedEl) => {
      const watchedElCollisions = collisions.get(watchedEl);
      watchedEl.style.setProperty("--vm-controls-height", `${Math.max(0, Math.max(...watchedElCollisions.values()))}px`);
    });
  });
}
function registerControlsForCollisionDetection(component) {
  const el = getElement(component);
  function getInnerEl() {
    return el.shadowRoot.querySelector(".controls");
  }
  createStencilHook(component, () => {
    const innerEl = getInnerEl();
    if (!isNull(innerEl)) {
      controls.add(innerEl);
      update();
    }
  }, () => {
    controls.delete(getInnerEl());
    update();
  });
  wrapStencilHook(component, "componentDidLoad", () => {
    controls.add(getInnerEl());
    update();
  });
  wrapStencilHook(component, "componentDidRender", update);
}
function withControlsCollisionDetection(component) {
  const el = getElement(component);
  createStencilHook(component, () => {
    watch$1.add(el);
    collisions.set(el, /* @__PURE__ */ new Map());
    update();
  }, () => {
    watch$1.delete(el);
    collisions.delete(el);
  });
}
var captionsCss = ":host{position:absolute;left:0;bottom:0;width:100%;pointer-events:none;z-index:var(--vm-captions-z-index)}.captions{width:100%;text-align:center;color:var(--vm-captions-text-color);font-size:var(--vm-captions-font-size);padding:$control-spacing;display:none;pointer-events:none;transition:transform 0.4s ease-in-out, opacity 0.3s ease-in-out}.captions.enabled{display:inline-block}.captions.hidden{display:none !important}.captions.inactive{opacity:0;visibility:hidden}.captions.fontMd{font-size:var(--vm-captions-font-size-medium)}.captions.fontLg{font-size:var(--vm-captions-font-size-large)}.captions.fontXl{font-size:var(--vm-captions-font-size-xlarge)}.cue{display:inline-block;background:var(--vm-captions-cue-bg-color);border-radius:var(--vm-captions-cue-border-radius);box-decoration-break:clone;line-height:185%;padding:var(--vm-captions-cue-padding);white-space:pre-wrap;pointer-events:none}.cue>div{display:inline}.cue:empty{display:none}";
var __awaiter$t = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Captions = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.sizeDisposal = new Disposal();
    this.textDisposal = new Disposal();
    this.isEnabled = false;
    this.fontSize = "sm";
    this.hidden = false;
    this.isControlsActive = false;
    this.isVideoView = false;
    this.playbackStarted = false;
    this.textTracks = [];
    this.currentTextTrack = -1;
    this.isTextTrackVisible = true;
    withComponentRegistry(this);
    withControlsCollisionDetection(this);
    withPlayerContext(this, [
      "isVideoView",
      "playbackStarted",
      "isControlsActive",
      "textTracks",
      "currentTextTrack",
      "isTextTrackVisible"
    ]);
  }
  onEnabledChange() {
    this.isEnabled = this.playbackStarted && this.isVideoView;
  }
  onTextTracksChange() {
    const textTrack = this.textTracks[this.currentTextTrack];
    const renderCues = () => {
      var _a2;
      const activeCues = Array.from((_a2 = textTrack.activeCues) !== null && _a2 !== void 0 ? _a2 : []);
      this.renderCurrentCue(activeCues[0]);
    };
    this.textDisposal.empty();
    if (!isNil(textTrack)) {
      renderCues();
      this.textDisposal.add(listen(textTrack, "cuechange", renderCues));
    }
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
    this.dispatch("shouldRenderNativeTextTracks", false);
    this.onTextTracksChange();
    this.onPlayerResize();
  }
  disconnectedCallback() {
    this.textDisposal.empty();
    this.sizeDisposal.empty();
    this.dispatch("shouldRenderNativeTextTracks", true);
  }
  onPlayerResize() {
    return __awaiter$t(this, void 0, void 0, function* () {
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      const container = yield player.getContainer();
      const resizeObs = new ResizeObserver((entries) => {
        const entry = entries[0];
        const { width } = entry.contentRect;
        if (width >= 1360) {
          this.fontSize = "xl";
        } else if (width >= 1024) {
          this.fontSize = "lg";
        } else if (width >= 768) {
          this.fontSize = "md";
        } else {
          this.fontSize = "sm";
        }
      });
      resizeObs.observe(container);
    });
  }
  renderCurrentCue(cue) {
    if (isNil(cue)) {
      this.cue = "";
      return;
    }
    const div = document.createElement("div");
    div.append(cue.getCueAsHTML());
    this.cue = div.innerHTML.trim();
  }
  render() {
    return h("div", { style: {
      transform: `translateY(calc(${this.isControlsActive ? "var(--vm-controls-height)" : "24px"} * -1))`
    }, class: {
      captions: true,
      enabled: this.isEnabled,
      hidden: this.hidden,
      fontMd: this.fontSize === "md",
      fontLg: this.fontSize === "lg",
      fontXl: this.fontSize === "xl",
      inactive: !this.isTextTrackVisible
    } }, h("span", { class: "cue" }, this.cue));
  }
  static get watchers() {
    return {
      "isVideoView": ["onEnabledChange"],
      "playbackStarted": ["onEnabledChange"],
      "textTracks": ["onTextTracksChange"],
      "currentTextTrack": ["onTextTracksChange"]
    };
  }
  static get style() {
    return captionsCss;
  }
};
var clickToPlayCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-click-to-play-z-index)}.clickToPlay{display:none;width:100%;height:100%;pointer-events:none}.clickToPlay.enabled{display:inline-block;pointer-events:auto}";
var __awaiter$s = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClickToPlay = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.useOnMobile = false;
    this.paused = true;
    this.isVideoView = false;
    this.isMobile = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["paused", "isVideoView", "isMobile"]);
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }
  forceClick() {
    return __awaiter$s(this, void 0, void 0, function* () {
      this.onClick();
    });
  }
  onClick() {
    this.dispatch("paused", !this.paused);
  }
  render() {
    return h("div", { class: {
      clickToPlay: true,
      enabled: this.isVideoView && (!this.isMobile || this.useOnMobile)
    }, onClick: this.onClick.bind(this) });
  }
  static get style() {
    return clickToPlayCss;
  }
};
var controlCss = "button{display:flex;align-items:center;flex-direction:row;border:var(--vm-control-border);cursor:pointer;flex-shrink:0;font-size:var(--vm-control-icon-size);color:var(--vm-control-color);background:var(--vm-control-bg, transparent);border-radius:var(--vm-control-border-radius);padding:var(--vm-control-padding);position:relative;pointer-events:auto;transition:all 0.3s ease;transform:scale(var(--vm-control-scale, 1));touch-action:manipulation;box-sizing:border-box}button.hidden{display:none}button:focus{outline:0}button.tapHighlight{background:var(--vm-control-tap-highlight)}button.notTouch:focus,button.notTouch:hover,button.notTouch[aria-expanded='true']{background:var(--vm-control-focus-bg);color:var(--vm-control-focus-color);transform:scale(calc(var(--vm-control-scale, 1) + 0.06))}";
var __awaiter$r = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Control = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmInteractionChange = createEvent(this, "vmInteractionChange", 7);
    this.vmFocus = createEvent(this, "vmFocus", 7);
    this.vmBlur = createEvent(this, "vmBlur", 7);
    this.keyboardDisposal = new Disposal();
    this.showTapHighlight = false;
    this.hidden = false;
    this.isTouch = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["isTouch"]);
  }
  onKeysChange() {
    return __awaiter$r(this, void 0, void 0, function* () {
      this.keyboardDisposal.empty();
      if (isUndefined(this.keys))
        return;
      const player = yield findPlayer(this);
      const codes = this.keys.split("/");
      if (isUndefined(player))
        return;
      this.keyboardDisposal.add(listen(player, "keydown", (event) => {
        if (codes.includes(event.key)) {
          this.button.click();
        }
      }));
    });
  }
  connectedCallback() {
    this.findTooltip();
    this.onKeysChange();
  }
  componentWillLoad() {
    this.findTooltip();
  }
  disconnectedCallback() {
    this.keyboardDisposal.empty();
  }
  focusControl() {
    var _a2;
    return __awaiter$r(this, void 0, void 0, function* () {
      (_a2 = this.button) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  }
  blurControl() {
    var _a2;
    return __awaiter$r(this, void 0, void 0, function* () {
      (_a2 = this.button) === null || _a2 === void 0 ? void 0 : _a2.blur();
    });
  }
  onTouchStart() {
    this.showTapHighlight = true;
  }
  onTouchEnd() {
    setTimeout(() => {
      this.showTapHighlight = false;
    }, 100);
  }
  findTooltip() {
    const tooltip = this.host.querySelector("vm-tooltip");
    if (!isNull(tooltip))
      this.describedBy = tooltip.id;
    return tooltip;
  }
  onShowTooltip() {
    const tooltip = this.findTooltip();
    if (!isNull(tooltip))
      tooltip.active = true;
    this.vmInteractionChange.emit(true);
  }
  onHideTooltip() {
    const tooltip = this.findTooltip();
    if (!isNull(tooltip))
      tooltip.active = false;
    this.button.blur();
    this.vmInteractionChange.emit(false);
  }
  onFocus() {
    this.vmFocus.emit();
    this.onShowTooltip();
  }
  onBlur() {
    this.vmBlur.emit();
    this.onHideTooltip();
  }
  onMouseEnter() {
    this.onShowTooltip();
  }
  onMouseLeave() {
    this.onHideTooltip();
  }
  render() {
    const isMenuExpanded = this.expanded ? "true" : "false";
    const isPressed = this.pressed ? "true" : "false";
    return h("button", { class: {
      hidden: this.hidden,
      notTouch: !this.isTouch,
      tapHighlight: this.showTapHighlight
    }, id: this.identifier, type: "button", "aria-label": this.label, "aria-haspopup": !isUndefined(this.menu) ? "true" : void 0, "aria-controls": this.menu, "aria-expanded": !isUndefined(this.menu) ? isMenuExpanded : void 0, "aria-pressed": !isUndefined(this.pressed) ? isPressed : void 0, "aria-hidden": this.hidden ? "true" : "false", "aria-describedby": this.describedBy, onTouchStart: this.onTouchStart.bind(this), onTouchEnd: this.onTouchEnd.bind(this), onFocus: this.onFocus.bind(this), onBlur: this.onBlur.bind(this), onMouseEnter: this.onMouseEnter.bind(this), onMouseLeave: this.onMouseLeave.bind(this), ref: (el) => {
      this.button = el;
    } }, h("slot", null));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "keys": ["onKeysChange"]
    };
  }
  static get style() {
    return controlCss;
  }
};
var controlGroupCss = ":host{width:100%}.controlGroup{position:relative;width:100%;display:flex;flex-wrap:wrap;flex-direction:inherit;align-items:inherit;justify-content:inherit;box-sizing:border-box}.controlGroup.spaceTop{margin-top:var(--vm-control-group-spacing)}.controlGroup.spaceBottom{margin-bottom:var(--vm-control-group-spacing)}::slotted(*){margin-left:var(--vm-controls-spacing)}::slotted(*:first-child){margin-left:0}";
var ControlNewLine = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.space = "none";
    withComponentRegistry(this);
  }
  render() {
    return h("div", { class: {
      controlGroup: true,
      spaceTop: this.space !== "none" && this.space !== "bottom",
      spaceBottom: this.space !== "none" && this.space !== "top"
    } }, h("slot", null));
  }
  get host() {
    return this;
  }
  static get style() {
    return controlGroupCss;
  }
};
var controlSpacerCss = ":host{flex:1}";
var ControlSpacer = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    withComponentRegistry(this);
  }
  static get style() {
    return controlSpacerCss;
  }
};
var debounce = (func, wait = 1e3, immediate = false) => {
  let timeout;
  return function executedFunction(...args) {
    const context = this;
    const later = function delayedFunctionCall() {
      timeout = void 0;
      if (!immediate)
        func.apply(context, args);
    };
    const callNow = immediate && isUndefined(timeout);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(context, args);
  };
};
var controlsCss = ":host{position:relative;width:100%;z-index:var(--vm-controls-z-index)}:host([video]){position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.controls{display:flex;width:100%;position:absolute;flex-wrap:wrap;pointer-events:auto;box-sizing:border-box;background:var(--vm-controls-bg);padding:var(--vm-controls-padding);border-radius:var(--vm-controls-border-radius);opacity:0;visibility:hidden;transition:var(--vm-fade-transition)}.controls.audio{position:relative}.controls.hidden{display:none}.controls.active{opacity:1;visibility:visible}.controls.fullWidth{width:100%}.controls.fullHeight{height:100%}::slotted(*:not(vm-control-group)){margin-left:var(--vm-controls-spacing)}::slotted(*:not(vm-control-group):first-child){margin-left:0}";
var __awaiter$q = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var playerRef = {};
var hideControlsTimeout = {};
var Controls = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.disposal = new Disposal();
    this.isInteracting = false;
    this.hidden = false;
    this.fullWidth = false;
    this.fullHeight = false;
    this.direction = "row";
    this.align = "center";
    this.justify = "start";
    this.pin = "bottomLeft";
    this.activeDuration = 2750;
    this.waitForPlaybackStart = false;
    this.hideWhenPaused = false;
    this.hideOnMouseLeave = false;
    this.isAudioView = false;
    this.isSettingsActive = false;
    this.playbackReady = false;
    this.isControlsActive = false;
    this.paused = true;
    this.playbackStarted = false;
    withComponentRegistry(this);
    registerControlsForCollisionDetection(this);
    withPlayerContext(this, [
      "playbackReady",
      "isAudioView",
      "isControlsActive",
      "isSettingsActive",
      "paused",
      "playbackStarted"
    ]);
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
    this.onControlsChange();
    this.setupPlayerListeners();
  }
  componentWillLoad() {
    this.onControlsChange();
  }
  disconnectedCallback() {
    this.disposal.empty();
    delete hideControlsTimeout[playerRef[this]];
    delete playerRef[this];
  }
  setupPlayerListeners() {
    return __awaiter$q(this, void 0, void 0, function* () {
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      const events = ["focus", "keydown", "click", "touchstart", "mouseleave"];
      events.forEach((event) => {
        this.disposal.add(listen(player, event, this.onControlsChange.bind(this)));
      });
      this.disposal.add(listen(player, "mousemove", debounce(this.onControlsChange, 50, true).bind(this)));
      playerRef[this] = player;
    });
  }
  show() {
    this.dispatch("isControlsActive", true);
  }
  hide() {
    this.dispatch("isControlsActive", false);
  }
  hideWithDelay() {
    clearTimeout(hideControlsTimeout[playerRef[this]]);
    hideControlsTimeout[playerRef[this]] = setTimeout(() => {
      this.hide();
    }, this.activeDuration);
  }
  onControlsChange(event) {
    clearTimeout(hideControlsTimeout[playerRef[this]]);
    if (this.hidden || !this.playbackReady) {
      this.hide();
      return;
    }
    if (this.isAudioView) {
      this.show();
      return;
    }
    if (this.waitForPlaybackStart && !this.playbackStarted) {
      this.hide();
      return;
    }
    if (this.isInteracting || this.isSettingsActive) {
      this.show();
      return;
    }
    if (this.hideWhenPaused && this.paused) {
      this.hideWithDelay();
      return;
    }
    if (this.hideOnMouseLeave && !this.paused && (event === null || event === void 0 ? void 0 : event.type) === "mouseleave") {
      this.hide();
      return;
    }
    if (!this.paused) {
      this.show();
      this.hideWithDelay();
      return;
    }
    this.show();
  }
  getPosition() {
    if (this.isAudioView)
      return {};
    if (this.pin === "center") {
      return {
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)"
      };
    }
    const pos = this.pin.split(/(?=[L|R])/).map((s) => s.toLowerCase());
    return { [pos[0]]: 0, [pos[1]]: 0 };
  }
  onStartInteraction() {
    this.isInteracting = true;
  }
  onEndInteraction() {
    this.isInteracting = false;
  }
  render() {
    return h(Host, { video: !this.isAudioView }, h("div", { style: Object.assign(Object.assign({}, this.getPosition()), { flexDirection: this.direction, alignItems: this.align === "center" ? "center" : `flex-${this.align}`, justifyContent: this.justify }), class: {
      controls: true,
      audio: this.isAudioView,
      hidden: this.hidden,
      active: this.playbackReady && this.isControlsActive,
      fullWidth: this.isAudioView || this.fullWidth,
      fullHeight: !this.isAudioView && this.fullHeight
    }, onMouseEnter: this.onStartInteraction.bind(this), onMouseLeave: this.onEndInteraction.bind(this), onTouchStart: this.onStartInteraction.bind(this), onTouchEnd: this.onEndInteraction.bind(this) }, h("slot", null)));
  }
  static get watchers() {
    return {
      "paused": ["onControlsChange"],
      "hidden": ["onControlsChange"],
      "isAudioView": ["onControlsChange"],
      "isInteracting": ["onControlsChange"],
      "isSettingsActive": ["onControlsChange"],
      "hideWhenPaused": ["onControlsChange"],
      "hideOnMouseLeave": ["onControlsChange"],
      "playbackStarted": ["onControlsChange"],
      "waitForPlaybackStart": ["onControlsChange"],
      "playbackReady": ["onControlsChange"]
    };
  }
  static get style() {
    return controlsCss;
  }
};
var currentTimeCss = ":host{display:flex;align-items:center;justify-content:center}";
var CurrentTime = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.currentTime = 0;
    this.i18n = {};
    this.alwaysShowHours = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["currentTime", "i18n"]);
  }
  render() {
    return h("vm-time", { label: this.i18n.currentTime, seconds: this.currentTime, alwaysShowHours: this.alwaysShowHours });
  }
  static get style() {
    return currentTimeCss;
  }
};
var _a;
var _b;
var IS_CLIENT = typeof window !== "undefined";
var UA = IS_CLIENT ? (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent.toLowerCase() : "";
var IS_IOS = /iphone|ipad|ipod|ios|CriOS|FxiOS/.test(UA);
var IS_ANDROID = /android/.test(UA);
var IS_MOBILE = IS_CLIENT && (IS_IOS || IS_ANDROID);
var IS_IPHONE = IS_CLIENT && /(iPhone|iPod)/gi.test((_b = window.navigator) === null || _b === void 0 ? void 0 : _b.platform);
/firefox/.test(UA);
var IS_CHROME = IS_CLIENT && window.chrome;
IS_CLIENT && !IS_CHROME && (window.safari || IS_IOS || /(apple|safari)/.test(UA));
var onMobileChange = (callback) => {
  if (!IS_CLIENT || isUndefined(window.ResizeObserver)) {
    callback(IS_MOBILE);
    return noop;
  }
  function onResize() {
    callback(window.innerWidth <= 480 || IS_MOBILE);
  }
  callback(window.innerWidth <= 480 || IS_MOBILE);
  return listen(window, "resize", onResize);
};
var onTouchInputChange = (callback) => {
  if (!IS_CLIENT)
    return noop;
  let lastTouchTime = 0;
  const offTouchListener = listen(document, "touchstart", () => {
    lastTouchTime = new Date().getTime();
    callback(true);
  }, true);
  const offMouseListener = listen(document, "mousemove", () => {
    if (new Date().getTime() - lastTouchTime < 500)
      return;
    callback(false);
  }, true);
  return () => {
    offTouchListener();
    offMouseListener();
  };
};
var canRotateScreen = () => IS_CLIENT && window.screen.orientation && !!window.screen.orientation.lock;
var canUsePiPInChrome = () => {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return !!document.pictureInPictureEnabled && !video.disablePictureInPicture;
};
var canUsePiPInSafari = () => {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return isFunction(video.webkitSupportsPresentationMode) && isFunction(video.webkitSetPresentationMode) && !IS_IPHONE;
};
var canUsePiP = () => canUsePiPInChrome() || canUsePiPInSafari();
var canAutoplay = (muted = true, playsinline = true) => {
  if (!IS_CLIENT)
    return Promise.resolve(false);
  const video = document.createElement("video");
  if (muted) {
    video.setAttribute("muted", "");
    video.muted = true;
  }
  if (playsinline) {
    video.setAttribute("playsinline", "");
    video.setAttribute("webkit-playsinline", "");
  }
  video.setAttribute("height", "0");
  video.setAttribute("width", "0");
  video.style.position = "fixed";
  video.style.top = "0";
  video.style.width = "0";
  video.style.height = "0";
  video.style.opacity = "0";
  new Promise((resolve) => resolve(video.play())).catch(noop);
  return Promise.resolve(!video.paused);
};
function tryParseJSON(json) {
  if (!isString(json))
    return void 0;
  try {
    return JSON.parse(json);
  } catch (e) {
    return void 0;
  }
}
var isObjOrJSON = (input) => !isNil(input) && (isObject(input) || isString(input) && input.startsWith("{"));
var objOrParseJSON = (input) => isObject(input) ? input : tryParseJSON(input);
var loadImage = (src, minWidth = 1) => new Promise((resolve, reject) => {
  const image = new Image();
  const handler = () => {
    delete image.onload;
    delete image.onerror;
    image.naturalWidth >= minWidth ? resolve(image) : reject(image);
  };
  Object.assign(image, { onload: handler, onerror: handler, src });
});
var loadScript = (src, onLoad, onError = noop) => {
  var _a2;
  const script = document.createElement("script");
  script.src = src;
  script.onload = onLoad;
  script.onerror = onError;
  const firstScriptTag = document.getElementsByTagName("script")[0];
  (_a2 = firstScriptTag.parentNode) === null || _a2 === void 0 ? void 0 : _a2.insertBefore(script, firstScriptTag);
};
var decodeJSON = (data) => {
  if (!isObjOrJSON(data))
    return void 0;
  return objOrParseJSON(data);
};
var tryDecodeURIComponent = (component, fallback = "") => {
  if (!IS_CLIENT)
    return fallback;
  try {
    return window.decodeURIComponent(component);
  } catch (e) {
    return fallback;
  }
};
var QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;
var parseQueryString = (qs) => {
  const params = /* @__PURE__ */ Object.create(null);
  if (isUndefined(qs))
    return params;
  let match;
  while (match = QUERY_STRING_REGEX.exec(qs)) {
    const name = tryDecodeURIComponent(match[1], match[1]).replace("[]", "");
    const value = isString(match[2]) ? tryDecodeURIComponent(match[2].replace(/\+/g, " "), match[2]) : "";
    const currValue = params[name];
    if (currValue && !isArray(currValue))
      params[name] = [currValue];
    currValue ? params[name].push(value) : params[name] = value;
  }
  return params;
};
var serializeQueryString = (params) => {
  const qs = [];
  const appendQueryParam = (param, v) => {
    qs.push(`${encodeURIComponent(param)}=${encodeURIComponent(v)}`);
  };
  Object.keys(params).forEach((param) => {
    const value = params[param];
    if (isNil(value))
      return;
    if (isArray(value)) {
      value.forEach((v) => appendQueryParam(param, v));
    } else {
      appendQueryParam(param, value);
    }
  });
  return qs.join("&");
};
var preconnect = (url, rel = "preconnect", as) => {
  if (!IS_CLIENT)
    return false;
  const link = document.createElement("link");
  link.rel = rel;
  link.href = url;
  if (!isUndefined(as))
    link.as = as;
  link.crossOrigin = "true";
  document.head.append(link);
  return true;
};
var appendQueryStringToURL = (url, qs) => {
  if (isUndefined(qs) || qs.length === 0)
    return url;
  const mainAndQuery = url.split("?", 2);
  return mainAndQuery[0] + (!isUndefined(mainAndQuery[1]) ? `?${mainAndQuery[1]}&${qs}` : `?${qs}`);
};
var appendParamsToURL = (url, params) => appendQueryStringToURL(url, isObject(params) ? serializeQueryString(params) : params);
var decodeQueryString = (qs) => {
  if (!isString(qs))
    return void 0;
  return parseQueryString(qs);
};
var pendingSDKRequests = {};
var loadSDK = (url, sdkGlobalVar, sdkReadyVar, isLoaded = () => true, loadScriptFn = loadScript) => {
  const getGlobal = (key2) => {
    if (!isUndefined(window[key2]))
      return window[key2];
    if (window.exports && window.exports[key2])
      return window.exports[key2];
    if (window.module && window.module.exports && window.module.exports[key2]) {
      return window.module.exports[key2];
    }
    return void 0;
  };
  const existingGlobal = getGlobal(sdkGlobalVar);
  if (existingGlobal && isLoaded(existingGlobal)) {
    return Promise.resolve(existingGlobal);
  }
  return new Promise((resolve, reject) => {
    if (!isUndefined(pendingSDKRequests[url])) {
      pendingSDKRequests[url].push({ resolve, reject });
      return;
    }
    pendingSDKRequests[url] = [{ resolve, reject }];
    const onLoaded = (sdk) => {
      pendingSDKRequests[url].forEach((request) => request.resolve(sdk));
    };
    if (!isUndefined(sdkReadyVar)) {
      const previousOnReady = window[sdkReadyVar];
      window[sdkReadyVar] = function() {
        if (!isUndefined(previousOnReady))
          previousOnReady();
        onLoaded(getGlobal(sdkGlobalVar));
      };
    }
    loadScriptFn(url, () => {
      if (isUndefined(sdkReadyVar))
        onLoaded(getGlobal(sdkGlobalVar));
    }, (e) => {
      pendingSDKRequests[url].forEach((request) => {
        request.reject(e);
      });
      delete pendingSDKRequests[url];
    });
  });
};
var withProviderContext = (provider, additionalProps = []) => withPlayerContext(provider, [
  "autoplay",
  "controls",
  "language",
  "muted",
  "logger",
  "loop",
  "aspectRatio",
  "playsinline",
  ...additionalProps
]);
var dailymotionCss = ":host{z-index:var(--vm-media-z-index)}";
var __awaiter$p = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var videoInfoCache$1 = /* @__PURE__ */ new Map();
var Dailymotion = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.defaultInternalState = {};
    this.internalState = {
      currentTime: 0,
      volume: 0,
      muted: false,
      isAdsPlaying: false,
      playbackReady: false
    };
    this.embedSrc = "";
    this.mediaTitle = "";
    this.shouldAutoplayQueue = false;
    this.showUpNextQueue = false;
    this.showShareButtons = false;
    this.showDailymotionLogo = false;
    this.showVideoInfo = true;
    this.language = "en";
    this.autoplay = false;
    this.controls = false;
    this.loop = false;
    this.muted = false;
    this.playsinline = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this);
  }
  onVideoIdChange() {
    this.internalState = Object.assign({}, this.defaultInternalState);
    if (!this.videoId) {
      this.embedSrc = "";
      return;
    }
    this.embedSrc = `${this.getOrigin()}/embed/video/${this.videoId}?api=1`;
    this.fetchVideoInfo = this.getVideoInfo();
    this.pendingMediaTitleCall = deferredPromise();
  }
  onControlsChange() {
    if (this.internalState.playbackReady) {
      this.remoteControl("controls", this.controls);
    }
  }
  onCustomPosterChange() {
    this.dispatch("currentPoster", this.poster);
  }
  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    this.dispatch("viewType", ViewType.Video);
    this.onVideoIdChange();
    this.internalState.muted = this.muted;
    this.defaultInternalState = Object.assign({}, this.internalState);
  }
  componentDidLoad() {
    this.initialMuted = this.muted;
  }
  getOrigin() {
    return "https://www.dailymotion.com";
  }
  getPreconnections() {
    return [this.getOrigin(), "https://static1.dmcdn.net"];
  }
  remoteControl(command, arg) {
    return this.embed.postMessage({
      command,
      parameters: arg ? [arg] : []
    });
  }
  buildParams() {
    return {
      autoplay: this.autoplay,
      mute: this.initialMuted,
      controls: this.controls,
      "queue-autoplay-next": this.shouldAutoplayQueue,
      "queue-enable": this.showUpNextQueue,
      "sharing-enable": this.showShareButtons,
      syndication: this.syndication,
      "ui-highlight": this.color,
      "ui-logo": this.showDailymotionLogo,
      "ui-start-screen-info": this.showVideoInfo
    };
  }
  getVideoInfo() {
    return __awaiter$p(this, void 0, void 0, function* () {
      if (videoInfoCache$1.has(this.videoId))
        return videoInfoCache$1.get(this.videoId);
      const apiEndpoint = "https://api.dailymotion.com";
      return window.fetch(`${apiEndpoint}/video/${this.videoId}?fields=duration,thumbnail_1080_url`).then((response) => response.json()).then((data) => {
        const poster = data.thumbnail_1080_url;
        const duration = parseFloat(data.duration);
        videoInfoCache$1.set(this.videoId, { poster, duration });
        return { poster, duration };
      });
    });
  }
  onEmbedSrcChange() {
    this.vmLoadStart.emit();
    this.dispatch("viewType", ViewType.Video);
  }
  onEmbedMessage(event) {
    var _a2, _b2;
    const msg = event.detail;
    switch (msg.event) {
      case "playback_ready":
        this.onControlsChange();
        this.dispatch("currentSrc", this.embedSrc);
        this.dispatch("mediaType", MediaType.Video);
        Promise.all([
          this.fetchVideoInfo,
          (_a2 = this.pendingMediaTitleCall) === null || _a2 === void 0 ? void 0 : _a2.promise
        ]).then(([info, mediaTitle]) => {
          var _a3, _b3;
          this.dispatch("duration", (_a3 = info === null || info === void 0 ? void 0 : info.duration) !== null && _a3 !== void 0 ? _a3 : -1);
          this.dispatch("currentPoster", (_b3 = this.poster) !== null && _b3 !== void 0 ? _b3 : info === null || info === void 0 ? void 0 : info.poster);
          this.dispatch("mediaTitle", mediaTitle);
          this.dispatch("playbackReady", true);
        });
        break;
      case "videochange":
        (_b2 = this.pendingMediaTitleCall) === null || _b2 === void 0 ? void 0 : _b2.resolve(msg.title);
        break;
      case "start":
        this.dispatch("paused", false);
        this.dispatch("playbackStarted", true);
        this.dispatch("buffering", true);
        break;
      case "video_start":
        this.remoteControl("muted", this.internalState.muted);
        this.remoteControl("volume", this.internalState.volume);
        if (this.internalState.currentTime > 0) {
          this.remoteControl("seek", this.internalState.currentTime);
        }
        break;
      case "play":
        this.dispatch("paused", false);
        break;
      case "pause":
        this.dispatch("paused", true);
        this.dispatch("playing", false);
        this.dispatch("buffering", false);
        break;
      case "playing":
        this.dispatch("playing", true);
        this.dispatch("buffering", false);
        break;
      case "video_end":
        if (this.loop) {
          setTimeout(() => {
            this.remoteControl("play");
          }, 300);
        } else {
          this.dispatch("playbackEnded", true);
        }
        break;
      case "timeupdate":
        this.dispatch("currentTime", parseFloat(msg.time));
        break;
      case "volumechange":
        this.dispatch("muted", msg.muted === "true");
        this.dispatch("volume", Math.floor(parseFloat(msg.volume) * 100));
        break;
      case "seeking":
        this.dispatch("currentTime", parseFloat(msg.time));
        this.dispatch("seeking", true);
        break;
      case "seeked":
        this.dispatch("currentTime", parseFloat(msg.time));
        this.dispatch("seeking", false);
        break;
      case "waiting":
        this.dispatch("buffering", true);
        break;
      case "progress":
        this.dispatch("buffered", parseFloat(msg.time));
        break;
      case "durationchange":
        this.dispatch("duration", parseFloat(msg.duration));
        break;
      case "qualitiesavailable":
        this.dispatch("playbackQualities", msg.qualities.map((q) => `${q}p`));
        break;
      case "qualitychange":
        this.dispatch("playbackQuality", `${msg.quality}p`);
        break;
      case "fullscreenchange":
        this.dispatch("isFullscreenActive", msg.fullscreen === "true");
        break;
      case "error":
        this.vmError.emit(msg.error);
        break;
    }
  }
  getAdapter() {
    return __awaiter$p(this, void 0, void 0, function* () {
      const canPlayRegex = /(?:dai\.ly|dailymotion|dailymotion\.com)\/(?:video\/|embed\/|)(?:video\/|)((?:\w)+)/;
      return {
        getInternalPlayer: () => __awaiter$p(this, void 0, void 0, function* () {
          return this.embed;
        }),
        play: () => __awaiter$p(this, void 0, void 0, function* () {
          this.remoteControl("play");
        }),
        pause: () => __awaiter$p(this, void 0, void 0, function* () {
          this.remoteControl("pause");
        }),
        canPlay: (type) => __awaiter$p(this, void 0, void 0, function* () {
          return isString(type) && canPlayRegex.test(type);
        }),
        setCurrentTime: (time) => __awaiter$p(this, void 0, void 0, function* () {
          if (time !== this.internalState.currentTime) {
            this.internalState.currentTime = time;
            this.remoteControl("seek", time);
          }
        }),
        setMuted: (muted) => __awaiter$p(this, void 0, void 0, function* () {
          this.internalState.muted = muted;
          this.remoteControl("muted", muted);
        }),
        setVolume: (volume) => __awaiter$p(this, void 0, void 0, function* () {
          this.internalState.volume = volume / 100;
          this.dispatch("volume", volume);
          this.remoteControl("volume", volume / 100);
        }),
        canSetPlaybackQuality: () => __awaiter$p(this, void 0, void 0, function* () {
          return true;
        }),
        setPlaybackQuality: (quality) => __awaiter$p(this, void 0, void 0, function* () {
          this.remoteControl("quality", quality.slice(0, -1));
        }),
        canSetFullscreen: () => __awaiter$p(this, void 0, void 0, function* () {
          return true;
        }),
        enterFullscreen: () => __awaiter$p(this, void 0, void 0, function* () {
          this.remoteControl("fullscreen", true);
        }),
        exitFullscreen: () => __awaiter$p(this, void 0, void 0, function* () {
          this.remoteControl("fullscreen", false);
        })
      };
    });
  }
  render() {
    return h("vm-embed", { embedSrc: this.embedSrc, mediaTitle: this.mediaTitle, origin: this.getOrigin(), params: this.buildParams(), decoder: decodeQueryString, preconnections: this.getPreconnections(), onVmEmbedMessage: this.onEmbedMessage.bind(this), onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this), ref: (el) => {
      this.embed = el;
    } });
  }
  static get watchers() {
    return {
      "videoId": ["onVideoIdChange"],
      "controls": ["onControlsChange"],
      "poster": ["onCustomPosterChange"]
    };
  }
  static get style() {
    return dailymotionCss;
  }
};
var dashCss = ":host{z-index:var(--vm-media-z-index)}";
var __awaiter$o = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Dash = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.textTracksDisposal = new Disposal();
    this.hasAttached = false;
    this.version = "latest";
    this.config = {};
    this.autoplay = false;
    this.preload = "metadata";
    this.enableTextTracksByDefault = true;
    this.shouldRenderNativeTextTracks = true;
    this.isTextTrackVisible = true;
    this.currentTextTrack = -1;
    withComponentRegistry(this);
    withProviderConnect(this);
    withPlayerContext(this, [
      "autoplay",
      "shouldRenderNativeTextTracks",
      "isTextTrackVisible",
      "currentTextTrack"
    ]);
  }
  onSrcChange() {
    var _a2;
    if (!this.hasAttached)
      return;
    this.vmLoadStart.emit();
    (_a2 = this.dash) === null || _a2 === void 0 ? void 0 : _a2.attachSource(this.src);
  }
  onShouldRenderNativeTextTracks() {
    var _a2;
    if (this.shouldRenderNativeTextTracks) {
      this.textTracksDisposal.empty();
    } else {
      this.hideCurrentTextTrack();
    }
    (_a2 = this.dash) === null || _a2 === void 0 ? void 0 : _a2.enableForcedTextStreaming(!this.shouldRenderNativeTextTracks);
  }
  onTextTrackChange() {
    var _a2, _b2;
    if (!this.shouldRenderNativeTextTracks || isUndefined(this.dash))
      return;
    this.dash.setTextTrack(!this.isTextTrackVisible ? -1 : this.currentTextTrack);
    if (!this.isTextTrackVisible) {
      const track = Array.from((_b2 = (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.textTracks) !== null && _b2 !== void 0 ? _b2 : [])[this.currentTextTrack];
      if ((track === null || track === void 0 ? void 0 : track.mode) === "hidden")
        this.dispatch("currentTextTrack", -1);
    }
  }
  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    if (this.mediaEl)
      this.setupDash();
  }
  disconnectedCallback() {
    this.textTracksDisposal.empty();
    this.destroyDash();
  }
  setupDash() {
    return __awaiter$o(this, void 0, void 0, function* () {
      try {
        const url = this.libSrc || `https://cdn.jsdelivr.net/npm/dashjs@${this.version}/dist/dash.all.min.js`;
        const DashSDK = yield loadSDK(url, "dashjs");
        this.dash = DashSDK.MediaPlayer(this.config).create();
        this.dash.initialize(this.mediaEl, null, this.autoplay);
        this.dash.setTextDefaultEnabled(this.enableTextTracksByDefault);
        this.dash.enableForcedTextStreaming(!this.shouldRenderNativeTextTracks);
        this.dash.on(DashSDK.MediaPlayer.events.PLAYBACK_METADATA_LOADED, () => {
          this.dispatch("mediaType", MediaType.Video);
          this.dispatch("currentSrc", this.src);
          this.dispatchLevels();
          this.listenToTextTracksForChanges();
          this.dispatch("playbackReady", true);
        });
        this.dash.on(DashSDK.MediaPlayer.events.TRACK_CHANGE_RENDERED, () => {
          if (!this.shouldRenderNativeTextTracks)
            this.hideCurrentTextTrack();
        });
        this.dash.on(DashSDK.MediaPlayer.events.ERROR, (e) => {
          this.vmError.emit(e);
        });
        this.hasAttached = true;
      } catch (e) {
        this.vmError.emit(e);
      }
    });
  }
  destroyDash() {
    var _a2;
    return __awaiter$o(this, void 0, void 0, function* () {
      (_a2 = this.dash) === null || _a2 === void 0 ? void 0 : _a2.reset();
      this.hasAttached = false;
    });
  }
  onMediaElChange(event) {
    return __awaiter$o(this, void 0, void 0, function* () {
      this.destroyDash();
      if (isUndefined(event.detail))
        return;
      this.mediaEl = event.detail;
      yield this.setupDash();
    });
  }
  levelToPlaybackQuality(level) {
    return level === -1 ? "Auto" : `${level.height}p`;
  }
  findLevelIndexFromQuality(quality) {
    return this.dash.getBitrateInfoListFor("video").findIndex((level) => this.levelToPlaybackQuality(level) === quality);
  }
  dispatchLevels() {
    try {
      const levels = this.dash.getBitrateInfoListFor("video");
      if ((levels === null || levels === void 0 ? void 0 : levels.length) > 0) {
        this.dispatch("playbackQualities", [
          "Auto",
          ...levels.map(this.levelToPlaybackQuality)
        ]);
        this.dispatch("playbackQuality", "Auto");
      }
    } catch (e) {
      this.vmError.emit(e);
    }
  }
  listenToTextTracksForChanges() {
    var _a2, _b2, _c;
    this.textTracksDisposal.empty();
    if (isUndefined(this.mediaEl) || this.shouldRenderNativeTextTracks)
      return;
    const currentTrack = (_c = ((_b2 = (_a2 = this.dash) === null || _a2 === void 0 ? void 0 : _a2.getCurrentTrackFor("text")) === null || _b2 === void 0 ? void 0 : _b2.index) - 1) !== null && _c !== void 0 ? _c : -1;
    this.currentTextTrack = currentTrack;
    this.dispatch("currentTextTrack", currentTrack);
    this.textTracksDisposal.add(listen(this.mediaEl.textTracks, "change", this.onTextTracksChange.bind(this)));
  }
  getTextTracks() {
    var _a2, _b2;
    return Array.from((_b2 = (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.textTracks) !== null && _b2 !== void 0 ? _b2 : []);
  }
  hideCurrentTextTrack() {
    const textTracks = this.getTextTracks();
    if (textTracks[this.currentTextTrack] && this.isTextTrackVisible) {
      textTracks[this.currentTextTrack].mode = "hidden";
    }
  }
  onTextTracksChange() {
    this.hideCurrentTextTrack();
    this.dispatch("textTracks", this.getTextTracks());
    this.dispatch("isTextTrackVisible", this.isTextTrackVisible);
    this.dispatch("currentTextTrack", this.currentTextTrack);
  }
  getAdapter() {
    var _a2, _b2;
    return __awaiter$o(this, void 0, void 0, function* () {
      const adapter = (_b2 = yield (_a2 = this.videoProvider) === null || _a2 === void 0 ? void 0 : _a2.getAdapter()) !== null && _b2 !== void 0 ? _b2 : {};
      const canVideoProviderPlay = adapter.canPlay;
      return Object.assign(Object.assign({}, adapter), { getInternalPlayer: () => __awaiter$o(this, void 0, void 0, function* () {
        return this.dash;
      }), canPlay: (type) => __awaiter$o(this, void 0, void 0, function* () {
        var _c;
        return isString(type) && dashRegex.test(type) || ((_c = canVideoProviderPlay === null || canVideoProviderPlay === void 0 ? void 0 : canVideoProviderPlay(type)) !== null && _c !== void 0 ? _c : false);
      }), canSetPlaybackQuality: () => __awaiter$o(this, void 0, void 0, function* () {
        var _d, _e;
        try {
          return ((_e = (_d = this.dash) === null || _d === void 0 ? void 0 : _d.getBitrateInfoListFor("video")) === null || _e === void 0 ? void 0 : _e.length) > 0;
        } catch (e) {
          this.vmError.emit(e);
          return false;
        }
      }), setPlaybackQuality: (quality) => __awaiter$o(this, void 0, void 0, function* () {
        if (!isUndefined(this.dash)) {
          const index = this.findLevelIndexFromQuality(quality);
          this.dash.updateSettings({
            streaming: {
              abr: {
                autoSwitchBitrate: {
                  video: index === -1
                }
              }
            }
          });
          if (index >= 0)
            this.dash.setQualityFor("video", index);
          this.dispatch("playbackQuality", quality);
        }
      }), setCurrentTextTrack: (trackId) => __awaiter$o(this, void 0, void 0, function* () {
        var _f;
        if (this.shouldRenderNativeTextTracks) {
          adapter.setCurrentTextTrack(trackId);
        } else {
          this.currentTextTrack = trackId;
          (_f = this.dash) === null || _f === void 0 ? void 0 : _f.setTextTrack(trackId);
          this.onTextTracksChange();
        }
      }), setTextTrackVisibility: (isVisible) => __awaiter$o(this, void 0, void 0, function* () {
        var _g;
        if (this.shouldRenderNativeTextTracks) {
          adapter.setTextTrackVisibility(isVisible);
        } else {
          this.isTextTrackVisible = isVisible;
          (_g = this.dash) === null || _g === void 0 ? void 0 : _g.enableText(isVisible);
          this.onTextTracksChange();
        }
      }) });
    });
  }
  render() {
    return h("vm-video", { willAttach: true, crossOrigin: this.crossOrigin, preload: this.preload, poster: this.poster, controlsList: this.controlsList, autoPiP: this.autoPiP, disablePiP: this.disablePiP, hasCustomTextManager: !this.shouldRenderNativeTextTracks, disableRemotePlayback: this.disableRemotePlayback, mediaTitle: this.mediaTitle, ref: (el) => {
      this.videoProvider = el;
    } });
  }
  static get watchers() {
    return {
      "src": ["onSrcChange"],
      "hasAttached": ["onSrcChange"],
      "shouldRenderNativeTextTracks": ["onShouldRenderNativeTextTracks"],
      "isTextTrackVisible": ["onTextTrackChange"],
      "currentTextTrack": ["onTextTrackChange"]
    };
  }
  static get style() {
    return dashCss;
  }
};
var dblClickFullscreenCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-dbl-click-fullscreen-z-index)}.dblClickFullscreen{display:none;width:100%;height:100%;pointer-events:none}.dblClickFullscreen.enabled{display:inline-block;pointer-events:auto}";
var __awaiter$n = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DblClickFullscreen = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.canSetFullscreen = false;
    this.useOnMobile = false;
    this.isFullscreenActive = true;
    this.isVideoView = false;
    this.playbackReady = false;
    this.isMobile = false;
    this.clicks = 0;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "playbackReady",
      "isFullscreenActive",
      "isVideoView",
      "isMobile"
    ]);
  }
  onPlaybackReadyChange() {
    return __awaiter$n(this, void 0, void 0, function* () {
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      this.canSetFullscreen = yield player.canSetFullscreen();
    });
  }
  onTriggerClickToPlay() {
    return __awaiter$n(this, void 0, void 0, function* () {
      const [clickToPlay] = getComponentFromRegistry(this, "vm-click-to-play");
      yield clickToPlay === null || clickToPlay === void 0 ? void 0 : clickToPlay.forceClick();
    });
  }
  onToggleFullscreen() {
    return __awaiter$n(this, void 0, void 0, function* () {
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      this.isFullscreenActive ? player.exitFullscreen() : player.enterFullscreen();
    });
  }
  onClick() {
    this.clicks += 1;
    if (this.clicks === 1) {
      setTimeout(() => {
        if (this.clicks === 1) {
          this.onTriggerClickToPlay();
        } else {
          this.onToggleFullscreen();
        }
        this.clicks = 0;
      }, 300);
    }
  }
  render() {
    return h("div", { class: {
      dblClickFullscreen: true,
      enabled: this.playbackReady && this.canSetFullscreen && this.isVideoView && (!this.isMobile || this.useOnMobile)
    }, onClick: this.onClick.bind(this) });
  }
  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReadyChange"]
    };
  }
  static get style() {
    return dblClickFullscreenCss;
  }
};
var defaultControlsCss = ":host{display:contents;pointer-events:none;z-index:var(--vm-controls-z-index)}";
var DefaultControls = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.activeDuration = 2750;
    this.waitForPlaybackStart = false;
    this.hideWhenPaused = false;
    this.hideOnMouseLeave = false;
    this.isMobile = false;
    this.isLive = false;
    this.isAudioView = false;
    this.isVideoView = false;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "theme",
      "isMobile",
      "isAudioView",
      "isVideoView",
      "isLive"
    ]);
  }
  buildAudioControls() {
    return h("vm-controls", { fullWidth: true }, h("vm-playback-control", { tooltipDirection: "right" }), h("vm-volume-control", null), !this.isLive && h("vm-current-time", null), this.isLive && h("vm-control-spacer", null), !this.isLive && h("vm-scrubber-control", null), this.isLive && h("vm-live-indicator", null), !this.isLive && h("vm-end-time", null), !this.isLive && h("vm-settings-control", { tooltipDirection: "left" }), h("div", { style: { marginLeft: "0", paddingRight: "2px" } }));
  }
  buildMobileVideoControls() {
    return h(Fragment, null, h("vm-scrim", { gradient: "up" }), h("vm-controls", { pin: "topLeft", fullWidth: true, activeDuration: this.activeDuration, waitForPlaybackStart: this.waitForPlaybackStart, hideWhenPaused: this.hideWhenPaused }, h("vm-control-spacer", null), h("vm-volume-control", null), !this.isLive && h("vm-caption-control", null), !this.isLive && h("vm-settings-control", null), this.isLive && h("vm-fullscreen-control", null)), h("vm-controls", { pin: "center", justify: "center", activeDuration: this.activeDuration, waitForPlaybackStart: this.waitForPlaybackStart, hideWhenPaused: this.hideWhenPaused }, h("vm-playback-control", { style: { "--vm-control-scale": "1.3" } })), !this.isLive && h("vm-controls", { pin: "bottomLeft", fullWidth: true, activeDuration: this.activeDuration, waitForPlaybackStart: this.waitForPlaybackStart, hideWhenPaused: this.hideWhenPaused }, h("vm-control-group", null, h("vm-current-time", null), h("vm-control-spacer", null), h("vm-end-time", null), h("vm-fullscreen-control", null)), h("vm-control-group", { space: "top" }, h("vm-scrubber-control", null))));
  }
  buildDesktopVideoControls() {
    return h(Fragment, null, this.theme !== "light" && h("vm-scrim", { gradient: "up" }), h("vm-controls", { fullWidth: true, pin: "bottomRight", activeDuration: this.activeDuration, waitForPlaybackStart: this.waitForPlaybackStart, hideWhenPaused: this.hideWhenPaused, hideOnMouseLeave: this.hideOnMouseLeave }, !this.isLive && h("vm-control-group", null, h("vm-scrubber-control", null)), h("vm-control-group", { space: this.isLive ? "none" : "top" }, h("vm-playback-control", { tooltipDirection: "right" }), h("vm-volume-control", null), !this.isLive && h("vm-time-progress", null), h("vm-control-spacer", null), !this.isLive && h("vm-caption-control", null), this.isLive && h("vm-live-indicator", null), h("vm-pip-control", null), !this.isLive && h("vm-settings-control", null), h("vm-fullscreen-control", { tooltipDirection: "left" }))));
  }
  render() {
    if (this.isAudioView)
      return this.buildAudioControls();
    if (this.isVideoView && this.isMobile)
      return this.buildMobileVideoControls();
    if (this.isVideoView)
      return this.buildDesktopVideoControls();
    return null;
  }
  static get style() {
    return defaultControlsCss;
  }
};
var defaultSettingsCss = ":host{z-index:var(--vm-menu-z-index)}";
var __awaiter$m = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DefaultSettings = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.textTracksDisposal = new Disposal();
    this.canSetPlaybackRate = false;
    this.canSetPlaybackQuality = false;
    this.canSetTextTrack = false;
    this.canSetAudioTrack = false;
    this.pin = "bottomRight";
    this.i18n = {};
    this.playbackReady = false;
    this.playbackRate = 1;
    this.playbackRates = [1];
    this.isVideoView = false;
    this.playbackQualities = [];
    this.textTracks = [];
    this.currentTextTrack = -1;
    this.audioTracks = [];
    this.currentAudioTrack = -1;
    this.isTextTrackVisible = true;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "i18n",
      "playbackReady",
      "playbackRate",
      "playbackRates",
      "playbackQuality",
      "playbackQualities",
      "isVideoView",
      "textTracks",
      "currentTextTrack",
      "isTextTrackVisible",
      "audioTracks",
      "currentAudioTrack"
    ]);
  }
  onPlaybackReady() {
    return __awaiter$m(this, void 0, void 0, function* () {
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      this.canSetPlaybackQuality = yield player.canSetPlaybackQuality();
      this.canSetPlaybackRate = yield player.canSetPlaybackRate();
    });
  }
  onAudioTracksChange() {
    var _a2;
    return __awaiter$m(this, void 0, void 0, function* () {
      const player = getPlayerFromRegistry(this);
      this.canSetAudioTrack = (_a2 = yield player === null || player === void 0 ? void 0 : player.canSetAudioTrack()) !== null && _a2 !== void 0 ? _a2 : false;
    });
  }
  onTextTracksChange() {
    var _a2;
    return __awaiter$m(this, void 0, void 0, function* () {
      const player = getPlayerFromRegistry(this);
      this.canSetTextTrack = (_a2 = yield player === null || player === void 0 ? void 0 : player.canSetTextTrack()) !== null && _a2 !== void 0 ? _a2 : false;
    });
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }
  componentDidLoad() {
    this.onTextTracksChange();
  }
  disconnectedCallback() {
    this.textTracksDisposal.empty();
  }
  onPlaybackRateSelect(event) {
    const radio = event.target;
    this.dispatch("playbackRate", parseFloat(radio.value));
  }
  buildPlaybackRateSubmenu() {
    if (this.playbackRates.length <= 1 || !this.canSetPlaybackRate) {
      return h("vm-menu-item", { label: this.i18n.playbackRate, hint: this.i18n.normal });
    }
    const formatRate = (rate) => rate === 1 ? this.i18n.normal : `${rate}`;
    return h("vm-submenu", { label: this.i18n.playbackRate, hint: formatRate(this.playbackRate) }, h("vm-menu-radio-group", { value: `${this.playbackRate}`, onVmCheck: this.onPlaybackRateSelect.bind(this) }, this.playbackRates.map((rate) => h("vm-menu-radio", { label: formatRate(rate), value: `${rate}` }))));
  }
  onPlaybackQualitySelect(event) {
    const radio = event.target;
    this.dispatch("playbackQuality", radio.value);
  }
  buildPlaybackQualitySubmenu() {
    var _a2;
    if (this.playbackQualities.length <= 1 || !this.canSetPlaybackQuality) {
      return h("vm-menu-item", { label: this.i18n.playbackQuality, hint: (_a2 = this.playbackQuality) !== null && _a2 !== void 0 ? _a2 : this.i18n.auto });
    }
    const getBadge = (quality) => {
      const verticalPixels = parseInt(quality.slice(0, -1), 10);
      if (verticalPixels >= 2160)
        return "UHD";
      if (verticalPixels >= 1080)
        return "HD";
      return void 0;
    };
    return h("vm-submenu", { label: this.i18n.playbackQuality, hint: this.playbackQuality }, h("vm-menu-radio-group", { value: this.playbackQuality, onVmCheck: this.onPlaybackQualitySelect.bind(this) }, this.playbackQualities.map((quality) => h("vm-menu-radio", { label: quality, value: quality, badge: getBadge(quality) }))));
  }
  onTextTrackSelect(event) {
    const radio = event.target;
    const trackId = parseInt(radio.value, 10);
    const player = getPlayerFromRegistry(this);
    if (trackId === -1) {
      player === null || player === void 0 ? void 0 : player.setTextTrackVisibility(false);
      return;
    }
    player === null || player === void 0 ? void 0 : player.setTextTrackVisibility(true);
    player === null || player === void 0 ? void 0 : player.setCurrentTextTrack(trackId);
  }
  buildTextTracksSubmenu() {
    var _a2, _b2, _c;
    if (this.textTracks.length <= 1 || !this.canSetTextTrack) {
      return h("vm-menu-item", { label: this.i18n.subtitlesOrCc, hint: (_b2 = (_a2 = this.textTracks[this.currentTextTrack]) === null || _a2 === void 0 ? void 0 : _a2.label) !== null && _b2 !== void 0 ? _b2 : this.i18n.none });
    }
    return h("vm-submenu", { label: this.i18n.subtitlesOrCc, hint: this.isTextTrackVisible ? (_c = this.textTracks[this.currentTextTrack]) === null || _c === void 0 ? void 0 : _c.label : this.i18n.off }, h("vm-menu-radio-group", { value: `${!this.isTextTrackVisible ? -1 : this.currentTextTrack}`, onVmCheck: this.onTextTrackSelect.bind(this) }, [h("vm-menu-radio", { label: this.i18n.off, value: "-1" })].concat(this.textTracks.map((track, i2) => h("vm-menu-radio", { label: track.label, value: `${i2}` })))));
  }
  onAudioTrackSelect(event) {
    const radio = event.target;
    const trackId = parseInt(radio.value, 10);
    const player = getPlayerFromRegistry(this);
    player === null || player === void 0 ? void 0 : player.setCurrentAudioTrack(trackId);
  }
  buildAudioTracksMenu() {
    var _a2, _b2, _c;
    if (this.audioTracks.length <= 1 || !this.canSetAudioTrack) {
      return h("vm-menu-item", { label: this.i18n.audio, hint: (_b2 = (_a2 = this.audioTracks[this.currentAudioTrack]) === null || _a2 === void 0 ? void 0 : _a2.label) !== null && _b2 !== void 0 ? _b2 : this.i18n.default });
    }
    return h("vm-submenu", { label: this.i18n.audio, hint: (_c = this.audioTracks[this.currentAudioTrack]) === null || _c === void 0 ? void 0 : _c.label }, h("vm-menu-radio-group", { value: `${this.currentAudioTrack}`, onVmCheck: this.onAudioTrackSelect.bind(this) }, this.audioTracks.map((track, i2) => h("vm-menu-radio", { label: track.label, value: `${i2}` }))));
  }
  render() {
    return h("vm-settings", { pin: this.pin }, this.buildAudioTracksMenu(), this.buildPlaybackRateSubmenu(), this.buildPlaybackQualitySubmenu(), this.isVideoView && this.buildTextTracksSubmenu(), h("slot", null));
  }
  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReady", "onAudioTracksChange", "onTextTracksChange"],
      "audioTracks": ["onAudioTracksChange"],
      "textTracks": ["onTextTracksChange"]
    };
  }
  static get style() {
    return defaultSettingsCss;
  }
};
var defaultUiCss = ":host{display:contents;pointer-events:none}";
var DefaultUI = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.noClickToPlay = false;
    this.noDblClickFullscreen = false;
    this.noCaptions = false;
    this.noPoster = false;
    this.noSpinner = false;
    this.noControls = false;
    this.noSettings = false;
    this.noLoadingScreen = false;
    withComponentRegistry(this);
  }
  render() {
    return h("vm-ui", null, !this.noClickToPlay && h("vm-click-to-play", null), !this.noDblClickFullscreen && h("vm-dbl-click-fullscreen", null), !this.noCaptions && h("vm-captions", null), !this.noPoster && h("vm-poster", null), !this.noSpinner && h("vm-spinner", null), !this.noLoadingScreen && h("vm-loading-screen", null), !this.noControls && h("vm-default-controls", null), !this.noSettings && h("vm-default-settings", null), h("slot", null));
  }
  static get style() {
    return defaultUiCss;
  }
};
var LazyLoader = class {
  constructor(el, attributes, onLoad) {
    var _a2;
    this.el = el;
    this.attributes = attributes;
    this.onLoad = onLoad;
    this.hasLoaded = false;
    if (isNil(this.el))
      return;
    this.intersectionObs = this.canObserveIntersection() ? new IntersectionObserver(this.onIntersection.bind(this)) : void 0;
    this.mutationObs = this.canObserveMutations() ? new MutationObserver(this.onMutation.bind(this)) : void 0;
    (_a2 = this.mutationObs) === null || _a2 === void 0 ? void 0 : _a2.observe(this.el, {
      childList: true,
      subtree: true,
      attributeFilter: this.attributes
    });
    this.lazyLoad();
  }
  didLoad() {
    return this.hasLoaded;
  }
  destroy() {
    var _a2, _b2;
    (_a2 = this.intersectionObs) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b2 = this.mutationObs) === null || _b2 === void 0 ? void 0 : _b2.disconnect();
  }
  canObserveIntersection() {
    return IS_CLIENT && window.IntersectionObserver;
  }
  canObserveMutations() {
    return IS_CLIENT && window.MutationObserver;
  }
  lazyLoad() {
    var _a2;
    if (this.canObserveIntersection()) {
      (_a2 = this.intersectionObs) === null || _a2 === void 0 ? void 0 : _a2.observe(this.el);
    } else {
      this.load();
    }
  }
  onIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.intersectionRatio > 0 || entry.isIntersecting) {
        this.load();
        this.intersectionObs.unobserve(entry.target);
      }
    });
  }
  onMutation() {
    if (this.hasLoaded)
      this.load();
  }
  getLazyElements() {
    const root = !isNil(this.el.shadowRoot) ? this.el.shadowRoot : this.el;
    return root.querySelectorAll(".lazy");
  }
  load() {
    window.requestAnimationFrame(() => {
      this.getLazyElements().forEach(this.loadEl.bind(this));
    });
  }
  loadEl(el) {
    var _a2, _b2;
    (_a2 = this.intersectionObs) === null || _a2 === void 0 ? void 0 : _a2.unobserve(el);
    this.hasLoaded = true;
    (_b2 = this.onLoad) === null || _b2 === void 0 ? void 0 : _b2.call(this, el);
  }
};
var embedCss = ":host{z-index:var(--vm-media-z-index)}iframe{position:absolute;top:0;left:0;border:0;width:100%;height:100%;user-select:none}";
var __awaiter$l = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var idCount$4 = 0;
var connected = /* @__PURE__ */ new Set();
var Embed = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmEmbedSrcChange = createEvent(this, "vmEmbedSrcChange", 3);
    this.vmEmbedMessage = createEvent(this, "vmEmbedMessage", 3);
    this.vmEmbedLoaded = createEvent(this, "vmEmbedLoaded", 3);
    this.srcWithParams = "";
    this.hasEnteredViewport = false;
    this.embedSrc = "";
    this.mediaTitle = "";
    this.params = "";
    this.preconnections = [];
    withComponentRegistry(this);
  }
  onEmbedSrcChange() {
    this.srcWithParams = isString(this.embedSrc) && this.embedSrc.length > 0 ? appendParamsToURL(this.embedSrc, this.params) : void 0;
  }
  srcWithParamsChange() {
    if (isUndefined(this.srcWithParams)) {
      this.vmEmbedSrcChange.emit(this.srcWithParams);
      return;
    }
    if (!this.hasEnteredViewport && !connected.has(this.embedSrc)) {
      if (preconnect(this.srcWithParams))
        connected.add(this.embedSrc);
    }
    this.vmEmbedSrcChange.emit(this.srcWithParams);
  }
  preconnectionsChange() {
    if (this.hasEnteredViewport) {
      return;
    }
    this.preconnections.filter((connection) => !connected.has(connection)).forEach((connection) => {
      if (preconnect(connection))
        connected.add(connection);
    });
  }
  connectedCallback() {
    this.lazyLoader = new LazyLoader(this.host, ["data-src"], (el) => {
      const src = el.getAttribute("data-src");
      el.removeAttribute("src");
      if (!isNull(src))
        el.setAttribute("src", src);
    });
    this.onEmbedSrcChange();
    this.genIframeId();
  }
  disconnectedCallback() {
    this.lazyLoader.destroy();
  }
  onWindowMessage(e) {
    var _a2, _b2, _c;
    const originMatches = e.source === ((_a2 = this.iframe) === null || _a2 === void 0 ? void 0 : _a2.contentWindow) && (!isString(this.origin) || this.origin === e.origin);
    if (!originMatches)
      return;
    const message = (_c = (_b2 = this.decoder) === null || _b2 === void 0 ? void 0 : _b2.call(this, e.data)) !== null && _c !== void 0 ? _c : e.data;
    if (message)
      this.vmEmbedMessage.emit(message);
  }
  postMessage(message, target) {
    var _a2, _b2;
    return __awaiter$l(this, void 0, void 0, function* () {
      (_b2 = (_a2 = this.iframe) === null || _a2 === void 0 ? void 0 : _a2.contentWindow) === null || _b2 === void 0 ? void 0 : _b2.postMessage(JSON.stringify(message), target !== null && target !== void 0 ? target : "*");
    });
  }
  onLoad() {
    this.vmEmbedLoaded.emit();
  }
  genIframeId() {
    idCount$4 += 1;
    this.id = `vm-iframe-${idCount$4}`;
  }
  render() {
    return h("iframe", { id: this.id, class: "lazy", title: this.mediaTitle, "data-src": this.srcWithParams, allowFullScreen: true, allow: "autoplay; encrypted-media; picture-in-picture;", onLoad: this.onLoad.bind(this), ref: (el) => {
      this.iframe = el;
    } });
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "embedSrc": ["onEmbedSrcChange"],
      "params": ["onEmbedSrcChange"],
      "srcWithParams": ["srcWithParamsChange"],
      "preconnections": ["preconnectionsChange"]
    };
  }
  static get style() {
    return embedCss;
  }
};
var endTimeCss = ":host{display:flex;align-items:center;justify-content:center}";
var EndTime = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.duration = -1;
    this.i18n = {};
    this.alwaysShowHours = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["duration", "i18n"]);
  }
  render() {
    return h("vm-time", { label: this.i18n.duration, seconds: Math.max(0, this.duration), alwaysShowHours: this.alwaysShowHours });
  }
  static get style() {
    return endTimeCss;
  }
};
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document$1 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document$1 && Object.keys(key) || webkit[0] in document$1 && webkit || moz[0] in document$1 && moz || ms[0] in document$1 && ms || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document$1[vendor[key.exitFullscreen]].bind(document$1);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document$1.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document$1.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document$1[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document$1[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document$1[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document$1[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document$1[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document$1[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i2 = n.get(t);
    i2 ? i2.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i2 = n.get(t);
    i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i2 = n.get(t);
    i2 && i2.slice().map(function(n2) {
      n2(e);
    }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var __awaiter$k = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FullscreenController = class {
  constructor(host) {
    this.host = host;
    this.disposal = new Disposal();
    this.emitter = mitt();
  }
  get isSupported() {
    return this.isSupportedNatively;
  }
  get isSupportedNatively() {
    return fscreen.fullscreenEnabled;
  }
  get isFullscreen() {
    return this.isNativeFullscreen;
  }
  get isNativeFullscreen() {
    if (fscreen.fullscreenElement === this.host)
      return true;
    try {
      return this.host.matches(fscreen.fullscreenPseudoClass);
    } catch (error) {
      return false;
    }
  }
  on(type, handler) {
    this.emitter.on(type, handler);
  }
  off(type, handler) {
    this.emitter.off(type, handler);
  }
  destroy() {
    return __awaiter$k(this, void 0, void 0, function* () {
      if (this.isFullscreen)
        yield this.exitFullscreen();
      this.disposal.empty();
      this.emitter.all.clear();
    });
  }
  addFullscreenChangeEventListener(handler) {
    if (!this.isSupported)
      return noop;
    return listen(fscreen, "fullscreenchange", handler);
  }
  addFullscreenErrorEventListener(handler) {
    if (!this.isSupported)
      return noop;
    return listen(fscreen, "fullscreenerror", handler);
  }
  requestFullscreen() {
    return __awaiter$k(this, void 0, void 0, function* () {
      if (this.isFullscreen)
        return;
      this.throwIfNoFullscreenSupport();
      this.disposal.add(this.addFullscreenChangeEventListener(this.handleFullscreenChange.bind(this)));
      this.disposal.add(this.addFullscreenErrorEventListener(this.handleFullscreenError.bind(this)));
      return this.makeEnterFullscreenRequest();
    });
  }
  makeEnterFullscreenRequest() {
    return __awaiter$k(this, void 0, void 0, function* () {
      return fscreen.requestFullscreen(this.host);
    });
  }
  handleFullscreenChange() {
    if (!this.isFullscreen)
      this.disposal.empty();
    this.emitter.emit("change", this.isFullscreen);
  }
  handleFullscreenError(event) {
    this.emitter.emit("error", event);
  }
  exitFullscreen() {
    return __awaiter$k(this, void 0, void 0, function* () {
      if (!this.isFullscreen)
        return;
      this.throwIfNoFullscreenSupport();
      return this.makeExitFullscreenRequest();
    });
  }
  makeExitFullscreenRequest() {
    return __awaiter$k(this, void 0, void 0, function* () {
      return fscreen.exitFullscreen();
    });
  }
  throwIfNoFullscreenSupport() {
    if (this.isSupported)
      return;
    throw Error("Fullscreen API is not enabled or supported in this environment.");
  }
};
var __awaiter$j = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var VideoFullscreenController = class extends FullscreenController {
  constructor(host, presentationController) {
    super(host);
    this.host = host;
    this.presentationController = presentationController;
  }
  get isFullscreen() {
    return this.presentationController.isFullscreenMode;
  }
  get isSupported() {
    return this.presentationController.isSupported;
  }
  makeEnterFullscreenRequest() {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this.presentationController.setPresentationMode("fullscreen");
    });
  }
  makeExitFullscreenRequest() {
    return __awaiter$j(this, void 0, void 0, function* () {
      return this.presentationController.setPresentationMode("inline");
    });
  }
  addFullscreenChangeEventListener() {
    if (!this.isSupported)
      return noop;
    this.presentationController.on("change", this.handlePresentationModeChange.bind(this));
    return () => {
      this.presentationController.off("change", this.handlePresentationModeChange.bind(this));
    };
  }
  handlePresentationModeChange() {
    this.handleFullscreenChange();
  }
  addFullscreenErrorEventListener() {
    return noop;
  }
};
var __awaiter$i = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var VideoPresentationController = class {
  constructor(host) {
    this.host = host;
    this.disposal = new Disposal();
    this.emitter = mitt();
    const disconnectedCallback2 = host.disconnectedCallback;
    host.disconnectedCallback = () => __awaiter$i(this, void 0, void 0, function* () {
      yield this.destroy();
      disconnectedCallback2 === null || disconnectedCallback2 === void 0 ? void 0 : disconnectedCallback2.call(host);
    });
  }
  get videoElement() {
    var _a2;
    if (((_a2 = this.host.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.tagName.toLowerCase()) === "video") {
      return this.host.mediaEl;
    }
    return void 0;
  }
  get presentationMode() {
    var _a2;
    return (_a2 = this.videoElement) === null || _a2 === void 0 ? void 0 : _a2.webkitPresentationMode;
  }
  get isInlineMode() {
    return this.presentationMode === "inline";
  }
  get isPictureInPictureMode() {
    return this.presentationMode === "inline";
  }
  get isFullscreenMode() {
    return this.presentationMode === "fullscreen";
  }
  get isSupported() {
    var _a2, _b2, _c;
    return IS_IOS && isFunction((_a2 = this.videoElement) === null || _a2 === void 0 ? void 0 : _a2.webkitSetPresentationMode) && ((_c = (_b2 = this.videoElement) === null || _b2 === void 0 ? void 0 : _b2.webkitSupportsFullscreen) !== null && _c !== void 0 ? _c : false);
  }
  setPresentationMode(mode) {
    var _a2, _b2;
    (_b2 = (_a2 = this.videoElement) === null || _a2 === void 0 ? void 0 : _a2.webkitSetPresentationMode) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, mode);
  }
  on(type, handler) {
    this.emitter.on(type, handler);
  }
  off(type, handler) {
    this.emitter.off(type, handler);
  }
  destroy() {
    this.setPresentationMode("inline");
    this.disposal.empty();
  }
  addPresentationModeChangeEventListener() {
    if (!this.isSupported || isNil(this.videoElement))
      return noop;
    return listen(this.videoElement, "webkitpresentationmodechanged", this.handlePresentationModeChange.bind(this));
  }
  handlePresentationModeChange() {
    this.emitter.emit("change", this.presentationMode);
  }
};
var fileCss = "audio.sc-vm-file,video.sc-vm-file{border-radius:inherit;vertical-align:middle;width:100%;outline:0}video.sc-vm-file{position:absolute;top:0;left:0;border:0;height:100%;user-select:none}";
var __awaiter$h = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var File = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.vmMediaElChange = createEvent(this, "vmMediaElChange", 7);
    this.vmSrcSetChange = createEvent(this, "vmSrcSetChange", 7);
    this.textTracksDisposal = new Disposal();
    this.wasPausedBeforeSeeking = true;
    this.currentSrcSet = [];
    this.mediaQueryDisposal = new Disposal();
    this.willAttach = false;
    this.preload = "metadata";
    this.playbackRates = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
    this.language = "en";
    this.autoplay = false;
    this.controls = false;
    this.loop = false;
    this.muted = false;
    this.playsinline = false;
    this.noConnect = false;
    this.paused = true;
    this.currentTime = 0;
    this.volume = 0;
    this.playbackReady = false;
    this.playbackStarted = false;
    this.presentationController = new VideoPresentationController(this);
    this.fullscreenController = new VideoFullscreenController(this, this.presentationController);
    this.currentTextTrack = -1;
    this.hasCustomTextManager = false;
    this.isTextTrackVisible = true;
    this.shouldRenderNativeTextTracks = true;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this, [
      "playbackReady",
      "playbackStarted",
      "currentTime",
      "volume",
      "paused",
      "currentTextTrack",
      "isTextTrackVisible",
      "shouldRenderNativeTextTracks"
    ]);
    watchComponentRegistry(this, "vm-poster", (regs) => {
      [this.vmPoster] = regs;
    });
  }
  onMediaTitleChange() {
    this.dispatch("mediaTitle", this.mediaTitle);
  }
  onPosterChange() {
    var _a2;
    if (!this.playbackStarted)
      (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.load();
  }
  onViewTypeChange() {
    this.dispatch("viewType", this.viewType);
  }
  connectedCallback() {
    this.initLazyLoader();
    this.dispatch = createProviderDispatcher(this);
    this.onViewTypeChange();
    this.onPosterChange();
    this.onMediaTitleChange();
    this.addPresentationControllerListeners();
  }
  componentDidRender() {
    if (this.prevMediaEl !== this.mediaEl) {
      this.prevMediaEl = this.mediaEl;
      this.vmMediaElChange.emit(this.mediaEl);
      this.presentationController.addPresentationModeChangeEventListener();
    }
  }
  componentDidLoad() {
    this.onViewTypeChange();
  }
  disconnectedCallback() {
    var _a2;
    this.mediaQueryDisposal.empty();
    this.textTracksDisposal.empty();
    this.cancelTimeUpdates();
    (_a2 = this.lazyLoader) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    this.wasPausedBeforeSeeking = true;
  }
  initLazyLoader() {
    this.lazyLoader = new LazyLoader(this.host, ["data-src", "data-poster"], () => {
      if (isNil(this.mediaEl))
        return;
      const poster = this.mediaEl.getAttribute("data-poster");
      if (!isNull(poster))
        this.mediaEl.setAttribute("poster", poster);
      this.refresh();
      this.didSrcSetChange();
    });
  }
  refresh() {
    if (isNil(this.mediaEl))
      return;
    const { children } = this.mediaEl;
    for (let i2 = 0; i2 <= children.length - 1; i2 += 1) {
      const child = children[i2];
      const src = child.getAttribute("data-src") || child.getAttribute("src") || child.getAttribute("data-vs");
      child.removeAttribute("src");
      if (isNull(src))
        continue;
      child.setAttribute("data-vs", src);
      child.setAttribute("src", src);
    }
  }
  didSrcSetChange() {
    if (isNil(this.mediaEl))
      return;
    const sources = Array.from(this.mediaEl.querySelectorAll("source"));
    const srcSet = sources.map((source) => {
      var _a2;
      return {
        src: source.getAttribute("data-vs"),
        media: (_a2 = source.getAttribute("data-media")) !== null && _a2 !== void 0 ? _a2 : void 0,
        ref: source
      };
    });
    const didChange = this.currentSrcSet.length !== srcSet.length || srcSet.some((resource, i2) => this.currentSrcSet[i2].src !== resource.src);
    if (didChange) {
      this.currentSrcSet = srcSet;
      this.onSrcSetChange();
    }
  }
  onSrcSetChange() {
    var _a2;
    this.textTracksDisposal.empty();
    this.mediaQueryDisposal.empty();
    this.vmLoadStart.emit();
    this.vmSrcSetChange.emit(this.currentSrcSet);
    if (!this.willAttach)
      (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.load();
  }
  hasCustomPoster() {
    return !IS_IOS && !isUndefined(this.vmPoster);
  }
  cancelTimeUpdates() {
    if (isNumber(this.timeRAF))
      window.cancelAnimationFrame(this.timeRAF);
    this.timeRAF = void 0;
  }
  requestTimeUpdates() {
    var _a2, _b2;
    this.dispatch("currentTime", (_b2 = (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.currentTime) !== null && _b2 !== void 0 ? _b2 : 0);
    this.timeRAF = window.requestAnimationFrame(() => {
      this.requestTimeUpdates();
    });
  }
  getMediaType() {
    const { currentSrc } = this.mediaEl;
    if (audioRegex.test(currentSrc))
      return MediaType.Audio;
    if (videoRegex.test(currentSrc) || hlsRegex.test(currentSrc))
      return MediaType.Video;
    return void 0;
  }
  onLoadedMetadata() {
    this.mediaEl.volume = this.volume / 100;
    this.listenToTextTracksForChanges();
    this.onTextTracksChange();
    this.onProgress();
    this.dispatch("currentPoster", this.poster);
    this.dispatch("duration", this.mediaEl.duration);
    this.dispatch("playbackRates", this.playbackRates);
    if (!this.willAttach) {
      this.dispatch("currentSrc", this.mediaEl.currentSrc);
      this.dispatch("mediaType", this.getMediaType());
      this.dispatch("playbackReady", true);
    }
  }
  onProgress() {
    const { buffered, duration } = this.mediaEl;
    const end = buffered.length === 0 ? 0 : buffered.end(buffered.length - 1);
    this.dispatch("buffered", end > duration ? duration : end);
  }
  onPlay() {
    this.requestTimeUpdates();
    this.dispatch("paused", false);
    if (!this.playbackStarted)
      this.dispatch("playbackStarted", true);
  }
  onPause() {
    this.cancelTimeUpdates();
    this.dispatch("paused", true);
    this.dispatch("buffering", false);
  }
  onPlaying() {
    this.dispatch("playing", true);
    this.dispatch("buffering", false);
  }
  onSeeking() {
    if (!this.wasPausedBeforeSeeking)
      this.wasPausedBeforeSeeking = this.mediaEl.paused;
    this.dispatch("currentTime", this.mediaEl.currentTime);
    this.dispatch("seeking", true);
  }
  onSeeked() {
    if (this.currentTime === 0 && !this.playbackStarted)
      return;
    this.dispatch("seeking", false);
    if (!this.playbackStarted || !this.wasPausedBeforeSeeking)
      this.attemptToPlay();
    this.wasPausedBeforeSeeking = true;
  }
  onRateChange() {
    this.dispatch("playbackRate", this.mediaEl.playbackRate);
  }
  onVolumeChange() {
    this.dispatch("muted", this.mediaEl.muted);
    this.dispatch("volume", this.mediaEl.volume * 100);
  }
  onDurationChange() {
    this.dispatch("duration", this.mediaEl.duration);
  }
  onWaiting() {
    this.dispatch("buffering", true);
  }
  onSuspend() {
    this.dispatch("buffering", false);
  }
  onEnded() {
    if (!this.loop)
      this.dispatch("playbackEnded", true);
  }
  onError() {
    this.vmError.emit(this.mediaEl.error);
  }
  attemptToPlay() {
    var _a2;
    try {
      (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.play();
    } catch (e) {
      this.vmError.emit(e);
    }
  }
  togglePiPInChrome(toggle) {
    var _a2;
    return toggle ? (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.requestPictureInPicture() : document.exitPictureInPicture();
  }
  togglePiPInSafari(toggle) {
    var _a2, _b2;
    const mode = toggle ? "picture-in-picture" : "inline";
    if (!((_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.webkitSupportsPresentationMode(mode))) {
      throw new Error("PiP API is not available.");
    }
    return (_b2 = this.mediaEl) === null || _b2 === void 0 ? void 0 : _b2.webkitSetPresentationMode(mode);
  }
  togglePiP(toggle) {
    return __awaiter$h(this, void 0, void 0, function* () {
      if (canUsePiPInChrome())
        return this.togglePiPInChrome(toggle);
      if (canUsePiPInSafari())
        return this.togglePiPInSafari(toggle);
      throw new Error("PiP API is not available.");
    });
  }
  onEnterPiP() {
    this.dispatch("isPiPActive", true);
  }
  onLeavePiP() {
    this.dispatch("isPiPActive", false);
  }
  addPresentationControllerListeners() {
    this.presentationController.on("change", (mode) => {
      this.dispatch("isPiPActive", mode === "picture-in-picture");
      this.dispatch("isFullscreenActive", mode === "fullscreen");
    });
  }
  getAdapter() {
    return __awaiter$h(this, void 0, void 0, function* () {
      return {
        getInternalPlayer: () => __awaiter$h(this, void 0, void 0, function* () {
          return this.mediaEl;
        }),
        play: () => __awaiter$h(this, void 0, void 0, function* () {
          var _a2;
          return (_a2 = this.mediaEl) === null || _a2 === void 0 ? void 0 : _a2.play();
        }),
        pause: () => __awaiter$h(this, void 0, void 0, function* () {
          var _b2;
          return (_b2 = this.mediaEl) === null || _b2 === void 0 ? void 0 : _b2.pause();
        }),
        canPlay: (type) => __awaiter$h(this, void 0, void 0, function* () {
          return isString(type) && (audioRegex.test(type) || videoRegex.test(type));
        }),
        setCurrentTime: (time) => __awaiter$h(this, void 0, void 0, function* () {
          if (this.mediaEl)
            this.mediaEl.currentTime = time;
        }),
        setMuted: (muted) => __awaiter$h(this, void 0, void 0, function* () {
          if (this.mediaEl)
            this.mediaEl.muted = muted;
        }),
        setVolume: (volume) => __awaiter$h(this, void 0, void 0, function* () {
          if (this.mediaEl)
            this.mediaEl.volume = volume / 100;
        }),
        canSetPlaybackRate: () => __awaiter$h(this, void 0, void 0, function* () {
          return true;
        }),
        setPlaybackRate: (rate) => __awaiter$h(this, void 0, void 0, function* () {
          if (this.mediaEl)
            this.mediaEl.playbackRate = rate;
        }),
        canSetPiP: () => __awaiter$h(this, void 0, void 0, function* () {
          return canUsePiP();
        }),
        enterPiP: () => this.togglePiP(true),
        exitPiP: () => this.togglePiP(false),
        canSetFullscreen: () => __awaiter$h(this, void 0, void 0, function* () {
          return this.fullscreenController.isSupported;
        }),
        enterFullscreen: () => this.fullscreenController.requestFullscreen(),
        exitFullscreen: () => this.fullscreenController.exitFullscreen(),
        setCurrentTextTrack: (trackId) => __awaiter$h(this, void 0, void 0, function* () {
          if (trackId !== this.currentTextTrack)
            this.toggleTextTrackModes(trackId);
        }),
        setTextTrackVisibility: (isVisible) => __awaiter$h(this, void 0, void 0, function* () {
          this.isTextTrackVisible = isVisible;
          this.toggleTextTrackModes(this.currentTextTrack);
        })
      };
    });
  }
  onHasCustomTextManagerChange() {
    if (this.hasCustomTextManager) {
      this.textTracksDisposal.empty();
    } else if (this.playbackReady) {
      this.listenToTextTracksForChanges();
    }
  }
  onShouldRenderNativeTextTracksChange() {
    if (this.hasCustomTextManager)
      return;
    this.toggleTextTrackModes(this.currentTextTrack);
  }
  onProviderConnect(event) {
    if (this.noConnect)
      event.stopImmediatePropagation();
  }
  onProviderDisconnect(event) {
    if (this.noConnect)
      event.stopImmediatePropagation();
  }
  getFilteredTextTracks() {
    const tracks = [];
    const textTrackList = Array.from(this.mediaEl.textTracks);
    for (let i2 = 0; i2 < textTrackList.length; i2 += 1) {
      const track = textTrackList[i2];
      if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
        tracks.push(textTrackList[i2]);
      }
    }
    return tracks;
  }
  listenToTextTracksForChanges() {
    if (this.hasCustomTextManager)
      return;
    this.textTracksDisposal.empty();
    if (isUndefined(this.mediaEl))
      return;
    this.textTracksDisposal.add(listen(this.mediaEl.textTracks, "change", this.onTextTracksChange.bind(this)));
  }
  onTextTracksChange() {
    var _a2;
    const tracks = this.getFilteredTextTracks();
    let trackId = -1;
    for (let id = 0; id < tracks.length; id += 1) {
      if (tracks[id].mode === "hidden") {
        trackId = id;
      } else if (tracks[id].mode === "showing") {
        trackId = id;
        break;
      }
    }
    if (!this.shouldRenderNativeTextTracks && ((_a2 = tracks[trackId]) === null || _a2 === void 0 ? void 0 : _a2.mode) === "showing") {
      tracks[trackId].mode = "hidden";
      return;
    }
    if (this.shouldRenderNativeTextTracks) {
      this.isTextTrackVisible = trackId !== -1 && tracks[trackId].mode === "showing";
      this.dispatch("isTextTrackVisible", this.isTextTrackVisible);
    }
    this.dispatch("textTracks", tracks);
    this.dispatch("currentTextTrack", this.shouldRenderNativeTextTracks && !this.isTextTrackVisible ? -1 : trackId);
  }
  toggleTextTrackModes(newTrackId) {
    if (isNil(this.mediaEl))
      return;
    const { textTracks } = this.mediaEl;
    if (newTrackId === -1) {
      Array.from(textTracks).forEach((track) => {
        track.mode = "disabled";
      });
    } else {
      const oldTrack = textTracks[this.currentTextTrack];
      if (oldTrack)
        oldTrack.mode = "disabled";
    }
    const nextTrack = textTracks[newTrackId];
    if (nextTrack) {
      nextTrack.mode = this.isTextTrackVisible && this.shouldRenderNativeTextTracks ? "showing" : "hidden";
    }
    this.dispatch("currentTextTrack", this.shouldRenderNativeTextTracks && !this.isTextTrackVisible ? -1 : newTrackId);
    this.dispatch("isTextTrackVisible", this.isTextTrackVisible);
  }
  render() {
    const mediaProps = {
      autoplay: this.autoplay,
      muted: this.muted,
      playsinline: this.playsinline,
      playsInline: this.playsinline,
      "x5-playsinline": this.playsinline,
      "webkit-playsinline": this.playsinline,
      controls: this.controls,
      crossorigin: this.crossOrigin === "" ? "anonymous" : this.crossOrigin,
      controlslist: this.controlsList,
      "data-poster": !this.hasCustomPoster() ? this.poster : void 0,
      loop: this.loop,
      preload: this.preload,
      disablePictureInPicture: this.disablePiP,
      autoPictureInPicture: this.autoPiP,
      disableRemotePlayback: this.disableRemotePlayback,
      "x-webkit-airplay": this.disableRemotePlayback ? "deny" : "allow",
      ref: (el) => {
        this.mediaEl = el;
      },
      onLoadedMetadata: this.onLoadedMetadata.bind(this),
      onProgress: this.onProgress.bind(this),
      onPlay: this.onPlay.bind(this),
      onPause: this.onPause.bind(this),
      onPlaying: this.onPlaying.bind(this),
      onSeeking: this.onSeeking.bind(this),
      onSeeked: this.onSeeked.bind(this),
      onRateChange: this.onRateChange.bind(this),
      onVolumeChange: this.onVolumeChange.bind(this),
      onDurationChange: this.onDurationChange.bind(this),
      onWaiting: this.onWaiting.bind(this),
      onSuspend: this.onSuspend.bind(this),
      onEnded: this.onEnded.bind(this),
      onError: this.onError.bind(this)
    };
    const audio = h("audio", Object.assign({ class: "lazy" }, mediaProps), h("slot", null), "Your browser does not support the", h("code", null, "audio"), "element.");
    const video = h("video", Object.assign({ class: "lazy" }, mediaProps, {
      onenterpictureinpicture: this.onEnterPiP.bind(this),
      onleavepictureinpicture: this.onLeavePiP.bind(this)
    }), h("slot", null), "Your browser does not support the", h("code", null, "video"), "element.");
    return this.viewType === ViewType.Audio ? audio : video;
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "mediaTitle": ["onMediaTitleChange"],
      "poster": ["onPosterChange"],
      "viewType": ["onViewTypeChange"],
      "hasCustomTextManager": ["onHasCustomTextManagerChange"],
      "shouldRenderNativeTextTracks": ["onShouldRenderNativeTextTracksChange"]
    };
  }
  static get style() {
    return fileCss;
  }
};
var fullscreenControlCss = ":host([hidden]){display:none}";
var __awaiter$g = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FullscreenControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.canSetFullscreen = false;
    this.enterIcon = "fullscreen-enter";
    this.exitIcon = "fullscreen-exit";
    this.tooltipPosition = "top";
    this.hideTooltip = false;
    this.keys = "f";
    this.isFullscreenActive = false;
    this.i18n = {};
    this.playbackReady = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["isFullscreenActive", "playbackReady", "i18n"]);
  }
  onPlaybackReadyChange() {
    var _a2;
    return __awaiter$g(this, void 0, void 0, function* () {
      const player = getPlayerFromRegistry(this);
      this.canSetFullscreen = (_a2 = yield player === null || player === void 0 ? void 0 : player.canSetFullscreen()) !== null && _a2 !== void 0 ? _a2 : false;
    });
  }
  componentDidLoad() {
    this.onPlaybackReadyChange();
  }
  onClick() {
    const player = getPlayerFromRegistry(this);
    !this.isFullscreenActive ? player === null || player === void 0 ? void 0 : player.enterFullscreen() : player === null || player === void 0 ? void 0 : player.exitFullscreen();
  }
  render() {
    const tooltip = this.isFullscreenActive ? this.i18n.exitFullscreen : this.i18n.enterFullscreen;
    const tooltipWithHint = !isUndefined(this.keys) ? `${tooltip} (${this.keys})` : tooltip;
    return h(Host, { hidden: !this.canSetFullscreen }, h("vm-control", { label: this.i18n.fullscreen, keys: this.keys, pressed: this.isFullscreenActive, hidden: !this.canSetFullscreen, onClick: this.onClick.bind(this) }, h("vm-icon", { name: this.isFullscreenActive ? this.exitIcon : this.enterIcon, library: this.icons }), h("vm-tooltip", { hidden: this.hideTooltip, position: this.tooltipPosition, direction: this.tooltipDirection }, tooltipWithHint)));
  }
  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReadyChange"]
    };
  }
  static get style() {
    return fullscreenControlCss;
  }
};
var __awaiter$f = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HLS = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.hasAttached = false;
    this.version = "latest";
    this.preload = "metadata";
    this.playbackReady = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withPlayerContext(this, ["playbackReady"]);
  }
  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    if (this.mediaEl)
      this.setupHls();
  }
  disconnectedCallback() {
    this.destroyHls();
  }
  get src() {
    if (isNil(this.videoProvider))
      return void 0;
    const sources = this.videoProvider.querySelectorAll("source");
    const currSource = Array.from(sources).find((source) => hlsRegex.test(source.src) || hlsTypeRegex.test(source.type));
    return currSource === null || currSource === void 0 ? void 0 : currSource.src;
  }
  setupHls() {
    return __awaiter$f(this, void 0, void 0, function* () {
      if (!isUndefined(this.hls))
        return;
      try {
        const url = this.libSrc || `https://cdn.jsdelivr.net/npm/hls.js@${this.version}/dist/hls.min.js`;
        const Hls2 = yield loadSDK(url, "Hls");
        if (!Hls2.isSupported()) {
          this.vmError.emit("hls.js is not supported");
          return;
        }
        this.hls = new Hls2(this.config);
        this.hls.on(Hls2.Events.MEDIA_ATTACHED, () => {
          this.hasAttached = true;
          this.onSrcChange();
        });
        this.hls.on(Hls2.Events.AUDIO_TRACKS_UPDATED, () => {
          this.dispatch("audioTracks", this.hls.audioTracks);
          this.dispatch("currentAudioTrack", this.hls.audioTrack);
        });
        this.hls.on(Hls2.Events.AUDIO_TRACK_SWITCHED, () => {
          this.dispatch("currentAudioTrack", this.hls.audioTrack);
        });
        this.hls.on(Hls2.Events.ERROR, (event, data) => {
          if (data.fatal) {
            switch (data.type) {
              case Hls2.ErrorTypes.NETWORK_ERROR:
                this.hls.startLoad();
                break;
              case Hls2.ErrorTypes.MEDIA_ERROR:
                this.hls.recoverMediaError();
                break;
              default:
                this.destroyHls();
                break;
            }
          }
          this.vmError.emit({ event, data });
        });
        this.hls.on(Hls2.Events.MANIFEST_PARSED, () => {
          this.dispatch("mediaType", MediaType.Video);
          this.dispatch("currentSrc", this.src);
          this.dispatchLevels();
        });
        this.hls.on(Hls2.Events.LEVEL_LOADED, (_, data) => {
          if (!this.playbackReady) {
            this.dispatch("duration", data.details.totalduration);
            this.dispatch("playbackReady", true);
          }
        });
        this.hls.attachMedia(this.mediaEl);
      } catch (e) {
        this.vmError.emit(e);
      }
    });
  }
  dispatchLevels() {
    if (!this.hls.levels || this.hls.levels.length === 0)
      return;
    this.dispatch("playbackQualities", [
      "Auto",
      ...this.hls.levels.map(this.levelToPlaybackQuality)
    ]);
    this.dispatch("playbackQuality", "Auto");
  }
  levelToPlaybackQuality(level) {
    return level === -1 ? "Auto" : `${level.height}p`;
  }
  findLevelIndexFromQuality(quality) {
    return this.hls.levels.findIndex((level) => this.levelToPlaybackQuality(level) === quality);
  }
  destroyHls() {
    var _a2;
    (_a2 = this.hls) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    this.hasAttached = false;
  }
  onMediaElChange(event) {
    return __awaiter$f(this, void 0, void 0, function* () {
      this.destroyHls();
      if (isUndefined(event.detail))
        return;
      this.mediaEl = event.detail;
      setTimeout(() => __awaiter$f(this, void 0, void 0, function* () {
        yield this.setupHls();
      }), 50);
    });
  }
  onSrcChange() {
    var _a2;
    return __awaiter$f(this, void 0, void 0, function* () {
      if (this.hasAttached && this.hls.url !== this.src) {
        this.vmLoadStart.emit();
        (_a2 = this.hls) === null || _a2 === void 0 ? void 0 : _a2.loadSource(this.src);
      }
    });
  }
  getAdapter() {
    var _a2, _b2;
    return __awaiter$f(this, void 0, void 0, function* () {
      const adapter = (_b2 = yield (_a2 = this.videoProvider) === null || _a2 === void 0 ? void 0 : _a2.getAdapter()) !== null && _b2 !== void 0 ? _b2 : {};
      const canVideoProviderPlay = adapter.canPlay;
      return Object.assign(Object.assign({}, adapter), { getInternalPlayer: () => __awaiter$f(this, void 0, void 0, function* () {
        return this.hls;
      }), canPlay: (type) => __awaiter$f(this, void 0, void 0, function* () {
        var _c;
        return isString(type) && hlsRegex.test(type) || ((_c = canVideoProviderPlay === null || canVideoProviderPlay === void 0 ? void 0 : canVideoProviderPlay(type)) !== null && _c !== void 0 ? _c : false);
      }), canSetPlaybackQuality: () => __awaiter$f(this, void 0, void 0, function* () {
        var _d, _e;
        return ((_e = (_d = this.hls) === null || _d === void 0 ? void 0 : _d.levels) === null || _e === void 0 ? void 0 : _e.length) > 0;
      }), setPlaybackQuality: (quality) => __awaiter$f(this, void 0, void 0, function* () {
        if (!isUndefined(this.hls)) {
          this.hls.currentLevel = this.findLevelIndexFromQuality(quality);
          this.dispatch("playbackQuality", quality);
        }
      }), setCurrentAudioTrack: (trackId) => __awaiter$f(this, void 0, void 0, function* () {
        if (!isUndefined(this.hls)) {
          this.hls.audioTrack = trackId;
        }
      }) });
    });
  }
  render() {
    return h("vm-video", { willAttach: true, crossOrigin: this.crossOrigin, preload: this.preload, poster: this.poster, controlsList: this.controlsList, autoPiP: this.autoPiP, disablePiP: this.disablePiP, disableRemotePlayback: this.disableRemotePlayback, mediaTitle: this.mediaTitle, ref: (el) => {
      this.videoProvider = el;
    } }, h("slot", null));
  }
};
var ICONS_BASE_CDN_URL = "https://cdn.jsdelivr.net/npm/@vime/core@latest/icons";
var registry = new Map(Object.entries({
  vime: (iconName) => `${ICONS_BASE_CDN_URL}/vime/vm-${iconName}.svg`,
  material: (iconName) => `${ICONS_BASE_CDN_URL}/material/md-${iconName}.svg`
}));
var watch = /* @__PURE__ */ new Set();
function withIconRegistry(component) {
  const el = getElement(component);
  createStencilHook(component, () => {
    watch.add(el);
  }, () => {
    watch.delete(el);
  });
}
var getIconLibraryResolver = (name) => registry.get(name);
function registerIconLibrary(name, resolver) {
  if (!isUndefined(resolver)) {
    registry.set(name, resolver);
  }
  watch.forEach((iconEl) => {
    if (iconEl.library === name)
      iconEl.redraw();
  });
}
function deregisterIconLibrary(name) {
  registry.delete(name);
}
var __awaiter$e = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var iconFiles = /* @__PURE__ */ new Map();
var requestIcon = (url) => {
  if (iconFiles.has(url))
    return iconFiles.get(url);
  const request = fetch(url).then((response) => __awaiter$e(void 0, void 0, void 0, function* () {
    if (response.ok) {
      const div = document.createElement("div");
      div.innerHTML = yield response.text();
      const svg = div.firstElementChild;
      return {
        ok: response.ok,
        status: response.status,
        svg: svg && svg.tagName.toLowerCase() === "svg" ? svg.outerHTML : ""
      };
    }
    return {
      ok: response.ok,
      status: response.status
    };
  }));
  iconFiles.set(url, request);
  return request;
};
var iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;box-sizing:content-box !important}.icon,svg{display:block;height:100%;width:100%;transition:var(--vm-icon-transition);transform:var(--vm-icon-transform);fill:var(--vm-icon-fill, currentColor);stroke:var(--vm-icon-stroke)}";
var __awaiter$d = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parser = new DOMParser();
var Icon = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmLoad = createEvent(this, "vmLoad", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.icons = "material";
    withComponentRegistry(this);
    withIconRegistry(this);
  }
  handleChange() {
    this.setIcon();
  }
  connectedCallback() {
    withPlayerContext(this, ["icons"]);
  }
  componentDidLoad() {
    this.setIcon();
  }
  redraw() {
    return __awaiter$d(this, void 0, void 0, function* () {
      this.setIcon();
    });
  }
  getLabel() {
    let label = "";
    if (this.label) {
      label = this.label;
    } else if (this.name) {
      label = this.name.replace(/-/g, " ");
    } else if (this.src) {
      label = this.src.replace(/.*\//, "").replace(/-/g, " ").replace(/\.svg/i, "");
    }
    return label;
  }
  setIcon() {
    var _a2;
    return __awaiter$d(this, void 0, void 0, function* () {
      const resolver = getIconLibraryResolver((_a2 = this.library) !== null && _a2 !== void 0 ? _a2 : this.icons);
      let url = this.src;
      if (this.name && resolver) {
        url = resolver(this.name);
      }
      if (url) {
        try {
          const file = yield requestIcon(url);
          if (file.ok) {
            const doc2 = parser.parseFromString(file.svg, "text/html");
            const svg = doc2.body.querySelector("svg");
            if (svg) {
              this.svg = svg.outerHTML;
              this.vmLoad.emit();
            } else {
              this.svg = "";
              this.vmError.emit({ status: file.status });
            }
          }
        } catch (_b2) {
          this.vmError.emit();
        }
      }
    });
  }
  render() {
    return h("div", { class: "icon", role: "img", "aria-label": this.getLabel(), innerHTML: this.svg });
  }
  static get watchers() {
    return {
      "name": ["handleChange"],
      "src": ["handleChange"],
      "library": ["handleChange"],
      "icons": ["handleChange"]
    };
  }
  static get style() {
    return iconCss;
  }
};
var IconLibrary = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.icons = "material";
    withComponentRegistry(this);
    withPlayerContext(this, ["icons"]);
  }
  handleUpdate() {
    this.register();
  }
  connectedCallback() {
    this.register();
  }
  disconnectedCallback() {
    if (!isUndefined(this.name))
      deregisterIconLibrary(this.name);
  }
  register() {
    var _a2;
    registerIconLibrary((_a2 = this.name) !== null && _a2 !== void 0 ? _a2 : this.icons, this.name ? this.resolver : void 0);
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["handleUpdate"],
      "resolver": ["handleUpdate"],
      "icons": ["handleUpdate"]
    };
  }
};
var liveIndicatorCss = ".liveIndicator{display:flex;align-items:center;font-size:13px;font-weight:bold;letter-spacing:0.6px;color:var(--vm-control-color)}.liveIndicator.hidden{display:none}.indicator{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:4px;background-color:var(--vm-live-indicator-color, red)}";
var LiveIndicator = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.isLive = false;
    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ["isLive", "i18n"]);
  }
  render() {
    return h("div", { class: {
      liveIndicator: true,
      hidden: !this.isLive
    } }, h("div", { class: "indicator" }), this.i18n.live);
  }
  static get style() {
    return liveIndicatorCss;
  }
};
var loadingScreenCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-loading-screen-z-index);display:flex;align-items:center;justify-content:center}.loadingScreen{opacity:100;transition:var(--vm-fade-transition)}.loadingScreen.inactive{opacity:0}.dotPulse{position:relative;left:-9999px;width:var(--vm-loading-screen-dot-size);height:var(--vm-loading-screen-dot-size);border-radius:calc(var(--vm-loading-screen-dot-size) / 2);background-color:var(--vm-loading-screen-dot-color);color:var(--vm-loading-screen-dot-color);box-shadow:9999px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n    var(--vm-loading-screen-dot-color);animation:dotPulse var(--vm-loading-screen-pulse-duration) infinite linear;animation-delay:calc(var(--vm-loading-screen-pulse-duration) / 6)}.dotPulse::before,.dotPulse::after{content:'';display:inline-block;position:absolute;top:0;width:var(--vm-loading-screen-dot-size);height:var(--vm-loading-screen-dot-size);border-radius:calc(var(--vm-loading-screen-dot-size) / 2);background-color:var(--vm-loading-screen-dot-color);color:var(--vm-loading-screen-dot-color)}.dotPulse::before{box-shadow:9984px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n    var(--vm-loading-screen-dot-color);animation:dotPulseBefore var(--vm-loading-screen-pulse-duration) infinite\n    linear;animation-delay:0s}.dotPulse::after{box-shadow:10014px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n    var(--vm-loading-screen-dot-color);animation:dotPulseAfter var(--vm-loading-screen-pulse-duration) infinite\n    linear;animation-delay:calc(var(--vm-loading-screen-pulse-duration) / 3)}@keyframes dotPulseBefore{0%{box-shadow:9984px 0 0\n      calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n      var(--vm-loading-screen-dot-color)}30%{box-shadow:9984px 0 0 2px var(--vm-loading-screen-dot-color)}60%,100%{box-shadow:9984px 0 0\n      calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n      var(--vm-loading-screen-dot-color)}}@keyframes dotPulse{0%{box-shadow:9999px 0 0\n      calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n      var(--vm-loading-screen-dot-color)}30%{box-shadow:9999px 0 0 2px var(--vm-loading-screen-dot-color)}60%,100%{box-shadow:9999px 0 0\n      calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n      var(--vm-loading-screen-dot-color)}}@keyframes dotPulseAfter{0%{box-shadow:10014px 0 0\n      calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n      var(--vm-loading-screen-dot-color)}30%{box-shadow:10014px 0 0 2px var(--vm-loading-screen-dot-color)}60%,100%{box-shadow:10014px 0 0\n      calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1)\n      var(--vm-loading-screen-dot-color)}}";
var LoadingScreen = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.playbackReady = false;
    this.hideDots = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["playbackReady"]);
  }
  render() {
    return h("div", { class: {
      loadingScreen: true,
      inactive: this.playbackReady
    } }, h("slot", null), !this.hideDots && h("div", { class: "dotPulse" }));
  }
  static get style() {
    return loadingScreenCss;
  }
};
function unwrapSubmenu(el) {
  if (el.tagName.toLowerCase() !== "vm-submenu")
    return el;
  const submenu = el;
  return submenu.shadowRoot.querySelector("vm-menu-item");
}
function unwrapRadioGroup(el) {
  var _a2;
  if (el.tagName.toLowerCase() !== "vm-menu-radio-group")
    return el;
  const radioGroup = el;
  const slot = radioGroup.shadowRoot.querySelector("slot");
  const assignedElements = Array.from((_a2 = slot === null || slot === void 0 ? void 0 : slot.assignedElements()) !== null && _a2 !== void 0 ? _a2 : []);
  return assignedElements.filter((radio) => radio.tagName.toLowerCase() === "vm-menu-radio").map((radio) => radio.shadowRoot.querySelector("vm-menu-item"));
}
function menuItemHunter(assignedElements) {
  if (isUndefined(assignedElements))
    return [];
  const allowed = ["vm-menu-item", "vm-menu-radio-group", "vm-submenu"];
  return Array.from(assignedElements !== null && assignedElements !== void 0 ? assignedElements : []).filter((el) => allowed.includes(el.tagName.toLowerCase())).map((el) => unwrapSubmenu(el)).map((el) => unwrapRadioGroup(el)).reduce((acc, val) => acc.concat(val), []);
}
var menuCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden;pointer-events:none;z-index:var(--vm-menu-z-index)}:host([active]){pointer-events:auto;z-index:calc(var(--vm-menu-z-index) + 1)}.menu{position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;transition:var(--vm-menu-transition)}.menu.slideIn{transform:translateX(0)}.menu[aria-hidden='true'].slideInFromLeft{transform:translateX(-100%)}.menu[aria-hidden='true'].slideInFromRight{transform:translateX(100%)}.container{display:flex;flex-direction:column;position:relative;text-align:left;width:100%;height:100%;color:var(--vm-menu-color);background:var(--vm-menu-bg);font-size:var(--vm-menu-font-size);font-weight:var(--vm-menu-font-weight)}.menu:focus{outline:0}";
var __awaiter$c = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Menu = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmOpen = createEvent(this, "vmOpen", 7);
    this.vmClose = createEvent(this, "vmClose", 7);
    this.vmFocus = createEvent(this, "vmFocus", 7);
    this.vmBlur = createEvent(this, "vmBlur", 7);
    this.vmActiveSubmenuChange = createEvent(this, "vmActiveSubmenuChange", 7);
    this.vmActiveMenuItemChange = createEvent(this, "vmActiveMenuItemChange", 7);
    this.vmMenuHeightChange = createEvent(this, "vmMenuHeightChange", 3);
    this.hasDisconnected = false;
    this.active = false;
    withComponentRegistry(this);
  }
  onActiveMenuitemChange() {
    this.vmActiveMenuItemChange.emit(this.activeMenuItem);
  }
  onActiveSubmenuChange() {
    this.vmActiveSubmenuChange.emit(this.activeSubmenu);
  }
  onActiveChange() {
    var _a2;
    if (this.hasDisconnected)
      return;
    this.active ? this.vmOpen.emit(this.host) : this.vmClose.emit(this.host);
    if (((_a2 = this.controller) === null || _a2 === void 0 ? void 0 : _a2.tagName.toLowerCase()) === "vm-menu-item") {
      this.controller.expanded = true;
    }
  }
  connectedCallback() {
    this.hasDisconnected = false;
  }
  componentDidRender() {
    writeTask(() => {
      if (!this.hasDisconnected)
        this.calculateHeight();
    });
  }
  disconnectedCallback() {
    this.controller = void 0;
    this.hasDisconnected = true;
  }
  focusMenu() {
    var _a2;
    return __awaiter$c(this, void 0, void 0, function* () {
      (_a2 = this.menu) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  }
  blurMenu() {
    var _a2;
    return __awaiter$c(this, void 0, void 0, function* () {
      (_a2 = this.menu) === null || _a2 === void 0 ? void 0 : _a2.blur();
    });
  }
  getActiveMenuItem() {
    return __awaiter$c(this, void 0, void 0, function* () {
      return this.activeMenuItem;
    });
  }
  setActiveMenuItem(item) {
    return __awaiter$c(this, void 0, void 0, function* () {
      item === null || item === void 0 ? void 0 : item.focusItem();
      this.activeMenuItem = item;
    });
  }
  calculateHeight() {
    var _a2, _b2;
    return __awaiter$c(this, void 0, void 0, function* () {
      let height = 0;
      if (this.activeSubmenu) {
        const submenu = yield this.activeSubmenu.getMenu();
        height = (_a2 = yield submenu === null || submenu === void 0 ? void 0 : submenu.calculateHeight()) !== null && _a2 !== void 0 ? _a2 : 0;
        height += yield this.activeSubmenu.getControllerHeight();
      } else {
        const children = ((_b2 = this.container) === null || _b2 === void 0 ? void 0 : _b2.firstChild).assignedElements({ flatten: true });
        children === null || children === void 0 ? void 0 : children.forEach((child) => {
          height += parseFloat(window.getComputedStyle(child).height);
        });
      }
      this.vmMenuHeightChange.emit(height);
      return height;
    });
  }
  onOpenSubmenu(event) {
    event.stopPropagation();
    if (!isUndefined(this.activeSubmenu))
      this.activeSubmenu.active = false;
    this.activeSubmenu = event.detail;
    this.getChildren().forEach((child) => {
      if (child !== this.activeSubmenu) {
        child.style.opacity = "0";
        child.style.visibility = "hidden";
      }
    });
    writeTask(() => {
      this.activeSubmenu.active = true;
    });
  }
  onCloseSubmenu(event) {
    event === null || event === void 0 ? void 0 : event.stopPropagation();
    if (!isUndefined(this.activeSubmenu))
      this.activeSubmenu.active = false;
    this.getChildren().forEach((child) => {
      if (child !== this.activeSubmenu) {
        child.style.opacity = "";
        child.style.visibility = "";
      }
    });
    writeTask(() => {
      this.activeSubmenu = void 0;
    });
  }
  onWindowClick() {
    this.onCloseSubmenu();
    this.onClose();
  }
  onWindowKeyDown(event) {
    if (this.active && event.key === "Escape") {
      this.onCloseSubmenu();
      this.onClose();
      this.focusController();
    }
  }
  getChildren() {
    var _a2;
    const assignedElements = (_a2 = this.host.shadowRoot.querySelector("slot")) === null || _a2 === void 0 ? void 0 : _a2.assignedElements({ flatten: true });
    return assignedElements !== null && assignedElements !== void 0 ? assignedElements : [];
  }
  getMenuItems() {
    var _a2;
    const assignedElements = (_a2 = this.host.shadowRoot.querySelector("slot")) === null || _a2 === void 0 ? void 0 : _a2.assignedElements({ flatten: true });
    return menuItemHunter(assignedElements);
  }
  focusController() {
    var _a2, _b2, _c, _d, _e;
    if (!isUndefined((_a2 = this.controller) === null || _a2 === void 0 ? void 0 : _a2.focusItem)) {
      (_b2 = this.controller) === null || _b2 === void 0 ? void 0 : _b2.focusItem();
    } else if (!isUndefined((_c = this.controller) === null || _c === void 0 ? void 0 : _c.focusControl)) {
      (_d = this.controller) === null || _d === void 0 ? void 0 : _d.focusControl();
    } else {
      (_e = this.controller) === null || _e === void 0 ? void 0 : _e.focus();
    }
  }
  triggerMenuItem() {
    var _a2;
    if (isUndefined(this.activeMenuItem))
      return;
    this.activeMenuItem.click();
    (_a2 = this.activeMenuItem.menu) === null || _a2 === void 0 ? void 0 : _a2.focusMenu();
  }
  onClose() {
    this.activeMenuItem = void 0;
    this.active = false;
  }
  onClick(event) {
    event.stopPropagation();
  }
  onFocus() {
    var _a2;
    this.active = true;
    [this.activeMenuItem] = this.getMenuItems();
    (_a2 = this.activeMenuItem) === null || _a2 === void 0 ? void 0 : _a2.focusItem();
    this.vmFocus.emit();
  }
  onBlur() {
    this.vmBlur.emit();
  }
  foucsMenuItem(items, index) {
    if (index < 0)
      index = items.length - 1;
    if (index > items.length - 1)
      index = 0;
    this.activeMenuItem = items[index];
    this.activeMenuItem.focusItem();
  }
  onKeyDown(event) {
    if (!this.active)
      return;
    event.preventDefault();
    event.stopPropagation();
    const items = this.getMenuItems();
    let index = items.findIndex((item) => item === this.activeMenuItem);
    switch (event.key) {
      case "Escape":
        this.onClose();
        this.focusController();
        break;
      case "ArrowDown":
      case "Tab":
        this.foucsMenuItem(items, index += 1);
        break;
      case "ArrowUp":
        this.foucsMenuItem(items, index -= 1);
        break;
      case "ArrowLeft":
        this.onClose();
        this.focusController();
        break;
      case "ArrowRight":
      case "Enter":
      case " ":
        this.triggerMenuItem();
        break;
      case "Home":
      case "PageUp":
        this.foucsMenuItem(items, 0);
        break;
      case "End":
      case "PageDown":
        this.foucsMenuItem(items, items.length - 1);
        break;
    }
  }
  render() {
    var _a2, _b2, _c;
    return h("div", { id: this.identifier, class: {
      menu: true,
      slideIn: !isUndefined(this.slideInDirection),
      slideInFromLeft: this.slideInDirection === "left",
      slideInFromRight: this.slideInDirection === "right"
    }, role: "menu", tabindex: "-1", "aria-labelledby": (_b2 = (_a2 = this.controller) === null || _a2 === void 0 ? void 0 : _a2.identifier) !== null && _b2 !== void 0 ? _b2 : (_c = this.controller) === null || _c === void 0 ? void 0 : _c.id, "aria-hidden": !this.active ? "true" : "false", onFocus: this.onFocus.bind(this), onBlur: this.onBlur.bind(this), onClick: this.onClick.bind(this), onKeyDown: this.onKeyDown.bind(this), ref: (el) => {
      this.menu = el;
    } }, h("div", { class: "container", ref: (el) => {
      this.container = el;
    } }, h("slot", null)));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "activeMenuItem": ["onActiveMenuitemChange"],
      "activeSubmenu": ["onActiveSubmenuChange"],
      "active": ["onActiveChange"]
    };
  }
  static get style() {
    return menuCss;
  }
};
var menuItemCss = ":host{display:block}.menuItem{display:flex;position:relative;align-items:center;flex-direction:row;cursor:pointer;color:var(--vm-menu-color);background:var(--vm-menu-bg);font-size:var(--vm-menu-font-size);font-weight:var(--vm-menu-font-weight);padding:var(--vm-menu-item-padding);touch-action:manipulation;box-sizing:border-box}.menuItem:focus{outline:0}.menuItem.hidden{display:none}.menuItem.tapHighlight{background:var(--vm-menu-item-tap-highlight)}.menuItem.showDivider{border-bottom:0.5px solid var(--vm-menu-item-divider-color)}.menuItem.notTouch:hover,.menuItem.notTouch:focus{outline:0;color:var(--vm-menu-item-focus-color);background-color:var(--vm-menu-item-focus-bg)}.menuItem[aria-expanded='true']{position:absolute;z-index:2;top:0;width:100%}.menuItem[aria-hidden='true']{display:none}.menuItem[aria-checked='true'] vm-icon{opacity:1;visibility:visible}vm-icon{display:inline-block}vm-icon{fill:currentColor;pointer-events:none;font-size:var(--vm-menu-item-check-icon-size);margin-right:10px;opacity:0;visibility:hidden;transition:var(--vm-fade-transition)}.hint{display:inline-block;margin-left:auto;overflow:hidden;pointer-events:none;margin-right:6px;font-size:var(--vm-menu-item-hint-font-size);opacity:var(--vm-menu-item-hint-opacity);color:var(--vm-menu-item-hint-color)}.badge{display:inline-block;line-height:1;overflow:hidden;pointer-events:none;margin-left:6px;color:var(--vm-menu-item-badge-color);background:var(--vm-menu-item-badge-bg);font-size:var(--vm-menu-item-badge-font-size)}.spacer{flex:1}.arrow{color:var(--vm-menu-item-arrow-color);border:2px solid;padding:2px;display:inline-block;border-width:0 2px 2px 0}.arrow.left{margin-right:6px;transform:rotate(135deg)}.arrow.right{transform:rotate(-45deg);opacity:0.38}";
var __awaiter$b = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MenuItem = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmFocus = createEvent(this, "vmFocus", 7);
    this.vmBlur = createEvent(this, "vmBlur", 7);
    this.showTapHighlight = false;
    this.hidden = false;
    this.checkIcon = "check";
    this.isTouch = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["isTouch"]);
  }
  focusItem() {
    var _a2;
    return __awaiter$b(this, void 0, void 0, function* () {
      (_a2 = this.menuItem) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  }
  blurItem() {
    var _a2;
    return __awaiter$b(this, void 0, void 0, function* () {
      (_a2 = this.menuItem) === null || _a2 === void 0 ? void 0 : _a2.blur();
    });
  }
  getHeight() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return parseFloat(this.menuItem ? window.getComputedStyle(this.menuItem).height : "0");
    });
  }
  onClick() {
    if (!isNil(this.menu))
      this.menu.active = !this.expanded;
  }
  onFocus() {
    this.vmFocus.emit();
  }
  onBlur() {
    this.vmBlur.emit();
  }
  onTouchStart() {
    this.showTapHighlight = true;
  }
  onTouchEnd() {
    setTimeout(() => {
      this.showTapHighlight = false;
    }, 100);
  }
  onMouseLeave() {
    var _a2;
    (_a2 = this.menuItem) === null || _a2 === void 0 ? void 0 : _a2.blur();
  }
  render() {
    var _a2, _b2, _c, _d;
    const isCheckedDefined = !isUndefined(this.checked);
    const isMenuDefined = !isUndefined(this.menu);
    const hasExpanded = this.expanded ? "true" : "false";
    const isChecked = this.checked ? "true" : "false";
    const showCheckedIcon = isCheckedDefined && !isUndefined(this.checkIcon);
    const showLeftNavArrow = isMenuDefined && this.expanded;
    const showRightNavArrow = isMenuDefined && !this.expanded;
    const showHint = !isUndefined(this.hint) && !isCheckedDefined && (!isMenuDefined || !this.expanded);
    const showBadge = !isUndefined(this.badge) && !showHint && !showRightNavArrow;
    const hasSpacer = showHint || showRightNavArrow;
    return h("div", { class: {
      menuItem: true,
      notTouch: !this.isTouch,
      tapHighlight: this.showTapHighlight,
      showDivider: isMenuDefined && ((_a2 = this.expanded) !== null && _a2 !== void 0 ? _a2 : false)
    }, id: this.identifier, role: isCheckedDefined ? "menuitemradio" : "menuitem", tabindex: "0", "aria-label": this.label, "aria-hidden": this.hidden ? "true" : "false", "aria-haspopup": isMenuDefined ? "true" : void 0, "aria-controls": (_c = (_b2 = this.menu) === null || _b2 === void 0 ? void 0 : _b2.identifier) !== null && _c !== void 0 ? _c : (_d = this.menu) === null || _d === void 0 ? void 0 : _d.id, "aria-expanded": isMenuDefined ? hasExpanded : void 0, "aria-checked": isCheckedDefined ? isChecked : void 0, onClick: this.onClick.bind(this), onFocus: this.onFocus.bind(this), onBlur: this.onBlur.bind(this), onTouchStart: this.onTouchStart.bind(this), onTouchEnd: this.onTouchEnd.bind(this), onMouseLeave: this.onMouseLeave.bind(this), ref: (el) => {
      this.menuItem = el;
    } }, showCheckedIcon && h("vm-icon", { name: this.checkIcon, library: this.icons }), showLeftNavArrow && h("span", { class: "arrow left" }), this.label, hasSpacer && h("span", { class: "spacer" }), showHint && h("span", { class: "hint" }, this.hint), showBadge && h("span", { class: "badge" }, this.badge), showRightNavArrow && h("span", { class: "arrow right" }));
  }
  get host() {
    return this;
  }
  static get style() {
    return menuItemCss;
  }
};
var MenuRadio = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmCheck = createEvent(this, "vmCheck", 7);
    this.checked = false;
    this.checkIcon = "check";
    withComponentRegistry(this);
  }
  onClick() {
    this.checked = true;
    this.vmCheck.emit();
  }
  render() {
    return h("vm-menu-item", { label: this.label, checked: this.checked, badge: this.badge, checkIcon: this.checkIcon, icons: this.icons, onClick: this.onClick.bind(this) });
  }
};
var MenuRadioGroup = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmCheck = createEvent(this, "vmCheck", 7);
    withComponentRegistry(this);
  }
  onValueChange() {
    var _a2;
    (_a2 = this.findRadios()) === null || _a2 === void 0 ? void 0 : _a2.forEach((radio) => {
      radio.checked = radio.value === this.value;
    });
  }
  connectedCallback() {
    this.onValueChange();
  }
  componentDidLoad() {
    this.onValueChange();
  }
  onSelectionChange(event) {
    const radio = event.target;
    this.value = radio.value;
  }
  findRadios() {
    var _a2;
    return (_a2 = this.host.shadowRoot.querySelector("slot")) === null || _a2 === void 0 ? void 0 : _a2.assignedElements();
  }
  render() {
    return h("slot", null);
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["onValueChange"]
    };
  }
};
var MuteControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmFocus = createEvent(this, "vmFocus", 7);
    this.vmBlur = createEvent(this, "vmBlur", 7);
    this.lowVolumeIcon = "volume-low";
    this.highVolumeIcon = "volume-high";
    this.mutedIcon = "volume-mute";
    this.tooltipPosition = "top";
    this.hideTooltip = false;
    this.keys = "m";
    this.volume = 50;
    this.muted = false;
    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ["muted", "volume", "i18n"]);
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }
  getIcon() {
    const volumeIcon = this.volume < 50 ? this.lowVolumeIcon : this.highVolumeIcon;
    return this.muted || this.volume === 0 ? this.mutedIcon : volumeIcon;
  }
  onClick() {
    this.dispatch("muted", !this.muted);
  }
  render() {
    const tooltip = this.muted ? this.i18n.unmute : this.i18n.mute;
    const tooltipWithHint = !isUndefined(this.keys) ? `${tooltip} (${this.keys})` : tooltip;
    return h("vm-control", { label: this.i18n.mute, pressed: this.muted, keys: this.keys, onClick: this.onClick.bind(this) }, h("vm-icon", { name: this.getIcon(), library: this.icons }), h("vm-tooltip", { hidden: this.hideTooltip, position: this.tooltipPosition, direction: this.tooltipDirection }, tooltipWithHint));
  }
};
var pipControlCss = ":host([hidden]){display:none}";
var __awaiter$a = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PiPControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.canSetPiP = false;
    this.enterIcon = "pip-enter";
    this.exitIcon = "pip-exit";
    this.tooltipPosition = "top";
    this.hideTooltip = false;
    this.keys = "p";
    this.isPiPActive = false;
    this.i18n = {};
    this.playbackReady = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["isPiPActive", "playbackReady", "i18n"]);
  }
  onPlaybackReadyChange() {
    var _a2;
    return __awaiter$a(this, void 0, void 0, function* () {
      const player = getPlayerFromRegistry(this);
      this.canSetPiP = (_a2 = yield player === null || player === void 0 ? void 0 : player.canSetPiP()) !== null && _a2 !== void 0 ? _a2 : false;
    });
  }
  componentDidLoad() {
    this.onPlaybackReadyChange();
  }
  onClick() {
    const player = getPlayerFromRegistry(this);
    !this.isPiPActive ? player === null || player === void 0 ? void 0 : player.enterPiP() : player === null || player === void 0 ? void 0 : player.exitPiP();
  }
  render() {
    const tooltip = this.isPiPActive ? this.i18n.exitPiP : this.i18n.enterPiP;
    const tooltipWithHint = !isUndefined(this.keys) ? `${tooltip} (${this.keys})` : tooltip;
    return h(Host, { hidden: !this.canSetPiP }, h("vm-control", { label: this.i18n.pip, keys: this.keys, pressed: this.isPiPActive, hidden: !this.canSetPiP, onClick: this.onClick.bind(this) }, h("vm-icon", { name: this.isPiPActive ? this.exitIcon : this.enterIcon, library: this.icons }), h("vm-tooltip", { hidden: this.hideTooltip, position: this.tooltipPosition, direction: this.tooltipDirection }, tooltipWithHint)));
  }
  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReadyChange"]
    };
  }
  static get style() {
    return pipControlCss;
  }
};
var PlaybackControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.playIcon = "play";
    this.pauseIcon = "pause";
    this.tooltipPosition = "top";
    this.hideTooltip = false;
    this.keys = "k";
    this.paused = true;
    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ["paused", "i18n"]);
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }
  onClick() {
    this.dispatch("paused", !this.paused);
  }
  render() {
    const tooltip = this.paused ? this.i18n.play : this.i18n.pause;
    const tooltipWithHint = !isUndefined(this.keys) ? `${tooltip} (${this.keys})` : tooltip;
    return h("vm-control", { label: this.i18n.playback, keys: this.keys, pressed: !this.paused, onClick: this.onClick.bind(this) }, h("vm-icon", { name: this.paused ? this.playIcon : this.pauseIcon, library: this.icons }), h("vm-tooltip", { hidden: this.hideTooltip, position: this.tooltipPosition, direction: this.tooltipDirection }, tooltipWithHint));
  }
};
var Logger = class {
  constructor() {
    this.silent = false;
  }
  log(...args) {
    if (!this.silent && !isUndefined(console))
      console.log("[Vime tip]:", ...args);
  }
  warn(...args) {
    if (!this.silent && !isUndefined(console))
      console.error("[Vime warn]:", ...args);
  }
};
var players = /* @__PURE__ */ new Set();
function withAutopause(player) {
  const el = getElement(player);
  createStencilHook(player, () => {
    players.add(el);
  }, () => {
    players.delete(el);
  });
}
function autopause(player) {
  const el = getElement(player);
  players.forEach((p) => {
    if (p !== el && p.autopause)
      p.paused = true;
  });
}
function withPlayerEvents(player) {
  const el = getElement(player);
  const cache = /* @__PURE__ */ new Map();
  function initCache() {
    Object.keys(initialState).forEach((prop) => {
      cache.set(prop, player[prop]);
    });
  }
  createStencilHook(player, () => {
    initCache();
  }, () => {
    cache.clear();
  });
  const { componentDidRender } = player;
  player.componentDidRender = function() {
    componentDidRender === null || componentDidRender === void 0 ? void 0 : componentDidRender();
    const props = Array.from(cache.keys());
    for (let i2 = 0; i2 < props.length; i2 += 1) {
      const prop = props[i2];
      const oldValue = cache.get(prop);
      const newValue = player[prop];
      if (oldValue !== newValue) {
        firePlayerEvent(el, prop, newValue, oldValue);
        cache.set(prop, newValue);
      }
    }
  };
}
var __awaiter$9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var immediateAdapterCall = /* @__PURE__ */ new Set(["currentTime", "paused"]);
function withPlayerScheduler(player) {
  const el = getElement(player);
  const disposal = new Disposal();
  const cache = /* @__PURE__ */ new Map();
  function initCache() {
    Object.keys(initialState).forEach((prop) => {
      cache.set(prop, player[prop]);
    });
  }
  let adapterCalls = [];
  function flushAdapterCalls() {
    return __awaiter$9(this, void 0, void 0, function* () {
      const adapter = yield player.adapter;
      if (isUndefined(adapter))
        return;
      for (let i2 = 0; i2 < adapterCalls.length; i2 += 1) {
        yield adapterCalls[i2](adapter);
      }
      adapterCalls = [];
    });
  }
  let hasMediaChanged = false;
  function onMediaChange(e) {
    e === null || e === void 0 ? void 0 : e.stopImmediatePropagation();
    if (!hasMediaChanged) {
      hasMediaChanged = true;
      return;
    }
    adapterCalls = [];
    writeTask(() => {
      Object.keys(initialState).filter(shouldPropResetOnMediaChange).forEach((prop) => {
        player[prop] = initialState[prop];
      });
    });
  }
  function onStateChange(event) {
    var _a2;
    return __awaiter$9(this, void 0, void 0, function* () {
      event.stopImmediatePropagation();
      const { by, prop, value } = event.detail;
      if (!isWritableProp(prop)) {
        (_a2 = player.logger) === null || _a2 === void 0 ? void 0 : _a2.warn(`${by.nodeName} tried to change \`${prop}\` but it is readonly.`);
        return;
      }
      if (!player.playbackStarted && immediateAdapterCall.has(prop)) {
        const adapter = yield player.adapter;
        if (prop === "paused" && !value) {
          adapter === null || adapter === void 0 ? void 0 : adapter.play();
        }
        if (prop === "currentTime") {
          adapter === null || adapter === void 0 ? void 0 : adapter.play();
          adapter === null || adapter === void 0 ? void 0 : adapter.setCurrentTime(value);
        }
      }
      writeTask(() => {
        player[prop] = value;
      });
    });
  }
  const { onProviderDisconnect } = player;
  player.onProviderDisconnect = function() {
    onMediaChange();
    if (onProviderDisconnect)
      onProviderDisconnect.call(player);
  };
  createStencilHook(player, () => {
    initCache();
    disposal.add(listen(el, LOAD_START_EVENT, onMediaChange));
    disposal.add(listen(el, STATE_CHANGE_EVENT, onStateChange));
  }, () => {
    cache.clear();
    disposal.empty();
  });
  wrapStencilHook(player, "componentWillRender", () => __awaiter$9(this, void 0, void 0, function* () {
    if (player.playbackReady && adapterCalls.length > 0)
      yield flushAdapterCalls();
  }));
  function isAdapterCallRequired(prop, value) {
    var _a2;
    return value !== ((_a2 = player[PROVIDER_CACHE_KEY]) === null || _a2 === void 0 ? void 0 : _a2.get(prop));
  }
  return function safeAdapterCall(prop, method) {
    return __awaiter$9(this, void 0, void 0, function* () {
      if (!isAdapterCallRequired(prop, player[prop]))
        return;
      const value = player[prop];
      const safeCall2 = (adapter) => __awaiter$9(this, void 0, void 0, function* () {
        var _a2;
        try {
          yield (_a2 = adapter === null || adapter === void 0 ? void 0 : adapter[method]) === null || _a2 === void 0 ? void 0 : _a2.call(adapter, value);
        } catch (e) {
          el.dispatchEvent(new CustomEvent("vmError", { detail: e }));
        }
      });
      if (player.playbackReady) {
        yield safeCall2(yield player.adapter);
      } else {
        adapterCalls.push(safeCall2);
      }
    });
  };
}
var playerCss = ".player{box-sizing:border-box;direction:ltr;font-family:var(--vm-player-font-family);-moz-osx-font-smoothing:auto;-webkit-font-smoothing:subpixel-antialiased;-webkit-tap-highlight-color:transparent;font-variant-numeric:tabular-nums;font-weight:500;line-height:1.7;width:100%;display:block;max-width:100%;min-width:275px;min-height:40px;position:relative;text-shadow:none;outline:0;transition:box-shadow 0.3s ease;box-shadow:var(--vm-player-box-shadow);border-radius:var(--vm-player-border-radius)}.player.idle{cursor:none}.player.audio{background-color:transparent !important}.player.video{height:0;overflow:hidden;background-color:var(--vm-player-bg, #000)}.player.fullscreen{margin:0;border-radius:0;width:100%;height:100%;padding-bottom:0 !important}.blocker{position:absolute;top:0;left:0;width:100%;height:100%;display:inline-block;z-index:var(--vm-blocker-z-index)}";
var __awaiter$8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var idCount$3 = 0;
var Player = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmThemeChange = createEvent(this, "vmThemeChange", 7);
    this.vmPausedChange = createEvent(this, "vmPausedChange", 7);
    this.vmPlay = createEvent(this, "vmPlay", 7);
    this.vmPlayingChange = createEvent(this, "vmPlayingChange", 7);
    this.vmSeekingChange = createEvent(this, "vmSeekingChange", 7);
    this.vmSeeked = createEvent(this, "vmSeeked", 7);
    this.vmBufferingChange = createEvent(this, "vmBufferingChange", 7);
    this.vmDurationChange = createEvent(this, "vmDurationChange", 7);
    this.vmCurrentTimeChange = createEvent(this, "vmCurrentTimeChange", 7);
    this.vmReady = createEvent(this, "vmReady", 7);
    this.vmPlaybackReady = createEvent(this, "vmPlaybackReady", 7);
    this.vmPlaybackStarted = createEvent(this, "vmPlaybackStarted", 7);
    this.vmPlaybackEnded = createEvent(this, "vmPlaybackEnded", 7);
    this.vmBufferedChange = createEvent(this, "vmBufferedChange", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmCurrentProviderChange = createEvent(this, "vmCurrentProviderChange", 7);
    this.vmCurrentSrcChange = createEvent(this, "vmCurrentSrcChange", 7);
    this.vmCurrentPosterChange = createEvent(this, "vmCurrentPosterChange", 7);
    this.vmMediaTitleChange = createEvent(this, "vmMediaTitleChange", 7);
    this.vmControlsChange = createEvent(this, "vmControlsChange", 7);
    this.vmPlaybackRateChange = createEvent(this, "vmPlaybackRateChange", 7);
    this.vmPlaybackRatesChange = createEvent(this, "vmPlaybackRatesChange", 7);
    this.vmPlaybackQualityChange = createEvent(this, "vmPlaybackQualityChange", 7);
    this.vmPlaybackQualitiesChange = createEvent(this, "vmPlaybackQualitiesChange", 7);
    this.vmMutedChange = createEvent(this, "vmMutedChange", 7);
    this.vmVolumeChange = createEvent(this, "vmVolumeChange", 7);
    this.vmViewTypeChange = createEvent(this, "vmViewTypeChange", 7);
    this.vmMediaTypeChange = createEvent(this, "vmMediaTypeChange", 7);
    this.vmLiveChange = createEvent(this, "vmLiveChange", 7);
    this.vmTouchChange = createEvent(this, "vmTouchChange", 7);
    this.vmLanguageChange = createEvent(this, "vmLanguageChange", 7);
    this.vmI18nChange = createEvent(this, "vmI18nChange", 7);
    this.vmTranslationsChange = createEvent(this, "vmTranslationsChange", 7);
    this.vmLanguagesChange = createEvent(this, "vmLanguagesChange", 7);
    this.vmFullscreenChange = createEvent(this, "vmFullscreenChange", 7);
    this.vmPiPChange = createEvent(this, "vmPiPChange", 7);
    this.vmTextTracksChange = createEvent(this, "vmTextTracksChange", 7);
    this.vmCurrentTextTrackChange = createEvent(this, "vmCurrentTextTrackChange", 7);
    this.vmTextTrackVisibleChange = createEvent(this, "vmTextTrackVisibleChange", 7);
    this.vmAudioTracksChange = createEvent(this, "vmAudioTracksChange", 7);
    this.vmCurrentAudioTrackChange = createEvent(this, "vmCurrentAudioTrackChange", 7);
    this.disposal = new Disposal();
    this.logger = new Logger();
    this.icons = "vime";
    this.paused = true;
    this.playing = false;
    this.duration = -1;
    this.currentTime = 0;
    this.autoplay = false;
    this.ready = false;
    this.playbackReady = false;
    this.loop = false;
    this.muted = false;
    this.buffered = 0;
    this.playbackRate = 1;
    this.lastRateCheck = 1;
    this.playbackRates = [1];
    this.playbackQualities = [];
    this.seeking = false;
    this.debug = false;
    this.playbackStarted = false;
    this.playbackEnded = false;
    this.buffering = false;
    this.controls = false;
    this.isControlsActive = false;
    this.isSettingsActive = false;
    this.volume = 50;
    this.isFullscreenActive = false;
    this.aspectRatio = "16:9";
    this.isAudioView = false;
    this.isVideoView = false;
    this.isAudio = false;
    this.isVideo = false;
    this.isLive = false;
    this.isMobile = false;
    this.isTouch = false;
    this.isPiPActive = false;
    this.textTracks = [];
    this.currentTextTrack = -1;
    this.isTextTrackVisible = true;
    this.shouldRenderNativeTextTracks = true;
    this.audioTracks = [];
    this.currentAudioTrack = -1;
    this.autopause = true;
    this.playsinline = false;
    this.language = "en";
    this.translations = { en };
    this.languages = ["en"];
    this.i18n = en;
    withFindPlayer(this);
    withComponentRegistrar(this);
    withAutopause(this);
    withProviderHost(this);
    withPlayerEvents(this);
    this.safeAdapterCall = withPlayerScheduler(this);
  }
  get adapter() {
    var _a2;
    return (_a2 = this.provider) === null || _a2 === void 0 ? void 0 : _a2.getAdapter();
  }
  onContainerChange() {
    var _a2;
    (_a2 = this.fullscreenController) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    if (isUndefined(this.container))
      return;
    this.fullscreenController = new FullscreenController(this.container);
    this.fullscreenController.on("change", (isActive) => {
      this.isFullscreenActive = isActive;
      if (isActive)
        this.rotateDevice();
    });
    this.fullscreenController.on("error", (error) => {
      this.vmError.emit(error);
    });
  }
  onPausedChange() {
    if (this.paused) {
      this.playing = false;
    } else {
      autopause(this);
    }
    this.safeAdapterCall("paused", !this.paused ? "play" : "pause");
  }
  onDurationChange() {
    this.isLive = this.duration === Infinity;
  }
  onCurrentTimeChange() {
    const duration = this.playbackReady ? this.duration : Infinity;
    this.currentTime = Math.max(0, Math.min(this.currentTime, duration));
    this.safeAdapterCall("currentTime", "setCurrentTime");
  }
  onPlaybackReadyChange() {
    if (!this.ready)
      this.ready = true;
  }
  onMutedChange() {
    this.safeAdapterCall("muted", "setMuted");
  }
  onPlaybackRateChange(newRate, prevRate) {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      if (newRate === this.lastRateCheck)
        return;
      if (!(yield (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canSetPlaybackRate) === null || _b2 === void 0 ? void 0 : _b2.call(_a2))) {
        this.logger.log("provider cannot change `playbackRate`.");
        this.lastRateCheck = prevRate;
        this.playbackRate = prevRate;
        return;
      }
      if (!this.playbackRates.includes(newRate)) {
        this.logger.log(`invalid \`playbackRate\` of ${newRate}, valid values are [${this.playbackRates.join(", ")}]`);
        this.lastRateCheck = prevRate;
        this.playbackRate = prevRate;
        return;
      }
      this.lastRateCheck = newRate;
      this.safeAdapterCall("playbackRate", "setPlaybackRate");
    });
  }
  onPlaybackQualityChange(newQuality, prevQuality) {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      if (isUndefined(newQuality) || newQuality === this.lastQualityCheck)
        return;
      if (!(yield (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canSetPlaybackQuality) === null || _b2 === void 0 ? void 0 : _b2.call(_a2))) {
        this.logger.log("provider cannot change `playbackQuality`.");
        this.lastQualityCheck = prevQuality;
        this.playbackQuality = prevQuality;
        return;
      }
      if (!this.playbackQualities.includes(newQuality)) {
        this.logger.log(`invalid \`playbackQuality\` of ${newQuality}, valid values are [${this.playbackQualities.join(", ")}]`);
        this.lastQualityCheck = prevQuality;
        this.playbackQuality = prevQuality;
        return;
      }
      this.lastQualityCheck = newQuality;
      this.safeAdapterCall("playbackQuality", "setPlaybackQuality");
    });
  }
  onDebugChange() {
    this.logger.silent = !this.debug;
  }
  onVolumeChange() {
    return __awaiter$8(this, void 0, void 0, function* () {
      this.volume = Math.max(0, Math.min(this.volume, 100));
      this.safeAdapterCall("volume", "setVolume");
    });
  }
  onViewTypeChange() {
    this.isAudioView = this.viewType === ViewType.Audio;
    this.isVideoView = this.viewType === ViewType.Video;
  }
  onMediaTypeChange() {
    this.isAudio = this.mediaType === MediaType.Audio;
    this.isVideo = this.mediaType === MediaType.Video;
  }
  onLanguageChange(_, prevLanguage) {
    if (!this.languages.includes(this.language)) {
      this.logger.log(`invalid \`language\` of ${this.language}, valid values are [${this.languages.join(", ")}]`);
      this.language = prevLanguage;
      return;
    }
    this.i18n = this.translations[this.language];
  }
  onTranslationsChange() {
    Object.assign(this.translations, { en });
    this.languages = Object.keys(this.translations);
    this.i18n = this.translations[this.language];
  }
  onError(event) {
    this.logger.warn(event.detail);
  }
  getProvider() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.provider;
    });
  }
  getAdapter() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.adapter;
    });
  }
  play() {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.play();
    });
  }
  pause() {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.pause();
    });
  }
  canPlay(type) {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canPlay(type)) !== null && _b2 !== void 0 ? _b2 : false;
    });
  }
  canAutoplay() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return canAutoplay();
    });
  }
  canMutedAutoplay() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return canAutoplay(true);
    });
  }
  canSetPlaybackRate() {
    var _a2, _b2, _c;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_c = (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canSetPlaybackRate) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) !== null && _c !== void 0 ? _c : false;
    });
  }
  canSetPlaybackQuality() {
    var _a2, _b2, _c;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_c = (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canSetPlaybackQuality) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) !== null && _c !== void 0 ? _c : false;
    });
  }
  canSetFullscreen() {
    var _a2, _b2, _c;
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.fullscreenController.isSupported || ((_c = (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canSetFullscreen) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) !== null && _c !== void 0 ? _c : false);
    });
  }
  enterFullscreen(options) {
    var _a2, _b2, _c;
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.isVideoView) {
        throw Error("Cannot enter fullscreen on an audio player view.");
      }
      if (this.fullscreenController.isSupported) {
        return this.fullscreenController.requestFullscreen();
      }
      const adapter = yield this.adapter;
      const canProviderSetFullscreen = (_b2 = yield (_a2 = adapter === null || adapter === void 0 ? void 0 : adapter.canSetFullscreen) === null || _a2 === void 0 ? void 0 : _a2.call(adapter)) !== null && _b2 !== void 0 ? _b2 : false;
      if (canProviderSetFullscreen) {
        return (_c = adapter === null || adapter === void 0 ? void 0 : adapter.enterFullscreen) === null || _c === void 0 ? void 0 : _c.call(adapter, options);
      }
      throw Error("Fullscreen API is not available.");
    });
  }
  exitFullscreen() {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      if (this.fullscreenController.isSupported) {
        return this.fullscreenController.exitFullscreen();
      }
      return (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.exitFullscreen) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    });
  }
  canSetPiP() {
    var _a2, _b2, _c;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_c = (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.canSetPiP) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) !== null && _c !== void 0 ? _c : false;
    });
  }
  enterPiP() {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.isVideoView)
        throw Error("Cannot enter PiP mode on an audio player view.");
      if (!(yield this.canSetPiP()))
        throw Error("Picture-in-Picture API is not available.");
      return (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.enterPiP) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    });
  }
  exitPiP() {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.exitPiP) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    });
  }
  canSetAudioTrack() {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return !isUndefined((_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.setCurrentAudioTrack);
    });
  }
  setCurrentAudioTrack(trackId) {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.setCurrentAudioTrack) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, trackId);
    });
  }
  canSetTextTrack() {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return !isUndefined((_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.setCurrentTextTrack);
    });
  }
  setCurrentTextTrack(trackId) {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.setCurrentTextTrack) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, trackId);
    });
  }
  canSetTextTrackVisibility() {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      return !isUndefined((_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.setTextTrackVisibility);
    });
  }
  setTextTrackVisibility(isVisible) {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      (_b2 = (_a2 = yield this.adapter) === null || _a2 === void 0 ? void 0 : _a2.setTextTrackVisibility) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, isVisible);
    });
  }
  extendLanguage(language, translation) {
    var _a2;
    return __awaiter$8(this, void 0, void 0, function* () {
      const translations = Object.assign(Object.assign({}, this.translations), { [language]: Object.assign(Object.assign({}, (_a2 = this.translations[language]) !== null && _a2 !== void 0 ? _a2 : {}), translation) });
      this.translations = translations;
    });
  }
  connectedCallback() {
    this.onPausedChange();
    this.onCurrentTimeChange();
    this.onVolumeChange();
    this.onMutedChange();
    this.onDebugChange();
    this.onContainerChange();
    this.onTranslationsChange();
    this.onLanguageChange(this.language, initialState.language);
    this.disposal.add(onMobileChange((isMobile) => {
      this.isMobile = isMobile;
    }));
    this.disposal.add(onTouchInputChange((isTouch) => {
      this.isTouch = isTouch;
    }));
  }
  componentWillLoad() {
    Universe.create(this, this.getPlayerState());
  }
  disconnectedCallback() {
    var _a2;
    (_a2 = this.fullscreenController) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    this.disposal.empty();
  }
  rotateDevice() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.isMobile || !canRotateScreen())
        return;
      try {
        if (this.isFullscreenActive) {
          yield window.screen.orientation.lock("landscape");
        } else {
          yield window.screen.orientation.unlock();
        }
      } catch (err) {
        this.vmError.emit(err);
      }
    });
  }
  getPlayerState() {
    const state = {};
    const props = Object.keys(initialState);
    for (let i2 = 0; i2 < props.length; i2 += 1) {
      state[props[i2]] = this[props[i2]];
    }
    return state;
  }
  calcAspectRatio() {
    const [width, height] = /\d{1,2}:\d{1,2}/.test(this.aspectRatio) ? this.aspectRatio.split(":") : [16, 9];
    return 100 / Number(width) * Number(height);
  }
  getContainer() {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this.container;
    });
  }
  callAdapter(method, value) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return (yield this.adapter)[method](value);
    });
  }
  hasCustomControls() {
    return isComponentRegistered(this, "vm-controls");
  }
  genId() {
    var _a2;
    const id = (_a2 = this.host) === null || _a2 === void 0 ? void 0 : _a2.id;
    if (isString(id) && id.length > 0)
      return id;
    idCount$3 += 1;
    return `vm-player-${idCount$3}`;
  }
  render() {
    const label = `${this.isAudioView ? "Audio Player" : "Video Player"}${!isUndefined(this.mediaTitle) ? ` - ${this.mediaTitle}` : ""}`;
    const canShowCustomUI = !IS_IOS || !this.isVideoView || this.playsinline && !this.isFullscreenActive;
    if (!canShowCustomUI) {
      this.controls = true;
    }
    const isIdle = canShowCustomUI && this.hasCustomControls() && this.isVideoView && !this.paused && !this.isControlsActive;
    const isBlockerVisible = !this.controls && canShowCustomUI && this.isVideoView;
    return h(Host, { id: this.genId(), idle: isIdle, mobile: this.isMobile, touch: this.isTouch, live: this.isLive, audio: this.isAudioView, video: this.isVideoView, pip: this.isPiPActive, fullscreen: this.isFullscreenActive }, h("div", { "aria-label": label, "aria-hidden": !this.ready ? "true" : "false", "aria-busy": !this.playbackReady ? "true" : "false", class: {
      player: true,
      idle: isIdle,
      audio: this.isAudioView,
      video: this.isVideoView,
      fullscreen: this.isFullscreenActive
    }, style: {
      paddingBottom: this.isVideoView ? `${this.calcAspectRatio()}%` : void 0
    }, ref: (el) => {
      writeTask(() => {
        this.container = el;
      });
    } }, isBlockerVisible && h("div", { class: "blocker" }), h(Universe.Provider, { state: this.getPlayerState() }, h("slot", null))));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "container": ["onContainerChange"],
      "paused": ["onPausedChange"],
      "duration": ["onDurationChange"],
      "currentTime": ["onCurrentTimeChange"],
      "playbackReady": ["onPlaybackReadyChange"],
      "muted": ["onMutedChange"],
      "playbackRate": ["onPlaybackRateChange"],
      "playbackQuality": ["onPlaybackQualityChange"],
      "debug": ["onDebugChange"],
      "volume": ["onVolumeChange"],
      "viewType": ["onViewTypeChange"],
      "isAudioView": ["onViewTypeChange"],
      "isVideoView": ["onViewTypeChange"],
      "mediaType": ["onMediaTypeChange"],
      "language": ["onLanguageChange"],
      "translations": ["onTranslationsChange"]
    };
  }
  static get style() {
    return playerCss;
  }
};
var posterCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-poster-z-index)}.poster{width:100%;height:100%;background:#000;opacity:0;visibility:hidden;pointer-events:none;transition:var(--vm-fade-transition)}.poster.hidden{display:none}.poster.active{opacity:1;visibility:visible}img{width:100%;height:100%;pointer-events:none}";
var Poster = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmLoaded = createEvent(this, "vmLoaded", 3);
    this.vmWillShow = createEvent(this, "vmWillShow", 3);
    this.vmWillHide = createEvent(this, "vmWillHide", 3);
    this.isHidden = true;
    this.isActive = false;
    this.hasLoaded = false;
    this.fit = "cover";
    this.isVideoView = false;
    this.playbackStarted = false;
    this.currentTime = 0;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "mediaTitle",
      "currentPoster",
      "playbackStarted",
      "currentTime",
      "isVideoView"
    ]);
  }
  onCurrentPosterChange() {
    var _a2;
    this.hasLoaded = false;
    (_a2 = this.lazyLoader) === null || _a2 === void 0 ? void 0 : _a2.onMutation();
  }
  connectedCallback() {
    this.lazyLoader = new LazyLoader(this.host, ["data-src", "src"], (el) => {
      const src = el.getAttribute("data-src");
      el.removeAttribute("src");
      if (!isNull(src)) {
        el.setAttribute("src", src);
      }
    });
    this.onEnabledChange();
    this.onActiveChange();
  }
  disconnectedCallback() {
    this.lazyLoader.destroy();
  }
  onVisibilityChange() {
    !this.isHidden && this.isActive ? this.vmWillShow.emit() : this.vmWillHide.emit();
  }
  onEnabledChange() {
    this.isHidden = !this.isVideoView;
    this.onVisibilityChange();
  }
  onActiveChange() {
    this.isActive = !this.playbackStarted || this.currentTime <= 0.1;
    this.onVisibilityChange();
  }
  onPosterLoad() {
    this.vmLoaded.emit();
    this.hasLoaded = true;
  }
  render() {
    return h("div", { class: {
      poster: true,
      hidden: this.isHidden,
      active: this.isActive && this.hasLoaded
    } }, h("img", { class: "lazy", "data-src": this.currentPoster, alt: !isUndefined(this.mediaTitle) ? `${this.mediaTitle} Poster` : "Media Poster", style: { objectFit: this.fit }, onLoad: this.onPosterLoad.bind(this) }));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "currentPoster": ["onCurrentPosterChange"],
      "isVideoView": ["onEnabledChange"],
      "currentTime": ["onActiveChange"],
      "playbackStarted": ["onActiveChange"]
    };
  }
  static get style() {
    return posterCss;
  }
};
var scrimCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-scrim-z-index)}.scrim{position:absolute;width:100%;background:var(--vm-scrim-bg);display:inline-block;opacity:0;visibility:hidden;transition:var(--vm-fade-transition)}.scrim.gradient{height:258px;background:none;background-position:bottom;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAECCAYAAAA/9r2TAAABKklEQVQ4T2XI50cFABiF8dvee++67b33uM17b1MkkSSSSBJJJIkkkkQSSSKJ9Efmeb8cr86HH88JBP4thkfEkiKOFPGkSCCNRE8SKZJJkUIaqZ40UqSTIoMUmaSR5ckmRQ4pckkjz5NPigJSFJKiiDSKPSWkKCVFGWmUeypIUUmKKlJUk0aNJ0iKWlLUkUa9p4EUjaRoIkUzabR4WknRRop20ujwdJKiixTdpOghjV5PHyn6STFAGoOeIVIMk2KEFKOkMeYZJ8UEKUKkMemZIsU0KWZIMUsac54wKSKkiJLGvGeBFIukWCLFMrkCq7AG67ABm7AF27ADu7AH+3AAh3AEx3ACp3AG53ABl3AF13ADt3AH9/AAj/AEz/ACr/AG7/ABn/AF3/ADv39LujSyJPVJ0QAAAABJRU5ErkJggg==')}.scrim.gradientUp{top:unset;bottom:0}.scrim.gradientDown{transform:rotate(180deg)}.scrim.hidden{display:none}.scrim.active{opacity:1;visibility:visible}";
var Scrim = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.isVideoView = false;
    this.isControlsActive = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["isVideoView", "isControlsActive"]);
  }
  render() {
    return h("div", { class: {
      scrim: true,
      gradient: !isUndefined(this.gradient),
      gradientUp: this.gradient === "up",
      gradientDown: this.gradient === "down",
      hidden: !this.isVideoView,
      active: this.isControlsActive
    } });
  }
  static get style() {
    return scrimCss;
  }
};
var getHours = (value) => Math.trunc(value / 60 / 60 % 60);
var getMinutes = (value) => Math.trunc(value / 60 % 60);
var getSeconds = (value) => Math.trunc(value % 60);
var formatTime = (seconds = 0, alwaysShowHours = false) => {
  const format = (value) => `0${value}`.slice(-2);
  const hours = getHours(seconds);
  const mins = getMinutes(seconds);
  const secs = getSeconds(seconds);
  return `${alwaysShowHours || hours > 0 ? `${hours}:` : ""}${format(mins)}:${format(secs)}`;
};
var scrubberControlCss = ":host{--vm-tooltip-spacing:var(--vm-scrubber-tooltip-spacing);flex:1;position:relative;cursor:pointer;pointer-events:auto;box-sizing:border-box;left:calc(var(--vm-slider-thumb-width) / 2);margin-right:var(--vm-slider-thumb-width);margin-bottom:var(--vm-slider-track-height)}@keyframes progress{to{background-position:var(--vm-scrubber-loading-stripe-size) 0}}.scrubber{position:relative;width:100%}vm-slider,progress{margin-left:calc(calc(var(--vm-slider-thumb-width) / 2) * -1);margin-right:calc(calc(var(--vm-slider-thumb-width) / 2) * -1);width:calc(100% + var(--vm-slider-thumb-width));height:var(--vm-slider-track-height)}vm-slider:hover,progress:hover{cursor:pointer}vm-slider{position:absolute;top:0;left:0;z-index:3}progress{-webkit-appearance:none;background:transparent;border:0;border-radius:100px;position:absolute;left:0;top:50%;padding:0;color:var(--vm-scrubber-buffered-bg);height:var(--vm-slider-track-height)}progress::-webkit-progress-bar{background:transparent}progress::-webkit-progress-value{background:currentColor;border-radius:100px;min-width:var(--vm-slider-track-height);transition:width 0.2s ease}progress::-moz-progress-bar{background:currentColor;border-radius:100px;min-width:var(--vm-slider-track-height);transition:width 0.2s ease}progress::-ms-fill{border-radius:100px;transition:width 0.2s ease}progress.loading{animation:progress 1s linear infinite;background-image:linear-gradient(\n    -45deg,\n    var(--vm-scrubber-loading-stripe-color) 25%,\n    transparent 25%,\n    transparent 50%,\n    var(--vm-scrubber-loading-stripe-color) 50%,\n    var(--vm-scrubber-loading-stripe-color) 75%,\n    transparent 75%,\n    transparent\n  );background-repeat:repeat-x;background-size:var(--vm-scrubber-loading-stripe-size)\n    var(--vm-scrubber-loading-stripe-size);color:transparent;background-color:transparent}";
var __awaiter$7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ScrubberControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.keyboardDisposal = new Disposal();
    this.timestamp = "";
    this.endTime = 0;
    this.alwaysShowHours = false;
    this.hideTooltip = false;
    this.currentTime = 0;
    this.duration = -1;
    this.noKeyboard = false;
    this.buffering = false;
    this.buffered = 0;
    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, [
      "i18n",
      "currentTime",
      "duration",
      "buffering",
      "buffered"
    ]);
  }
  onNoKeyboardChange() {
    return __awaiter$7(this, void 0, void 0, function* () {
      this.keyboardDisposal.empty();
      if (this.noKeyboard)
        return;
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      const onKeyDown = (event) => {
        if (event.key !== "ArrowLeft" && event.key !== "ArrowRight")
          return;
        event.preventDefault();
        const isLeftArrow = event.key === "ArrowLeft";
        const seekTo = isLeftArrow ? Math.max(0, this.currentTime - 5) : Math.min(this.duration, this.currentTime + 5);
        this.dispatch("currentTime", seekTo);
      };
      this.keyboardDisposal.add(listen(player, "keydown", onKeyDown));
    });
  }
  onDurationChange() {
    this.endTime = Math.max(0, this.duration);
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
    this.timestamp = formatTime(this.currentTime, this.alwaysShowHours);
    this.onNoKeyboardChange();
  }
  disconnectedCallback() {
    this.keyboardDisposal.empty();
  }
  setTooltipPosition(value) {
    var _a2, _b2;
    const tooltipRect = (_b2 = (_a2 = this.tooltip.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".tooltip")) === null || _b2 === void 0 ? void 0 : _b2.getBoundingClientRect();
    const bounds = this.slider.getBoundingClientRect();
    const thumbWidth = parseFloat(window.getComputedStyle(this.slider).getPropertyValue("--vm-slider-thumb-width"));
    const leftLimit = tooltipRect.width / 2 - thumbWidth / 2;
    const rightLimit = bounds.width - tooltipRect.width / 2 - thumbWidth / 2;
    const xPos = Math.max(leftLimit, Math.min(value, rightLimit));
    this.tooltip.style = `--vm-tooltip-left: ${xPos}px`;
  }
  onSeek(event) {
    this.dispatch("currentTime", event.detail);
  }
  onSeeking(event) {
    if (this.duration < 0 || this.tooltip.hidden)
      return;
    if (event.type === "mouseleave") {
      this.getSliderInput().blur();
      this.tooltip.active = false;
      return;
    }
    const rect = this.host.getBoundingClientRect();
    const percent = Math.max(0, Math.min(100, 100 / rect.width * (event.pageX - rect.left)));
    this.timestamp = formatTime(this.duration / 100 * percent, this.alwaysShowHours);
    this.setTooltipPosition(percent / 100 * rect.width);
    if (!this.tooltip.active) {
      this.getSliderInput().focus();
      this.tooltip.active = true;
    }
  }
  getSliderInput() {
    var _a2;
    return (_a2 = this.slider.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector("input");
  }
  render() {
    const sliderValueText = this.i18n.scrubberLabel.replace(/{currentTime}/, formatTime(this.currentTime)).replace(/{duration}/, formatTime(this.endTime));
    return h("div", { class: "scrubber", onMouseEnter: this.onSeeking.bind(this), onMouseLeave: this.onSeeking.bind(this), onMouseMove: this.onSeeking.bind(this), onTouchMove: () => {
      this.getSliderInput().focus();
    }, onTouchEnd: () => {
      this.getSliderInput().blur();
    } }, h("vm-slider", { step: 0.01, max: this.endTime, value: this.currentTime, label: this.i18n.scrubber, valueText: sliderValueText, onVmValueChange: this.onSeek.bind(this), ref: (el) => {
      this.slider = el;
    } }), h("progress", {
      class: {
        loading: this.buffering
      },
      min: 0,
      max: this.endTime,
      value: this.buffered,
      "aria-label": this.i18n.buffered,
      "aria-valuemin": "0",
      "aria-valuemax": this.endTime,
      "aria-valuenow": this.buffered,
      "aria-valuetext": `${(this.endTime > 0 ? this.buffered / this.endTime : 0).toFixed(0)}%`
    }, "% buffered"), h("vm-tooltip", { hidden: this.hideTooltip, ref: (el) => {
      this.tooltip = el;
    } }, this.timestamp));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "noKeyboard": ["onNoKeyboardChange"],
      "duration": ["onDurationChange"]
    };
  }
  static get style() {
    return scrubberControlCss;
  }
};
var settingsCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-menu-z-index)}.settings{position:absolute;opacity:0;pointer-events:none;overflow-x:hidden;overflow-y:auto;background-color:var(--vm-menu-bg);max-height:var(--vm-settings-max-height);border-radius:var(--vm-settings-border-radius);padding:var(--vm-settings-padding);box-shadow:var(--vm-settings-shadow);box-sizing:border-box;scrollbar-width:thin;scroll-behavior:smooth;scrollbar-color:var(--vm-settings-scroll-thumb-color)\n    var(--vm-settings-scroll-track-color);transform:translateY(8px);transition:var(--vm-settings-transition)}.container{display:block;width:var(--vm-settings-width);height:100%;position:relative;transition:width 0.25s ease-in, height 0.25s ease-in}.settings.hydrated{visibility:hidden !important}.settings::-webkit-scrollbar{width:var(--vm-settings-scroll-width)}.settings::-webkit-scrollbar-track{background:var(--vm-settings-scroll-track-color)}.settings::-webkit-scrollbar-thumb{border-radius:var(--vm-settings-scroll-width);background-color:var(--vm-settings-scroll-thumb-color);border:2px solid var(--vm-menu-bg)}.settings.active{transform:translateY(0);opacity:1;pointer-events:auto;visibility:visible !important}.settings.mobile{position:fixed;top:auto !important;left:0 !important;right:0 !important;bottom:0 !important;width:100%;min-height:56px;max-height:50%;border-radius:0;z-index:2147483647;transform:translateY(100%)}.settings.mobile.active{transform:translateY(0)}.settings.mobile>vm-menu{height:100% !important;overflow:auto !important}";
var __awaiter$6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var idCount$2 = 0;
var Settings = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.disposal = new Disposal();
    this.menuHeight = 0;
    this.pin = "bottomRight";
    this.active = false;
    this.isMobile = false;
    this.isAudioView = false;
    withComponentRegistry(this);
    withControlsCollisionDetection(this);
    withPlayerContext(this, ["isMobile", "isAudioView"]);
  }
  onActiveChange() {
    this.dispatch("isSettingsActive", this.active);
    if (isUndefined(this.controller))
      return;
    this.controller.expanded = this.active;
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
    idCount$2 += 1;
    this.id = `vm-settings-${idCount$2}`;
  }
  disconnectedCallback() {
    this.disposal.empty();
  }
  setController(controller) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this.controller = controller;
      this.controller.menu = this.id;
      this.disposal.empty();
      this.disposal.add(listen(this.controller, "click", () => {
        this.active = !this.active;
      }));
      this.disposal.add(listen(this.controller, "keydown", (event) => {
        if (event.key !== "Enter")
          return;
        if (!this.active)
          this.menu.focusMenu();
      }));
    });
  }
  getPosition() {
    if (this.isAudioView) {
      return {
        right: "0",
        bottom: "calc(var(--vm-controls-height, 0) + 4px)"
      };
    }
    const pos = this.pin.split(/(?=[L|R])/).map((s) => s.toLowerCase());
    return {
      [pos.includes("top") ? "top" : "bottom"]: "var(--vm-controls-height, 0)",
      [pos.includes("left") ? "left" : "right"]: "8px"
    };
  }
  onOpen(event) {
    var _a2;
    if (((_a2 = event.detail) === null || _a2 === void 0 ? void 0 : _a2.identifier) !== this.id)
      return;
    this.active = true;
  }
  onClose(event) {
    var _a2;
    if (((_a2 = event.detail) === null || _a2 === void 0 ? void 0 : _a2.identifier) !== this.id)
      return;
    this.active = false;
  }
  onHeightChange(event) {
    this.menuHeight = event.detail;
  }
  render() {
    return h("div", { style: Object.assign({}, this.getPosition()), class: {
      settings: true,
      active: this.active,
      mobile: this.isMobile
    } }, h("div", { class: "container", style: { height: `${this.menuHeight}px` } }, h("vm-menu", { identifier: this.id, active: this.active, controller: this.controller, onVmOpen: this.onOpen.bind(this), onVmClose: this.onClose.bind(this), onVmMenuHeightChange: this.onHeightChange.bind(this), ref: (el) => {
      this.menu = el;
    } }, h("slot", null))));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "active": ["onActiveChange"]
    };
  }
  static get style() {
    return settingsCss;
  }
};
var settingsControlCss = ".settingsControl.hidden{display:none}.settingsControl{--vm-icon-transition:transform 0.3s ease}.settingsControl.active{--vm-icon-transform:rotate(90deg)}";
var __awaiter$5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var idCount$1 = 0;
var SettingsControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.icon = "settings";
    this.tooltipPosition = "top";
    this.expanded = false;
    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ["i18n"]);
  }
  onComponentsChange() {
    if (!isUndefined(this.vmSettings)) {
      this.vmSettings.setController(this.host);
    }
  }
  connectedCallback() {
    idCount$1 += 1;
    this.id = `vm-settings-control-${idCount$1}`;
    watchComponentRegistry(this, "vm-settings", (regs) => {
      [this.vmSettings] = regs;
    });
  }
  focusControl() {
    var _a2;
    return __awaiter$5(this, void 0, void 0, function* () {
      (_a2 = this.control) === null || _a2 === void 0 ? void 0 : _a2.focusControl();
    });
  }
  blurControl() {
    var _a2;
    return __awaiter$5(this, void 0, void 0, function* () {
      (_a2 = this.control) === null || _a2 === void 0 ? void 0 : _a2.blurControl();
    });
  }
  render() {
    const hasSettings = !isUndefined(this.menu);
    return h("div", { class: {
      settingsControl: true,
      hidden: !hasSettings,
      active: hasSettings && this.expanded
    } }, h("vm-control", { identifier: this.id, menu: this.menu, hidden: !hasSettings, expanded: this.expanded, label: this.i18n.settings, ref: (control) => {
      this.control = control;
    } }, h("vm-icon", { name: this.icon, library: this.icons }), h("vm-tooltip", { hidden: this.expanded, position: this.tooltipPosition, direction: this.tooltipDirection }, this.i18n.settings)));
  }
  get host() {
    return this;
  }
  static get watchers() {
    return {
      "vmSettings": ["onComponentsChange"]
    };
  }
  static get style() {
    return settingsControlCss;
  }
};
var skeletonCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-skeleton-z-index)}@keyframes sheen{0%{background-position:200% 0}to{background-position:-200% 0}}.skeleton{width:100%;height:100%;display:flex;min-height:1rem;pointer-events:auto}.sheen.hidden{opacity:0;visibility:hidden;transition:var(--vm-fade-transition);pointer-events:none}.indicator{flex:1 1 auto;background:var(--vm-skeleton-color)}.skeleton.sheen .indicator{background:linear-gradient(\n    270deg,\n    var(--vm-skeleton-sheen-color),\n    var(--vm-skeleton-color),\n    var(--vm-skeleton-color),\n    var(--vm-skeleton-sheen-color)\n  );background-size:400% 100%;background-size:400% 100%;animation:sheen 8s ease-in-out infinite}";
var Skeleton = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.hidden = false;
    this.effect = "sheen";
    this.ready = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["ready"]);
  }
  onReadyChange() {
    if (!this.ready) {
      this.hidden = false;
    } else {
      setTimeout(() => {
        this.hidden = true;
      }, 500);
    }
  }
  render() {
    return h("div", { class: {
      skeleton: true,
      hidden: this.hidden,
      sheen: this.effect === "sheen"
    } }, h("div", { class: "indicator" }));
  }
  static get watchers() {
    return {
      "ready": ["onReadyChange"]
    };
  }
  static get style() {
    return skeletonCss;
  }
};
var sliderCss = ":host{width:100%}.slider{width:100%}input{width:100%;-webkit-appearance:none;background:transparent;border:0;outline:0;cursor:pointer;box-sizing:border-box;border-radius:calc(var(--vm-slider-thumb-height) * 2);user-select:none;-webkit-user-select:none;touch-action:manipulation;color:var(--vm-slider-value-color);display:block;height:var(--vm-slider-track-height);margin:0;padding:0;transition:box-shadow 0.3s ease}input::-webkit-slider-runnable-track{background:transparent;border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;background-image:linear-gradient(\n    to right,\n    currentColor var(--vm-value, 0%),\n    transparent var(--vm-value, 0%)\n  );background-color:var(--vm-slider-track-color)}input::-webkit-slider-thumb{opacity:0;background:var(--vm-slider-thumb-bg);border:0;border-radius:100%;position:relative;transition:all 0.2s ease;width:var(--vm-slider-thumb-width);height:var(--vm-slider-thumb-height);box-shadow:var(--vm-slider-thumb-shadow);-webkit-appearance:none;margin-top:calc(\n    0px -\n      calc(\n        calc(var(--vm-slider-thumb-height) - var(--vm-slider-track-height)) / 2\n      )\n  )}input::-moz-range-track{background:transparent;border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;background-color:var(--vm-slider-track-color)}input::-moz-range-thumb{opacity:0;background:var(--vm-slider-thumb-bg);border:0;border-radius:100%;position:relative;transition:all 0.2s ease;width:var(--vm-slider-thumb-width);height:var(--vm-slider-thumb-height);box-shadow:var(--vm-slider-thumb-shadow)}input::-moz-range-progress{background:currentColor;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height)}input::-ms-track{border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;color:transparent;background-color:var(--vm-slider-track-color)}input::-ms-fill-upper{background:transparent;border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none}input::-ms-fill-lower{border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;background:currentColor}input::-ms-thumb{opacity:0;background:var(--vm-slider-thumb-bg);border:0;border-radius:100%;position:relative;transition:all 0.2s ease;width:var(--vm-slider-thumb-width);height:var(--vm-slider-thumb-height);box-shadow:var(--vm-slider-thumb-shadow);margin-top:0}input::-ms-tooltip{display:none}input:hover::-webkit-slider-runnable-track{height:var(--vm-slider-track-focused-height)}input:hover::-moz-range-track{height:var(--vm-slider-track-focused-height)}input:hover::-ms-track{height:var(--vm-slider-track-focused-height)}input:hover::-ms-fill-upper{height:var(--vm-slider-track-focused-height)}input:hover::-ms-fill-lower{height:var(--vm-slider-track-focused-height)}input:hover::-webkit-slider-thumb{opacity:1}input:hover::-moz-range-thumb{opacity:1}input:hover::-ms-thumb{opacity:1}input:focus{outline:0}input:focus::-webkit-slider-runnable-track{outline:0;height:var(--vm-slider-track-focused-height)}input:focus::-moz-range-track{outline:0;height:var(--vm-slider-track-focused-height)}input:focus::-ms-track{outline:0;height:var(--vm-slider-track-focused-height)}input::-moz-focus-outer{border:0}";
var Slider = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmValueChange = createEvent(this, "vmValueChange", 7);
    this.vmFocus = createEvent(this, "vmFocus", 7);
    this.vmBlur = createEvent(this, "vmBlur", 7);
    this.step = 1;
    this.min = 0;
    this.max = 10;
    this.value = 5;
    withComponentRegistry(this);
  }
  getPercentage() {
    return `${this.value / this.max * 100}%`;
  }
  onValueChange(event) {
    var _a2;
    const value = parseFloat((_a2 = event.target) === null || _a2 === void 0 ? void 0 : _a2.value);
    this.vmValueChange.emit(value);
  }
  calcTouchedValue(event) {
    const input = event.target;
    const touch = event.changedTouches[0];
    const min = parseFloat(input.getAttribute("min"));
    const max = parseFloat(input.getAttribute("max"));
    const step = parseFloat(input.getAttribute("step"));
    const delta = max - min;
    let percent;
    const clientRect = input.getBoundingClientRect();
    const sliderThumbWidth = parseFloat(window.getComputedStyle(this.host).getPropertyValue("--vm-slider-thumb-width"));
    const thumbWidth = 100 / clientRect.width * (sliderThumbWidth / 2) / 100;
    percent = 100 / clientRect.width * (touch.clientX - clientRect.left);
    percent = Math.max(0, Math.min(percent, 100));
    if (percent < 50) {
      percent -= (100 - percent * 2) * thumbWidth;
    } else if (percent > 50) {
      percent += (percent - 50) * 2 * thumbWidth;
    }
    const position = delta * (percent / 100);
    if (step >= 1) {
      return min + Math.round(position / step) * step;
    }
    return min + parseFloat(position.toFixed(2));
  }
  onTouch(event) {
    const input = event.target;
    if (input.disabled)
      return;
    event.preventDefault();
    this.value = this.calcTouchedValue(event);
    this.vmValueChange.emit(this.value);
    input.dispatchEvent(new window.Event(event.type === "touchend" ? "change" : "input", {
      bubbles: true
    }));
  }
  render() {
    var _a2;
    return h("div", { class: "slider", style: {
      "--vm-value": this.getPercentage()
    } }, h("input", { type: "range", step: this.step, min: this.min, max: this.max, value: this.value, autocomplete: "off", "aria-label": this.label, "aria-valuemin": this.min, "aria-valuemax": this.max, "aria-valuenow": this.value, "aria-valuetext": (_a2 = this.valueText) !== null && _a2 !== void 0 ? _a2 : this.getPercentage(), "aria-orientation": "horizontal", onInput: this.onValueChange.bind(this), onFocus: () => {
      this.vmFocus.emit();
    }, onBlur: () => {
      this.vmBlur.emit();
    }, onTouchStart: this.onTouch.bind(this), onTouchMove: this.onTouch.bind(this), onTouchEnd: this.onTouch.bind(this) }));
  }
  get host() {
    return this;
  }
  static get style() {
    return sliderCss;
  }
};
var spinnerCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-spinner-z-index)}.spinner{width:100%;height:100%;display:flex;justify-content:center;align-items:center;opacity:0;visibility:hidden;pointer-events:none;transition:var(--vm-fade-transition)}.spinner.hidden{display:none}.spinner.active{opacity:1;visibility:visible}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.spin{background:transparent;margin:60px auto;font-size:10px;position:relative;text-indent:-9999em;pointer-events:none;border-top:var(--vm-spinner-thickness) solid var(--vm-spinner-fill-color);border-left:var(--vm-spinner-thickness) solid var(--vm-spinner-fill-color);border-right:var(--vm-spinner-thickness) solid var(--vm-spinner-track-color);border-bottom:var(--vm-spinner-thickness) solid var(--vm-spinner-track-color);transform:translateZ(0)}.spin.active{animation:spin var(--vm-spinner-spin-duration) infinite\n    var(--vm-spinner-spin-timing-func)}.spin,.spin::after{border-radius:50%;width:var(--vm-spinner-width);height:var(--vm-spinner-height)}";
var Spinner = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmWillShow = createEvent(this, "vmWillShow", 3);
    this.vmWillHide = createEvent(this, "vmWillHide", 3);
    this.blacklist = [Provider.YouTube];
    this.isHidden = true;
    this.isActive = false;
    this.isVideoView = false;
    this.showWhenMediaLoading = false;
    this.playbackReady = false;
    this.buffering = false;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "isVideoView",
      "buffering",
      "playbackReady",
      "currentProvider"
    ]);
  }
  onVideoViewChange() {
    this.isHidden = !this.isVideoView;
    this.onVisiblityChange();
  }
  onActiveChange() {
    this.isActive = this.buffering || this.showWhenMediaLoading && !this.playbackReady;
    this.onVisiblityChange();
  }
  onVisiblityChange() {
    !this.isHidden && this.isActive ? this.vmWillShow.emit() : this.vmWillHide.emit();
  }
  render() {
    return h("div", { class: {
      spinner: true,
      hidden: this.isHidden || this.blacklist.includes(this.currentProvider),
      active: this.isActive
    } }, h("div", { class: {
      spin: true,
      active: this.isActive
    } }, "Loading..."));
  }
  static get watchers() {
    return {
      "isVideoView": ["onVideoViewChange"],
      "buffering": ["onActiveChange"],
      "playbackReady": ["onActiveChange"]
    };
  }
  static get style() {
    return spinnerCss;
  }
};
var __awaiter$4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var idCount = 0;
var Submenu = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmOpenSubmenu = createEvent(this, "vmOpenSubmenu", 7);
    this.vmCloseSubmenu = createEvent(this, "vmCloseSubmenu", 7);
    this.slideInDirection = "right";
    this.active = false;
    withComponentRegistry(this);
  }
  connectedCallback() {
    this.genId();
  }
  getController() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.controller;
    });
  }
  getMenu() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.menu;
    });
  }
  getControllerHeight() {
    var _a2, _b2;
    return __awaiter$4(this, void 0, void 0, function* () {
      return (_b2 = (_a2 = this.controller) === null || _a2 === void 0 ? void 0 : _a2.getHeight()) !== null && _b2 !== void 0 ? _b2 : 0;
    });
  }
  getControllerHeightSync() {
    var _a2;
    const el = (_a2 = this.controller) === null || _a2 === void 0 ? void 0 : _a2.shadowRoot.querySelector("[role='menuitem']");
    return el ? parseFloat(window.getComputedStyle(el).height) : 0;
  }
  onMenuOpen() {
    this.active = true;
    this.vmOpenSubmenu.emit(this.host);
  }
  onMenuClose() {
    this.active = false;
    this.vmCloseSubmenu.emit(this.host);
  }
  genId() {
    idCount += 1;
    this.id = `vm-submenu-${idCount}`;
  }
  getControllerId() {
    return `${this.id}-controller`;
  }
  render() {
    return h("div", null, h("vm-menu-item", { identifier: this.getControllerId(), menu: this.menu, label: this.label, hint: this.hint, expanded: this.active, ref: (el) => {
      writeTask(() => {
        this.controller = el;
      });
    } }), h("vm-menu", { identifier: this.id, controller: this.controller, active: this.active, slideInDirection: this.slideInDirection, onVmOpen: this.onMenuOpen.bind(this), onVmClose: this.onMenuClose.bind(this), ref: (el) => {
      writeTask(() => {
        this.menu = el;
      });
    }, style: { top: `${this.getControllerHeightSync() + 1}px` } }, h("slot", null)));
  }
  get host() {
    return this;
  }
};
var timeCss = ".time{display:flex;align-items:center;color:var(--vm-time-color);font-size:var(--vm-time-font-size);font-weight:var(--vm-time-font-weight)}";
var Time = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.seconds = 0;
    this.alwaysShowHours = false;
    withComponentRegistry(this);
  }
  render() {
    return h("div", { class: "time", "aria-label": this.label }, formatTime(Math.max(0, this.seconds), this.alwaysShowHours));
  }
  static get style() {
    return timeCss;
  }
};
var timeProgressCss = ".timeProgress{display:flex;width:100%;height:100%;align-items:center;color:var(--vm-time-color)}.separator{margin:0 4px}";
var TimeProgress = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.separator = "/";
    this.alwaysShowHours = false;
    withComponentRegistry(this);
  }
  render() {
    return h("div", { class: "timeProgress" }, h("vm-current-time", { alwaysShowHours: this.alwaysShowHours }), h("span", { class: "separator" }, this.separator), h("vm-end-time", { alwaysShowHours: this.alwaysShowHours }));
  }
  static get style() {
    return timeProgressCss;
  }
};
var tooltipCss = ":host{display:contents;z-index:var(--vm-tooltip-z-index)}.tooltip{left:var(--vm-tooltip-left, 50%);transform:translateX(-50%);line-height:1.3;pointer-events:none;position:absolute;opacity:0;white-space:nowrap;visibility:hidden;background:var(--vm-tooltip-bg);border-radius:var(--vm-tooltip-border-radius);box-sizing:border-box;box-shadow:var(--vm-tooltip-box-shadow);color:var(--vm-tooltip-color);font-size:var(--vm-tooltip-font-size);padding:var(--vm-tooltip-padding);transition:opacity var(--vm-tooltip-fade-duration)\n    var(--vm-tooltip-fade-timing-func)}.tooltip[aria-hidden='false']{opacity:1;visibility:visible}.tooltip.hidden{display:none}.tooltip.onTop{bottom:100%;margin-bottom:var(--vm-tooltip-spacing)}.tooltip.onBottom{top:100%;margin-top:var(--vm-tooltip-spacing)}.tooltip.growLeft{left:auto;right:0;transform:none}.tooltip.growRight{left:0;transform:none}";
var tooltipIdCount = 0;
var Tooltip = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.hasLoaded = false;
    this.hidden = false;
    this.active = false;
    this.position = "top";
    this.isTouch = false;
    this.isMobile = false;
    withComponentRegistry(this);
    withPlayerContext(this, ["isTouch", "isMobile"]);
  }
  componentDidLoad() {
    this.hasLoaded = true;
  }
  getId() {
    const id = this.host.id;
    if (isString(id) && id.length > 0)
      return id;
    tooltipIdCount += 1;
    return `vm-tooltip-${tooltipIdCount}`;
  }
  render() {
    return h("div", { id: this.getId(), role: "tooltip", "aria-hidden": !this.active || this.isTouch || this.isMobile ? "true" : "false", class: {
      tooltip: true,
      hidden: !this.hasLoaded || this.hidden,
      onTop: this.position === "top",
      onBottom: this.position === "bottom",
      growLeft: this.direction === "left",
      growRight: this.direction === "right"
    } }, h("slot", null));
  }
  get host() {
    return this;
  }
  static get style() {
    return tooltipCss;
  }
};
var uiCss = ":host{z-index:var(--vm-ui-z-index)}.ui{width:100%;pointer-events:none}.ui.hidden{display:none}.ui.video{position:absolute;top:0;left:0;height:100%}";
var UI = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.isVideoView = false;
    this.playsinline = false;
    this.isFullscreenActive = false;
    withComponentRegistry(this);
    withPlayerContext(this, [
      "isVideoView",
      "playsinline",
      "isFullscreenActive"
    ]);
  }
  render() {
    const canShowCustomUI = !IS_IOS || !this.isVideoView || this.playsinline && !this.isFullscreenActive;
    return h("div", { class: {
      ui: true,
      hidden: !canShowCustomUI,
      video: this.isVideoView
    } }, canShowCustomUI && h("slot", null));
  }
  static get style() {
    return uiCss;
  }
};
var __awaiter$3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Video = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.willAttach = false;
    this.hasCustomTextManager = false;
    this.preload = "metadata";
    withComponentRegistry(this);
    withProviderConnect(this);
  }
  onProviderConnect(event) {
    if (this.willAttach)
      event.stopImmediatePropagation();
  }
  onProviderDisconnect(event) {
    if (this.willAttach)
      event.stopImmediatePropagation();
  }
  getAdapter() {
    var _a2;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (_a2 = this.fileProvider) === null || _a2 === void 0 ? void 0 : _a2.getAdapter();
    });
  }
  render() {
    return h("vm-file", { noConnect: true, willAttach: this.willAttach, crossOrigin: this.crossOrigin, poster: this.poster, preload: this.preload, controlsList: this.controlsList, autoPiP: this.autoPiP, disablePiP: this.disablePiP, disableRemotePlayback: this.disableRemotePlayback, hasCustomTextManager: this.hasCustomTextManager, mediaTitle: this.mediaTitle, viewType: ViewType.Video, ref: (el) => {
      this.fileProvider = el;
    } }, h("slot", null));
  }
};
var VimeoEvent;
(function(VimeoEvent2) {
  VimeoEvent2["Play"] = "play";
  VimeoEvent2["Pause"] = "pause";
  VimeoEvent2["Seeking"] = "seeking";
  VimeoEvent2["Seeked"] = "seeked";
  VimeoEvent2["TimeUpdate"] = "timeupdate";
  VimeoEvent2["VolumeChange"] = "volumechange";
  VimeoEvent2["DurationChange"] = "durationchange";
  VimeoEvent2["FullscreenChange"] = "fullscreenchange";
  VimeoEvent2["CueChange"] = "cuechange";
  VimeoEvent2["Progress"] = "progress";
  VimeoEvent2["Error"] = "error";
  VimeoEvent2["PlaybackRateChange"] = "playbackratechange";
  VimeoEvent2["Loaded"] = "loaded";
  VimeoEvent2["BufferStart"] = "bufferstart";
  VimeoEvent2["BufferEnd"] = "bufferend";
  VimeoEvent2["TextTrackChange"] = "texttrackchange";
  VimeoEvent2["Waiting"] = "waiting";
  VimeoEvent2["Ended"] = "ended";
})(VimeoEvent || (VimeoEvent = {}));
var vimeoCss = ":host{z-index:var(--vm-media-z-index)}vm-embed{position:absolute;top:0;left:0;width:100%;height:100%}vm-embed.hideControls{display:block;width:100%;height:auto;position:relative}";
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var videoInfoCache = /* @__PURE__ */ new Map();
var Vimeo = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.defaultInternalState = {};
    this.volume = 50;
    this.hasLoaded = false;
    this.internalState = {
      paused: true,
      playing: false,
      seeking: false,
      currentTime: 0,
      buffered: 0,
      playbackStarted: false,
      playRequest: false
    };
    this.embedSrc = "";
    this.mediaTitle = "";
    this.byline = true;
    this.portrait = true;
    this.noAutoAspectRatio = false;
    this.cookies = true;
    this.language = "en";
    this.aspectRatio = "16:9";
    this.autoplay = false;
    this.controls = false;
    this.loop = false;
    this.muted = false;
    this.playsinline = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this);
  }
  onVideoIdChange() {
    this.cancelTimeUpdates();
    if (!this.videoId) {
      this.embedSrc = "";
      return;
    }
    this.embedSrc = `${this.getOrigin()}/video/${this.videoId}`;
    this.pendingDurationCall = deferredPromise();
    this.pendingMediaTitleCall = deferredPromise();
    this.fetchVideoInfo = this.getVideoInfo();
  }
  onCustomPosterChange() {
    this.dispatch("currentPoster", this.poster);
  }
  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    this.dispatch("viewType", ViewType.Video);
    this.onVideoIdChange();
    this.defaultInternalState = Object.assign({}, this.internalState);
  }
  componentDidLoad() {
    this.initialMuted = this.muted;
  }
  disconnectedCallback() {
    this.cancelTimeUpdates();
    this.pendingPlayRequest = void 0;
  }
  getOrigin() {
    return "https://player.vimeo.com";
  }
  getPreconnections() {
    return [
      this.getOrigin(),
      "https://i.vimeocdn.com",
      "https://f.vimeocdn.com",
      "https://fresnel.vimeocdn.com"
    ];
  }
  remoteControl(command, arg) {
    return this.embed.postMessage({
      method: command,
      value: arg
    });
  }
  buildParams() {
    return {
      byline: this.byline,
      color: this.color,
      portrait: this.portrait,
      autopause: false,
      transparent: false,
      autoplay: this.autoplay,
      muted: this.initialMuted,
      playsinline: this.playsinline,
      dnt: !this.cookies
    };
  }
  getVideoInfo() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (videoInfoCache.has(this.videoId))
        return videoInfoCache.get(this.videoId);
      return window.fetch(`https://vimeo.com/api/oembed.json?url=${this.embedSrc}`).then((response) => response.json()).then((data) => {
        var _a2;
        const thumnailRegex = /vimeocdn.com\/video\/(.*)?_/;
        const thumbnailId = (_a2 = data === null || data === void 0 ? void 0 : data.thumbnail_url) === null || _a2 === void 0 ? void 0 : _a2.match(thumnailRegex)[1];
        const poster = `https://i.vimeocdn.com/video/${thumbnailId}_1920x1080.jpg`;
        const info = { poster, width: data === null || data === void 0 ? void 0 : data.width, height: data === null || data === void 0 ? void 0 : data.height };
        videoInfoCache.set(this.videoId, info);
        return info;
      });
    });
  }
  onTimeChange(time) {
    if (this.internalState.currentTime === time)
      return;
    this.dispatch("currentTime", time);
    if (Math.abs(this.internalState.currentTime - time) > 1.5) {
      this.internalState.seeking = true;
      this.dispatch("seeking", true);
      if (this.internalState.playing && this.internalState.buffered < time) {
        this.dispatch("buffering", true);
      }
      window.clearTimeout(this.pendingPlayRequest);
      if (!this.internalState.paused) {
        this.internalState.playRequest = true;
      }
      this.remoteControl(this.internalState.playbackStarted ? "pause" : "play");
    }
    this.internalState.currentTime = time;
  }
  cancelTimeUpdates() {
    if (isNumber(this.timeRAF))
      window.cancelAnimationFrame(this.timeRAF);
  }
  requestTimeUpdates() {
    this.remoteControl("getCurrentTime");
    this.timeRAF = window.requestAnimationFrame(() => {
      this.requestTimeUpdates();
    });
  }
  onSeeked() {
    if (!this.internalState.seeking)
      return;
    this.dispatch("seeking", false);
    this.internalState.seeking = false;
    if (this.internalState.playRequest) {
      window.setTimeout(() => {
        this.remoteControl("play");
      }, 150);
    }
  }
  onVimeoMethod(method, arg) {
    var _a2, _b2;
    switch (method) {
      case "getCurrentTime":
        if (!this.internalState.seeking)
          this.onTimeChange(arg);
        break;
      case "getDuration":
        (_a2 = this.pendingDurationCall) === null || _a2 === void 0 ? void 0 : _a2.resolve(arg);
        break;
      case "getVideoTitle":
        (_b2 = this.pendingMediaTitleCall) === null || _b2 === void 0 ? void 0 : _b2.resolve(arg);
        break;
    }
  }
  onLoaded() {
    var _a2, _b2;
    if (this.hasLoaded)
      return;
    this.pendingPlayRequest = void 0;
    this.internalState = Object.assign({}, this.defaultInternalState);
    this.dispatch("currentSrc", this.embedSrc);
    this.dispatch("mediaType", MediaType.Video);
    this.remoteControl("getDuration");
    this.remoteControl("getVideoTitle");
    Promise.all([
      this.fetchVideoInfo,
      (_a2 = this.pendingDurationCall) === null || _a2 === void 0 ? void 0 : _a2.promise,
      (_b2 = this.pendingMediaTitleCall) === null || _b2 === void 0 ? void 0 : _b2.promise
    ]).then(([info, duration, mediaTitle]) => {
      var _a3, _b3, _c;
      this.requestTimeUpdates();
      this.dispatch("aspectRatio", `${(_a3 = info === null || info === void 0 ? void 0 : info.width) !== null && _a3 !== void 0 ? _a3 : 16}:${(_b3 = info === null || info === void 0 ? void 0 : info.height) !== null && _b3 !== void 0 ? _b3 : 9}`);
      this.dispatch("currentPoster", (_c = this.poster) !== null && _c !== void 0 ? _c : info === null || info === void 0 ? void 0 : info.poster);
      this.dispatch("duration", duration !== null && duration !== void 0 ? duration : -1);
      this.dispatch("mediaTitle", mediaTitle);
      this.dispatch("playbackReady", true);
    });
    this.hasLoaded = true;
  }
  onVimeoEvent(event, payload) {
    switch (event) {
      case "ready":
        Object.values(VimeoEvent).forEach((e) => {
          this.remoteControl("addEventListener", e);
        });
        break;
      case "loaded":
        this.onLoaded();
        break;
      case "play":
        this.onLoaded();
        this.internalState.paused = false;
        this.dispatch("paused", false);
        break;
      case "playProgress":
        if (!this.internalState.playing) {
          this.dispatch("playing", true);
          this.internalState.playing = true;
          this.internalState.playbackStarted = true;
          this.pendingPlayRequest = window.setTimeout(() => {
            this.internalState.playRequest = false;
            this.pendingPlayRequest = void 0;
          }, 1e3);
        }
        this.dispatch("buffering", false);
        this.onSeeked();
        break;
      case "pause":
        this.internalState.paused = true;
        this.internalState.playing = false;
        this.dispatch("paused", true);
        this.dispatch("buffering", false);
        break;
      case "loadProgress":
        this.internalState.buffered = payload.seconds;
        this.dispatch("buffered", payload.seconds);
        break;
      case "bufferstart":
        this.dispatch("buffering", true);
        if (this.internalState.paused) {
          this.internalState.paused = false;
          this.dispatch("paused", false);
          this.dispatch("playbackStarted", true);
        }
        break;
      case "bufferend":
        this.dispatch("buffering", false);
        if (this.internalState.paused)
          this.onSeeked();
        break;
      case "volumechange":
        if (payload.volume > 0) {
          const newVolume = Math.floor(payload.volume * 100);
          this.dispatch("muted", false);
          if (this.volume !== newVolume) {
            this.volume = newVolume;
            this.dispatch("volume", this.volume);
          }
        } else {
          this.dispatch("muted", true);
        }
        break;
      case "durationchange":
        this.dispatch("duration", payload.duration);
        break;
      case "playbackratechange":
        this.dispatch("playbackRate", payload.playbackRate);
        break;
      case "fullscreenchange":
        this.dispatch("isFullscreenActive", payload.fullscreen);
        break;
      case "finish":
        if (this.loop) {
          this.remoteControl("setCurrentTime", 0);
          setTimeout(() => {
            this.remoteControl("play");
          }, 200);
        } else {
          this.dispatch("playbackEnded", true);
        }
        break;
      case "error":
        this.vmError.emit(payload);
        break;
    }
  }
  onEmbedSrcChange() {
    this.hasLoaded = false;
    this.vmLoadStart.emit();
    this.dispatch("viewType", ViewType.Video);
  }
  onEmbedMessage(event) {
    const message = event.detail;
    if (!isUndefined(message.event))
      this.onVimeoEvent(message.event, message.data);
    if (!isUndefined(message.method))
      this.onVimeoMethod(message.method, message.value);
  }
  adjustPosition() {
    if (this.controls) {
      return {};
    }
    const [aw, ah] = this.aspectRatio.split(":").map((r) => parseInt(r, 10));
    const height = 240;
    const padding = 100 / aw * ah;
    const offset = (height - padding) / (height / 50);
    return {
      paddingBottom: `${height}%`,
      transform: `translateY(-${offset + 0.02}%)`
    };
  }
  getAdapter() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const canPlayRegex = /vimeo(?:\.com|)\/([0-9]{9,})/;
      const fileRegex = /vimeo\.com\/external\/[0-9]+\..+/;
      return {
        getInternalPlayer: () => __awaiter$2(this, void 0, void 0, function* () {
          return this.embed;
        }),
        play: () => __awaiter$2(this, void 0, void 0, function* () {
          this.remoteControl("play");
        }),
        pause: () => __awaiter$2(this, void 0, void 0, function* () {
          this.remoteControl("pause");
        }),
        canPlay: (type) => __awaiter$2(this, void 0, void 0, function* () {
          return isString(type) && !fileRegex.test(type) && canPlayRegex.test(type);
        }),
        setCurrentTime: (time) => __awaiter$2(this, void 0, void 0, function* () {
          if (time !== this.internalState.currentTime) {
            this.remoteControl("setCurrentTime", time);
          }
        }),
        setMuted: (muted) => __awaiter$2(this, void 0, void 0, function* () {
          if (!muted)
            this.volume = this.volume > 0 ? this.volume : 30;
          this.remoteControl("setVolume", muted ? 0 : this.volume / 100);
        }),
        setVolume: (volume) => __awaiter$2(this, void 0, void 0, function* () {
          if (!this.muted) {
            this.remoteControl("setVolume", volume / 100);
          } else {
            this.dispatch("volume", volume);
          }
        }),
        canSetPlaybackRate: () => __awaiter$2(this, void 0, void 0, function* () {
          return false;
        }),
        setPlaybackRate: (rate) => __awaiter$2(this, void 0, void 0, function* () {
          this.remoteControl("setPlaybackRate", rate);
        })
      };
    });
  }
  render() {
    return h("vm-embed", { class: { hideControls: !this.controls }, style: this.adjustPosition(), embedSrc: this.embedSrc, mediaTitle: this.mediaTitle, origin: this.getOrigin(), params: this.buildParams(), decoder: decodeJSON, preconnections: this.getPreconnections(), onVmEmbedMessage: this.onEmbedMessage.bind(this), onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this), ref: (el) => {
      this.embed = el;
    } });
  }
  static get watchers() {
    return {
      "videoId": ["onVideoIdChange"],
      "poster": ["onCustomPosterChange"]
    };
  }
  static get style() {
    return vimeoCss;
  }
};
var volumeControlCss = ".volumeControl{align-items:center;display:flex;position:relative;pointer-events:auto;box-sizing:border-box}vm-slider{width:75px;height:100%;margin:0;max-width:0;position:relative;z-index:3;transition:margin 0.2s cubic-bezier(0.4, 0, 1, 1),\n    max-width 0.2s cubic-bezier(0.4, 0, 1, 1);margin-left:calc(var(--vm-control-spacing) / 2) !important;visibility:hidden}vm-slider:hover{cursor:pointer}vm-slider.hidden{display:none}vm-slider.active{max-width:75px;visibility:visible;margin:0 calc(var(--vm-control-spacing) / 2)}";
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var VolumeControl = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.keyboardDisposal = new Disposal();
    this.prevMuted = false;
    this.currentVolume = 50;
    this.isSliderActive = false;
    this.lowVolumeIcon = "volume-low";
    this.highVolumeIcon = "volume-high";
    this.mutedIcon = "volume-mute";
    this.tooltipPosition = "top";
    this.hideTooltip = false;
    this.muteKeys = "m";
    this.noKeyboard = false;
    this.muted = false;
    this.volume = 50;
    this.isMobile = false;
    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ["volume", "muted", "isMobile", "i18n"]);
  }
  onNoKeyboardChange() {
    return __awaiter$1(this, void 0, void 0, function* () {
      this.keyboardDisposal.empty();
      if (this.noKeyboard)
        return;
      const player = yield findPlayer(this);
      if (isUndefined(player))
        return;
      this.keyboardDisposal.add(listen(player, "keydown", (event) => {
        if (event.key !== "ArrowUp" && event.key !== "ArrowDown")
          return;
        const isUpArrow = event.key === "ArrowUp";
        const newVolume = isUpArrow ? Math.min(100, this.volume + 5) : Math.max(0, this.volume - 5);
        this.dispatch("volume", parseInt(`${newVolume}`, 10));
      }));
    });
  }
  onPlayerVolumeChange() {
    this.currentVolume = this.muted ? 0 : this.volume;
    if (!this.muted && this.prevMuted && this.volume === 0) {
      this.dispatch("volume", 30);
    }
    this.prevMuted = this.muted;
  }
  connectedCallback() {
    this.prevMuted = this.muted;
    this.dispatch = createDispatcher(this);
    this.onNoKeyboardChange();
  }
  disconnectedCallback() {
    this.keyboardDisposal.empty();
  }
  onShowSlider() {
    clearTimeout(this.hideSliderTimeout);
    this.isSliderActive = true;
  }
  onHideSlider() {
    this.hideSliderTimeout = setTimeout(() => {
      this.isSliderActive = false;
    }, 100);
  }
  onVolumeChange(event) {
    const newVolume = event.detail;
    this.currentVolume = newVolume;
    this.dispatch("volume", newVolume);
    this.dispatch("muted", newVolume === 0);
  }
  onKeyDown(event) {
    if (event.key !== "ArrowLeft" && event.key !== "ArrowRight")
      return;
    event.stopPropagation();
  }
  render() {
    return h("div", { class: "volumeControl", onMouseEnter: this.onShowSlider.bind(this), onMouseLeave: this.onHideSlider.bind(this) }, h("vm-mute-control", { keys: this.muteKeys, lowVolumeIcon: this.lowVolumeIcon, highVolumeIcon: this.highVolumeIcon, mutedIcon: this.mutedIcon, icons: this.icons, tooltipPosition: this.tooltipPosition, tooltipDirection: this.tooltipDirection, hideTooltip: this.hideTooltip, onVmFocus: this.onShowSlider.bind(this), onVmBlur: this.onHideSlider.bind(this) }), h("vm-slider", { class: {
      hidden: this.isMobile,
      active: this.isSliderActive
    }, step: 5, max: 100, value: this.currentVolume, label: this.i18n.volume, onKeyDown: this.onKeyDown.bind(this), onVmFocus: this.onShowSlider.bind(this), onVmBlur: this.onHideSlider.bind(this), onVmValueChange: this.onVolumeChange.bind(this) }));
  }
  static get watchers() {
    return {
      "noKeyboard": ["onNoKeyboardChange"],
      "muted": ["onPlayerVolumeChange"],
      "volume": ["onPlayerVolumeChange"]
    };
  }
  static get style() {
    return volumeControlCss;
  }
};
var mapYouTubePlaybackQuality = (quality) => {
  switch (quality) {
    case "unknown":
      return void 0;
    case "tiny":
      return "144p";
    case "small":
      return "240p";
    case "medium":
      return "360p";
    case "large":
      return "480p";
    case "hd720":
      return "720p";
    case "hd1080":
      return "1080p";
    case "highres":
      return "1440p";
    case "max":
      return "2160p";
    default:
      return void 0;
  }
};
var youtubeCss = ":host{z-index:var(--vm-media-z-index)}";
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var posterCache = /* @__PURE__ */ new Map();
var YouTube = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.defaultInternalState = {};
    this.internalState = {
      paused: true,
      duration: 0,
      seeking: false,
      playbackReady: false,
      playbackStarted: false,
      currentTime: 0,
      lastTimeUpdate: 0,
      playbackRate: 1,
      state: -1
    };
    this.embedSrc = "";
    this.mediaTitle = "";
    this.cookies = false;
    this.showFullscreenControl = true;
    this.language = "en";
    this.autoplay = false;
    this.controls = false;
    this.loop = false;
    this.muted = false;
    this.playsinline = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this);
  }
  onVideoIdChange() {
    if (!this.videoId) {
      this.embedSrc = "";
      return;
    }
    this.embedSrc = `${this.getOrigin()}/embed/${this.videoId}`;
    this.fetchPosterURL = this.findPosterURL();
  }
  onCustomPosterChange() {
    this.dispatch("currentPoster", this.poster);
  }
  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    this.dispatch("viewType", ViewType.Video);
    this.onVideoIdChange();
    this.defaultInternalState = Object.assign({}, this.internalState);
  }
  componentDidLoad() {
    this.initialMuted = this.muted;
  }
  getAdapter() {
    return __awaiter(this, void 0, void 0, function* () {
      const canPlayRegex = /(?:youtu\.be|youtube|youtube\.com|youtube-nocookie\.com)\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=|)((?:\w|-){11})/;
      return {
        getInternalPlayer: () => __awaiter(this, void 0, void 0, function* () {
          return this.embed;
        }),
        play: () => __awaiter(this, void 0, void 0, function* () {
          this.remoteControl("playVideo");
        }),
        pause: () => __awaiter(this, void 0, void 0, function* () {
          this.remoteControl("pauseVideo");
        }),
        canPlay: (type) => __awaiter(this, void 0, void 0, function* () {
          return isString(type) && canPlayRegex.test(type);
        }),
        setCurrentTime: (time) => __awaiter(this, void 0, void 0, function* () {
          if (time !== this.internalState.currentTime) {
            this.remoteControl("seekTo", time);
          }
        }),
        setMuted: (muted) => __awaiter(this, void 0, void 0, function* () {
          muted ? this.remoteControl("mute") : this.remoteControl("unMute");
        }),
        setVolume: (volume) => __awaiter(this, void 0, void 0, function* () {
          this.remoteControl("setVolume", volume);
        }),
        canSetPlaybackRate: () => __awaiter(this, void 0, void 0, function* () {
          return true;
        }),
        setPlaybackRate: (rate) => __awaiter(this, void 0, void 0, function* () {
          this.remoteControl("setPlaybackRate", rate);
        })
      };
    });
  }
  getOrigin() {
    return !this.cookies ? "https://www.youtube-nocookie.com" : "https://www.youtube.com";
  }
  getPreconnections() {
    return [
      this.getOrigin(),
      "https://www.google.com",
      "https://googleads.g.doubleclick.net",
      "https://static.doubleclick.net",
      "https://s.ytimg.com",
      "https://i.ytimg.com"
    ];
  }
  remoteControl(command, arg) {
    return this.embed.postMessage({
      event: "command",
      func: command,
      args: arg ? [arg] : void 0
    });
  }
  buildParams() {
    return {
      enablejsapi: 1,
      cc_lang_pref: this.language,
      hl: this.language,
      fs: this.showFullscreenControl ? 1 : 0,
      controls: this.controls ? 1 : 0,
      disablekb: !this.controls ? 1 : 0,
      iv_load_policy: this.controls ? 1 : 3,
      mute: this.initialMuted ? 1 : 0,
      playsinline: this.playsinline ? 1 : 0,
      autoplay: this.autoplay ? 1 : 0
    };
  }
  onEmbedSrcChange() {
    this.vmLoadStart.emit();
    this.dispatch("viewType", ViewType.Video);
  }
  onEmbedLoaded() {
    window.setTimeout(() => this.embed.postMessage({ event: "listening" }), 100);
  }
  findPosterURL() {
    return __awaiter(this, void 0, void 0, function* () {
      if (posterCache.has(this.videoId))
        return posterCache.get(this.videoId);
      const posterURL = (quality) => `https://i.ytimg.com/vi/${this.videoId}/${quality}.jpg`;
      return loadImage(posterURL("maxresdefault"), 121).catch(() => loadImage(posterURL("sddefault"), 121)).catch(() => loadImage(posterURL("hqdefault"), 121)).then((img) => {
        const poster = img.src;
        posterCache.set(this.videoId, poster);
        return poster;
      });
    });
  }
  onCued() {
    if (this.internalState.playbackReady)
      return;
    this.internalState = Object.assign({}, this.defaultInternalState);
    this.dispatch("currentSrc", this.embedSrc);
    this.dispatch("mediaType", MediaType.Video);
    this.fetchPosterURL.then((poster) => {
      var _a2;
      this.dispatch("currentPoster", (_a2 = this.poster) !== null && _a2 !== void 0 ? _a2 : poster);
      this.dispatch("playbackReady", true);
    });
    this.internalState.playbackReady = true;
  }
  onPlayerStateChange(state) {
    if (this.internalState.playbackReady && state === -1) {
      this.internalState.paused = true;
      this.internalState.playbackStarted = false;
      this.dispatch("buffering", false);
      this.dispatch("paused", true);
      this.dispatch("playbackStarted", false);
      return;
    }
    const isPlaying = state === 1;
    const isBuffering = state === 3;
    this.dispatch("buffering", isBuffering);
    if (this.internalState.paused && (isBuffering || isPlaying)) {
      this.internalState.paused = false;
      this.dispatch("paused", false);
      if (!this.internalState.playbackStarted) {
        this.dispatch("playbackStarted", true);
        this.internalState.playbackStarted = true;
      }
    }
    switch (state) {
      case 5:
        this.onCued();
        break;
      case 1:
        this.onCued();
        this.dispatch("playing", true);
        break;
      case 2:
        this.internalState.paused = true;
        this.dispatch("paused", true);
        break;
      case 0:
        if (this.loop) {
          window.setTimeout(() => {
            this.remoteControl("playVideo");
          }, 150);
        } else {
          this.dispatch("playbackEnded", true);
          this.internalState.paused = true;
          this.dispatch("paused", true);
        }
        break;
    }
    this.internalState.state = state;
  }
  calcCurrentTime(time) {
    let currentTime = time;
    if (this.internalState.state === 0) {
      return this.internalState.duration;
    }
    if (this.internalState.state === 1) {
      const elapsedTime = (Date.now() / 1e3 - this.defaultInternalState.lastTimeUpdate) * this.internalState.playbackRate;
      if (elapsedTime > 0)
        currentTime += Math.min(elapsedTime, 1);
    }
    return currentTime;
  }
  onTimeChange(time) {
    const currentTime = this.calcCurrentTime(time);
    this.dispatch("currentTime", currentTime);
    if (Math.abs(this.internalState.currentTime - currentTime) > 1.5) {
      this.internalState.seeking = true;
      this.dispatch("seeking", true);
    }
    this.internalState.currentTime = currentTime;
  }
  onBufferedChange(buffered) {
    this.dispatch("buffered", buffered);
    if (this.internalState.seeking && buffered > this.internalState.currentTime) {
      window.setTimeout(() => {
        this.internalState.seeking = false;
        this.dispatch("seeking", false);
      }, this.internalState.paused ? 100 : 0);
    }
  }
  onEmbedMessage(event) {
    const message = event.detail;
    const { info } = message;
    if (!info)
      return;
    if (isObject(info.videoData))
      this.dispatch("mediaTitle", info.videoData.title);
    if (isNumber(info.duration)) {
      this.internalState.duration = info.duration;
      this.dispatch("duration", info.duration);
    }
    if (isArray(info.availablePlaybackRates)) {
      this.dispatch("playbackRates", info.availablePlaybackRates);
    }
    if (isNumber(info.playbackRate)) {
      this.internalState.playbackRate = info.playbackRate;
      this.dispatch("playbackRate", info.playbackRate);
    }
    if (isNumber(info.currentTime))
      this.onTimeChange(info.currentTime);
    if (isNumber(info.currentTimeLastUpdated)) {
      this.internalState.lastTimeUpdate = info.currentTimeLastUpdated;
    }
    if (isNumber(info.videoLoadedFraction)) {
      this.onBufferedChange(info.videoLoadedFraction * this.internalState.duration);
    }
    if (isNumber(info.volume))
      this.dispatch("volume", info.volume);
    if (isBoolean(info.muted))
      this.dispatch("muted", info.muted);
    if (isArray(info.availableQualityLevels)) {
      this.dispatch("playbackQualities", info.availableQualityLevels.map((q) => mapYouTubePlaybackQuality(q)));
    }
    if (isString(info.playbackQuality)) {
      this.dispatch("playbackQuality", mapYouTubePlaybackQuality(info.playbackQuality));
    }
    if (isNumber(info.playerState))
      this.onPlayerStateChange(info.playerState);
  }
  render() {
    return h("vm-embed", { embedSrc: this.embedSrc, mediaTitle: this.mediaTitle, origin: this.getOrigin(), params: this.buildParams(), decoder: decodeJSON, preconnections: this.getPreconnections(), onVmEmbedLoaded: this.onEmbedLoaded.bind(this), onVmEmbedMessage: this.onEmbedMessage.bind(this), onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this), ref: (el) => {
      this.embed = el;
    } });
  }
  static get watchers() {
    return {
      "cookies": ["onVideoIdChange"],
      "videoId": ["onVideoIdChange"],
      "poster": ["onCustomPosterChange"]
    };
  }
  static get style() {
    return youtubeCss;
  }
};
var VmAudio = proxyCustomElement(Audio, [4, "vm-audio", { "willAttach": [4, "will-attach"], "crossOrigin": [1, "cross-origin"], "preload": [1], "disableRemotePlayback": [4, "disable-remote-playback"], "mediaTitle": [1, "media-title"] }]);
var VmCaptionControl = proxyCustomElement(CaptionControl, [1, "vm-caption-control", { "showIcon": [1, "show-icon"], "hideIcon": [1, "hide-icon"], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "hideTooltip": [4, "hide-tooltip"], "icons": [1], "keys": [1], "i18n": [16], "playbackReady": [4, "playback-ready"], "textTracks": [16], "isTextTrackVisible": [4, "is-text-track-visible"], "canToggleCaptionVisibility": [32] }]);
var VmCaptions = proxyCustomElement(Captions, [1, "vm-captions", { "hidden": [4], "isControlsActive": [4, "is-controls-active"], "isVideoView": [4, "is-video-view"], "playbackStarted": [4, "playback-started"], "textTracks": [16], "currentTextTrack": [2, "current-text-track"], "isTextTrackVisible": [4, "is-text-track-visible"], "isEnabled": [32], "cue": [32], "fontSize": [32] }]);
var VmClickToPlay = proxyCustomElement(ClickToPlay, [1, "vm-click-to-play", { "useOnMobile": [4, "use-on-mobile"], "paused": [4], "isVideoView": [4, "is-video-view"], "isMobile": [4, "is-mobile"] }]);
var VmControl = proxyCustomElement(Control, [1, "vm-control", { "keys": [1], "identifier": [1], "hidden": [4], "label": [1], "menu": [1], "expanded": [4], "pressed": [4], "isTouch": [4, "is-touch"], "describedBy": [32], "showTapHighlight": [32] }]);
var VmControlGroup = proxyCustomElement(ControlNewLine, [1, "vm-control-group", { "space": [1] }]);
var VmControlSpacer = proxyCustomElement(ControlSpacer, [1, "vm-control-spacer"]);
var VmControls = proxyCustomElement(Controls, [1, "vm-controls", { "hidden": [4], "fullWidth": [4, "full-width"], "fullHeight": [4, "full-height"], "direction": [1], "align": [1], "justify": [1], "pin": [513], "activeDuration": [2, "active-duration"], "waitForPlaybackStart": [4, "wait-for-playback-start"], "hideWhenPaused": [4, "hide-when-paused"], "hideOnMouseLeave": [4, "hide-on-mouse-leave"], "isAudioView": [4, "is-audio-view"], "isSettingsActive": [4, "is-settings-active"], "playbackReady": [4, "playback-ready"], "isControlsActive": [4, "is-controls-active"], "paused": [4], "playbackStarted": [4, "playback-started"], "isInteracting": [32] }]);
var VmCurrentTime = proxyCustomElement(CurrentTime, [1, "vm-current-time", { "currentTime": [2, "current-time"], "i18n": [16], "alwaysShowHours": [4, "always-show-hours"] }]);
var VmDailymotion = proxyCustomElement(Dailymotion, [1, "vm-dailymotion", { "videoId": [1, "video-id"], "shouldAutoplayQueue": [4, "should-autoplay-queue"], "showUpNextQueue": [4, "show-up-next-queue"], "showShareButtons": [4, "show-share-buttons"], "color": [1], "syndication": [1], "showDailymotionLogo": [4, "show-dailymotion-logo"], "showVideoInfo": [4, "show-video-info"], "language": [1], "autoplay": [4], "controls": [4], "poster": [1], "logger": [16], "loop": [4], "muted": [4], "playsinline": [4], "embedSrc": [32], "mediaTitle": [32] }]);
var VmDash = proxyCustomElement(Dash, [1, "vm-dash", { "src": [1], "version": [1], "libSrc": [1, "lib-src"], "config": [16], "autoplay": [4], "crossOrigin": [1, "cross-origin"], "preload": [1], "poster": [1], "controlsList": [1, "controls-list"], "autoPiP": [4, "auto-pip"], "disablePiP": [4, "disable-pip"], "disableRemotePlayback": [4, "disable-remote-playback"], "mediaTitle": [1, "media-title"], "enableTextTracksByDefault": [4, "enable-text-tracks-by-default"], "shouldRenderNativeTextTracks": [4, "should-render-native-text-tracks"], "isTextTrackVisible": [4, "is-text-track-visible"], "currentTextTrack": [2, "current-text-track"], "hasAttached": [32] }, [[0, "vmMediaElChange", "onMediaElChange"]]]);
var VmDblClickFullscreen = proxyCustomElement(DblClickFullscreen, [1, "vm-dbl-click-fullscreen", { "useOnMobile": [4, "use-on-mobile"], "isFullscreenActive": [4, "is-fullscreen-active"], "isVideoView": [4, "is-video-view"], "playbackReady": [4, "playback-ready"], "isMobile": [4, "is-mobile"], "canSetFullscreen": [32] }]);
var VmDefaultControls = proxyCustomElement(DefaultControls, [1, "vm-default-controls", { "activeDuration": [2, "active-duration"], "waitForPlaybackStart": [4, "wait-for-playback-start"], "hideWhenPaused": [4, "hide-when-paused"], "hideOnMouseLeave": [4, "hide-on-mouse-leave"], "theme": [1], "isMobile": [4, "is-mobile"], "isLive": [4, "is-live"], "isAudioView": [4, "is-audio-view"], "isVideoView": [4, "is-video-view"] }]);
var VmDefaultSettings = proxyCustomElement(DefaultSettings, [1, "vm-default-settings", { "pin": [513], "i18n": [16], "playbackReady": [4, "playback-ready"], "playbackRate": [2, "playback-rate"], "playbackRates": [16], "isVideoView": [4, "is-video-view"], "playbackQuality": [1, "playback-quality"], "playbackQualities": [16], "textTracks": [16], "currentTextTrack": [2, "current-text-track"], "audioTracks": [16], "currentAudioTrack": [2, "current-audio-track"], "isTextTrackVisible": [4, "is-text-track-visible"], "canSetPlaybackRate": [32], "canSetPlaybackQuality": [32], "canSetTextTrack": [32], "canSetAudioTrack": [32] }]);
var VmDefaultUi = proxyCustomElement(DefaultUI, [1, "vm-default-ui", { "noClickToPlay": [4, "no-click-to-play"], "noDblClickFullscreen": [4, "no-dbl-click-fullscreen"], "noCaptions": [4, "no-captions"], "noPoster": [4, "no-poster"], "noSpinner": [4, "no-spinner"], "noControls": [4, "no-controls"], "noSettings": [4, "no-settings"], "noLoadingScreen": [4, "no-loading-screen"] }]);
var VmEmbed = proxyCustomElement(Embed, [1, "vm-embed", { "embedSrc": [1, "embed-src"], "mediaTitle": [1, "media-title"], "params": [1], "origin": [1], "preconnections": [16], "decoder": [16], "srcWithParams": [32], "hasEnteredViewport": [32] }, [[8, "message", "onWindowMessage"]]]);
var VmEndTime = proxyCustomElement(EndTime, [1, "vm-end-time", { "duration": [2], "i18n": [16], "alwaysShowHours": [4, "always-show-hours"] }]);
var VmFile = proxyCustomElement(File, [6, "vm-file", { "willAttach": [4, "will-attach"], "crossOrigin": [1, "cross-origin"], "preload": [1], "poster": [1], "mediaTitle": [1, "media-title"], "controlsList": [1, "controls-list"], "autoPiP": [4, "auto-pip"], "disablePiP": [4, "disable-pip"], "disableRemotePlayback": [4, "disable-remote-playback"], "viewType": [1, "view-type"], "playbackRates": [16], "language": [1], "autoplay": [4], "controls": [4], "logger": [16], "loop": [4], "muted": [4], "playsinline": [4], "noConnect": [4, "no-connect"], "paused": [4], "currentTime": [2, "current-time"], "volume": [2], "playbackReady": [4, "playback-ready"], "playbackStarted": [4, "playback-started"], "currentTextTrack": [2, "current-text-track"], "hasCustomTextManager": [4, "has-custom-text-manager"], "isTextTrackVisible": [4, "is-text-track-visible"], "shouldRenderNativeTextTracks": [4, "should-render-native-text-tracks"], "vmPoster": [32] }, [[0, "vmMediaProviderConnect", "onProviderConnect"], [0, "vmMediaProviderDisconnect", "onProviderDisconnect"]]]);
var VmFullscreenControl = proxyCustomElement(FullscreenControl, [1, "vm-fullscreen-control", { "enterIcon": [1, "enter-icon"], "exitIcon": [1, "exit-icon"], "icons": [1], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "hideTooltip": [4, "hide-tooltip"], "keys": [1], "isFullscreenActive": [4, "is-fullscreen-active"], "i18n": [16], "playbackReady": [4, "playback-ready"], "canSetFullscreen": [32] }]);
var VmHls = proxyCustomElement(HLS, [4, "vm-hls", { "version": [1], "libSrc": [1, "lib-src"], "config": [8], "crossOrigin": [1, "cross-origin"], "preload": [1], "poster": [1], "controlsList": [1, "controls-list"], "autoPiP": [4, "auto-pip"], "disablePiP": [4, "disable-pip"], "disableRemotePlayback": [4, "disable-remote-playback"], "playbackReady": [4, "playback-ready"], "mediaTitle": [1, "media-title"], "hasAttached": [32] }, [[0, "vmMediaElChange", "onMediaElChange"], [0, "vmSrcSetChange", "onSrcChange"]]]);
var VmIcon = proxyCustomElement(Icon, [1, "vm-icon", { "name": [1], "src": [1], "label": [1], "library": [1], "icons": [1], "svg": [32] }]);
var VmIconLibrary = proxyCustomElement(IconLibrary, [1, "vm-icon-library", { "name": [1], "resolver": [16], "icons": [1] }]);
var VmLiveIndicator = proxyCustomElement(LiveIndicator, [1, "vm-live-indicator", { "isLive": [4, "is-live"], "i18n": [16] }]);
var VmLoadingScreen = proxyCustomElement(LoadingScreen, [1, "vm-loading-screen", { "playbackReady": [4, "playback-ready"], "hideDots": [4, "hide-dots"] }]);
var VmMenu = proxyCustomElement(Menu, [1, "vm-menu", { "active": [1540], "identifier": [1], "controller": [16], "slideInDirection": [1, "slide-in-direction"], "activeMenuItem": [32], "activeSubmenu": [32] }, [[0, "vmOpenSubmenu", "onOpenSubmenu"], [0, "vmCloseSubmenu", "onCloseSubmenu"], [8, "click", "onWindowClick"], [8, "keydown", "onWindowKeyDown"]]]);
var VmMenuItem = proxyCustomElement(MenuItem, [1, "vm-menu-item", { "identifier": [1], "hidden": [4], "label": [1], "menu": [16], "expanded": [4], "checked": [4], "hint": [1], "badge": [1], "checkIcon": [1, "check-icon"], "icons": [1], "isTouch": [4, "is-touch"], "showTapHighlight": [32] }]);
var VmMenuRadio = proxyCustomElement(MenuRadio, [1, "vm-menu-radio", { "label": [1], "value": [1], "checked": [1028], "badge": [1], "checkIcon": [1, "check-icon"], "icons": [1] }]);
var VmMenuRadioGroup = proxyCustomElement(MenuRadioGroup, [1, "vm-menu-radio-group", { "value": [1025] }, [[0, "vmCheck", "onSelectionChange"]]]);
var VmMuteControl = proxyCustomElement(MuteControl, [1, "vm-mute-control", { "lowVolumeIcon": [1, "low-volume-icon"], "highVolumeIcon": [1, "high-volume-icon"], "mutedIcon": [1, "muted-icon"], "icons": [1], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "hideTooltip": [4, "hide-tooltip"], "keys": [1], "volume": [2], "muted": [4], "i18n": [16] }]);
var VmPipControl = proxyCustomElement(PiPControl, [1, "vm-pip-control", { "enterIcon": [1, "enter-icon"], "exitIcon": [1, "exit-icon"], "icons": [1], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "hideTooltip": [4, "hide-tooltip"], "keys": [1], "isPiPActive": [4, "is-pi-p-active"], "i18n": [16], "playbackReady": [4, "playback-ready"], "canSetPiP": [32] }]);
var VmPlaybackControl = proxyCustomElement(PlaybackControl, [1, "vm-playback-control", { "playIcon": [1, "play-icon"], "pauseIcon": [1, "pause-icon"], "icons": [1], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "hideTooltip": [4, "hide-tooltip"], "keys": [1], "paused": [4], "i18n": [16] }]);
var VmPlayer = proxyCustomElement(Player, [1, "vm-player", { "logger": [16], "theme": [513], "icons": [513], "paused": [1028], "playing": [1028], "duration": [1026], "mediaTitle": [1025, "media-title"], "currentProvider": [1025, "current-provider"], "currentSrc": [1025, "current-src"], "currentPoster": [1025, "current-poster"], "currentTime": [1026, "current-time"], "autoplay": [4], "ready": [1540], "playbackReady": [1028, "playback-ready"], "loop": [4], "muted": [1028], "buffered": [1026], "playbackRate": [1026, "playback-rate"], "playbackRates": [1040], "playbackQuality": [1025, "playback-quality"], "playbackQualities": [1040], "seeking": [1028], "debug": [4], "playbackStarted": [1028, "playback-started"], "playbackEnded": [1028, "playback-ended"], "buffering": [1028], "controls": [4], "isControlsActive": [4, "is-controls-active"], "isSettingsActive": [1028, "is-settings-active"], "volume": [1026], "isFullscreenActive": [1028, "is-fullscreen-active"], "aspectRatio": [1025, "aspect-ratio"], "viewType": [1025, "view-type"], "isAudioView": [1028, "is-audio-view"], "isVideoView": [1028, "is-video-view"], "mediaType": [1025, "media-type"], "isAudio": [1028, "is-audio"], "isVideo": [1028, "is-video"], "isLive": [1028, "is-live"], "isMobile": [1028, "is-mobile"], "isTouch": [1028, "is-touch"], "isPiPActive": [1028, "is-pi-p-active"], "textTracks": [16], "currentTextTrack": [2, "current-text-track"], "isTextTrackVisible": [4, "is-text-track-visible"], "shouldRenderNativeTextTracks": [4, "should-render-native-text-tracks"], "audioTracks": [16], "currentAudioTrack": [2, "current-audio-track"], "autopause": [4], "playsinline": [4], "language": [1025], "translations": [1040], "languages": [1040], "i18n": [1040], "container": [32] }, [[0, "vmError", "onError"]]]);
var VmPoster = proxyCustomElement(Poster, [1, "vm-poster", { "fit": [1], "isVideoView": [4, "is-video-view"], "currentPoster": [1, "current-poster"], "mediaTitle": [1, "media-title"], "playbackStarted": [4, "playback-started"], "currentTime": [2, "current-time"], "isHidden": [32], "isActive": [32], "hasLoaded": [32] }]);
var VmScrim = proxyCustomElement(Scrim, [1, "vm-scrim", { "gradient": [1], "isVideoView": [4, "is-video-view"], "isControlsActive": [4, "is-controls-active"] }]);
var VmScrubberControl = proxyCustomElement(ScrubberControl, [1, "vm-scrubber-control", { "alwaysShowHours": [4, "always-show-hours"], "hideTooltip": [4, "hide-tooltip"], "currentTime": [2, "current-time"], "duration": [2], "noKeyboard": [4, "no-keyboard"], "buffering": [4], "buffered": [2], "i18n": [16], "timestamp": [32], "endTime": [32] }]);
var VmSettings = proxyCustomElement(Settings, [1, "vm-settings", { "pin": [513], "active": [1540], "isMobile": [4, "is-mobile"], "isAudioView": [4, "is-audio-view"], "menuHeight": [32] }]);
var VmSettingsControl = proxyCustomElement(SettingsControl, [1, "vm-settings-control", { "icon": [1], "icons": [1], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "menu": [1], "expanded": [4], "i18n": [16], "vmSettings": [32] }]);
var VmSkeleton = proxyCustomElement(Skeleton, [1, "vm-skeleton", { "effect": [1], "ready": [4], "hidden": [32] }]);
var VmSlider = proxyCustomElement(Slider, [1, "vm-slider", { "step": [2], "min": [2], "max": [2], "value": [2], "valueText": [1, "value-text"], "label": [1] }]);
var VmSpinner = proxyCustomElement(Spinner, [1, "vm-spinner", { "isVideoView": [4, "is-video-view"], "currentProvider": [1, "current-provider"], "showWhenMediaLoading": [4, "show-when-media-loading"], "playbackReady": [4, "playback-ready"], "buffering": [4], "isHidden": [32], "isActive": [32] }]);
var VmSubmenu = proxyCustomElement(Submenu, [1, "vm-submenu", { "label": [1], "hint": [1], "slideInDirection": [1, "slide-in-direction"], "active": [1540], "menu": [32], "controller": [32] }]);
var VmTime = proxyCustomElement(Time, [1, "vm-time", { "label": [1], "seconds": [2], "alwaysShowHours": [4, "always-show-hours"] }]);
var VmTimeProgress = proxyCustomElement(TimeProgress, [1, "vm-time-progress", { "separator": [1], "alwaysShowHours": [4, "always-show-hours"] }]);
var VmTooltip = proxyCustomElement(Tooltip, [1, "vm-tooltip", { "hidden": [4], "active": [4], "position": [1], "direction": [1], "isTouch": [4, "is-touch"], "isMobile": [4, "is-mobile"] }]);
var VmUi = proxyCustomElement(UI, [1, "vm-ui", { "isVideoView": [4, "is-video-view"], "playsinline": [4], "isFullscreenActive": [4, "is-fullscreen-active"] }]);
var VmVideo = proxyCustomElement(Video, [4, "vm-video", { "willAttach": [4, "will-attach"], "hasCustomTextManager": [4, "has-custom-text-manager"], "crossOrigin": [1, "cross-origin"], "preload": [1], "poster": [1], "controlsList": [1, "controls-list"], "autoPiP": [4, "auto-pip"], "disablePiP": [4, "disable-pip"], "disableRemotePlayback": [4, "disable-remote-playback"], "mediaTitle": [1, "media-title"] }, [[0, "vmMediaProviderConnect", "onProviderConnect"], [0, "vmMediaProviderDisconnect", "onProviderDisconnect"]]]);
var VmVimeo = proxyCustomElement(Vimeo, [1, "vm-vimeo", { "videoId": [1, "video-id"], "byline": [4], "color": [1], "portrait": [4], "noAutoAspectRatio": [4, "no-auto-aspect-ratio"], "poster": [1], "cookies": [4], "language": [1], "aspectRatio": [1, "aspect-ratio"], "autoplay": [4], "controls": [4], "logger": [16], "loop": [4], "muted": [4], "playsinline": [4], "embedSrc": [32], "mediaTitle": [32] }]);
var VmVolumeControl = proxyCustomElement(VolumeControl, [1, "vm-volume-control", { "lowVolumeIcon": [1, "low-volume-icon"], "highVolumeIcon": [1, "high-volume-icon"], "mutedIcon": [1, "muted-icon"], "icons": [1], "tooltipPosition": [1, "tooltip-position"], "tooltipDirection": [1, "tooltip-direction"], "hideTooltip": [4, "hide-tooltip"], "muteKeys": [1, "mute-keys"], "noKeyboard": [4, "no-keyboard"], "muted": [4], "volume": [2], "isMobile": [4, "is-mobile"], "i18n": [16], "currentVolume": [32], "isSliderActive": [32] }]);
var VmYoutube = proxyCustomElement(YouTube, [1, "vm-youtube", { "cookies": [4], "videoId": [1, "video-id"], "showFullscreenControl": [4, "show-fullscreen-control"], "poster": [1], "language": [1], "autoplay": [4], "controls": [4], "logger": [16], "loop": [4], "muted": [4], "playsinline": [4], "embedSrc": [32], "mediaTitle": [32] }]);

// node_modules/@vime/react/dist/esm/lib.jsx
var import_compose_react_refs = __toESM(require_composeRefs());
var import_react = __toESM(require_react());
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t[p[i2]] = s[p[i2]];
    }
  return t;
};
var define = (tagName, clazz) => {
  const isClient = typeof window !== "undefined";
  if (isClient && !customElements.get(tagName))
    customElements.define(tagName, clazz);
};
var dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
var isEvent = (prop) => {
  var _a2;
  return prop.indexOf("on") === 0 && prop[2] === ((_a2 = prop[2]) === null || _a2 === void 0 ? void 0 : _a2.toUpperCase());
};
var toDomEventName = (prop) => prop.charAt(2).toLowerCase() + prop.substring(3);
function createComponent(tagName, componentProps) {
  const Component = (0, import_react.forwardRef)((_a2, forwardedRef) => {
    var { children } = _a2, props = __rest(_a2, ["children"]);
    const [ref, setRef] = (0, import_react.useState)(null);
    const setRefCb = (0, import_react.useCallback)((node) => {
      setRef(node);
    }, []);
    const eventHandlers = (0, import_react.useRef)(/* @__PURE__ */ new Map());
    const domProps = (0, import_react.useMemo)(() => Object.keys(props).filter((prop) => !componentProps.has(prop) && !isEvent(prop)).reduce((p, c) => Object.assign(Object.assign({}, p), { [c]: props[c] }), {}), [props]);
    const wcProps = (0, import_react.useMemo)(() => Object.keys(props).filter((prop) => componentProps.has(prop) || isEvent(prop)).reduce((p, c) => Object.assign(Object.assign({}, p), { [c]: props[c] }), {}), [props]);
    const listen2 = (0, import_react.useCallback)((prop, handler) => {
      var _a3;
      const domEvent = toDomEventName(prop);
      (_a3 = eventHandlers.current.get(domEvent)) === null || _a3 === void 0 ? void 0 : _a3();
      if (!ref || !handler)
        return;
      ref.addEventListener(domEvent, handler);
      eventHandlers.current.set(domEvent, () => {
        ref.removeEventListener(domEvent, handler);
      });
    }, [ref]);
    const cleanup = (0, import_react.useCallback)(() => {
      eventHandlers.current.forEach((fn) => fn());
      eventHandlers.current.clear();
    }, []);
    (0, import_react.useEffect)(() => () => {
      cleanup();
    }, []);
    (0, import_react.useEffect)(() => {
      if (!ref)
        return;
      Object.keys(wcProps).forEach((prop) => {
        if (isEvent(prop)) {
          listen2(prop, wcProps[prop]);
          return;
        }
        if (ref[prop] !== wcProps[prop]) {
          ref[prop] = wcProps[prop];
        }
      });
    }, [ref, wcProps]);
    return (0, import_react.createElement)(tagName, Object.assign({ ref: (0, import_compose_react_refs.default)(setRefCb, forwardedRef) }, domProps), children);
  });
  Component.displayName = dashToPascalCase(tagName);
  return Component;
}

// node_modules/@vime/react/dist/esm/components/Audio.jsx
define("vm-audio", VmAudio);
define("vm-file", VmFile);
var Audio_default = createComponent("vm-audio", /* @__PURE__ */ new Set(["willAttach", "crossOrigin", "preload", "disableRemotePlayback", "mediaTitle"]));

// node_modules/@vime/react/dist/esm/components/CaptionControl.jsx
define("vm-caption-control", VmCaptionControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
var CaptionControl_default = createComponent("vm-caption-control", /* @__PURE__ */ new Set(["showIcon", "hideIcon", "tooltipPosition", "tooltipDirection", "hideTooltip", "icons", "keys", "i18n", "playbackReady", "textTracks", "isTextTrackVisible"]));

// node_modules/@vime/react/dist/esm/components/Captions.jsx
define("vm-captions", VmCaptions);
var Captions_default = createComponent("vm-captions", /* @__PURE__ */ new Set(["hidden", "isControlsActive", "isVideoView", "playbackStarted", "textTracks", "currentTextTrack", "isTextTrackVisible"]));

// node_modules/@vime/react/dist/esm/components/ClickToPlay.jsx
define("vm-click-to-play", VmClickToPlay);
var ClickToPlay_default = createComponent("vm-click-to-play", /* @__PURE__ */ new Set(["useOnMobile", "paused", "isVideoView", "isMobile"]));

// node_modules/@vime/react/dist/esm/components/Control.jsx
define("vm-control", VmControl);
var Control_default = createComponent("vm-control", /* @__PURE__ */ new Set(["keys", "identifier", "hidden", "label", "menu", "expanded", "pressed", "isTouch"]));

// node_modules/@vime/react/dist/esm/components/ControlGroup.jsx
define("vm-control-group", VmControlGroup);
var ControlGroup_default = createComponent("vm-control-group", /* @__PURE__ */ new Set(["space"]));

// node_modules/@vime/react/dist/esm/components/ControlSpacer.jsx
define("vm-control-spacer", VmControlSpacer);
var ControlSpacer_default = createComponent("vm-control-spacer", /* @__PURE__ */ new Set([]));

// node_modules/@vime/react/dist/esm/components/Controls.jsx
define("vm-controls", VmControls);
var Controls_default = createComponent("vm-controls", /* @__PURE__ */ new Set(["hidden", "fullWidth", "fullHeight", "direction", "align", "justify", "pin", "activeDuration", "waitForPlaybackStart", "hideWhenPaused", "hideOnMouseLeave", "isAudioView", "isSettingsActive", "playbackReady", "isControlsActive", "paused", "playbackStarted"]));

// node_modules/@vime/react/dist/esm/components/CurrentTime.jsx
define("vm-current-time", VmCurrentTime);
define("vm-time", VmTime);
var CurrentTime_default = createComponent("vm-current-time", /* @__PURE__ */ new Set(["currentTime", "i18n", "alwaysShowHours"]));

// node_modules/@vime/react/dist/esm/components/Dailymotion.jsx
define("vm-dailymotion", VmDailymotion);
define("vm-embed", VmEmbed);
var Dailymotion_default = createComponent("vm-dailymotion", /* @__PURE__ */ new Set(["videoId", "shouldAutoplayQueue", "showUpNextQueue", "showShareButtons", "color", "syndication", "showDailymotionLogo", "showVideoInfo", "language", "autoplay", "controls", "poster", "logger", "loop", "muted", "playsinline"]));

// node_modules/@vime/react/dist/esm/components/Dash.jsx
define("vm-dash", VmDash);
define("vm-file", VmFile);
define("vm-video", VmVideo);
var Dash_default = createComponent("vm-dash", /* @__PURE__ */ new Set(["src", "version", "libSrc", "config", "autoplay", "crossOrigin", "preload", "poster", "controlsList", "autoPiP", "disablePiP", "disableRemotePlayback", "mediaTitle", "enableTextTracksByDefault", "shouldRenderNativeTextTracks", "isTextTrackVisible", "currentTextTrack"]));

// node_modules/@vime/react/dist/esm/components/DblClickFullscreen.jsx
define("vm-dbl-click-fullscreen", VmDblClickFullscreen);
var DblClickFullscreen_default = createComponent("vm-dbl-click-fullscreen", /* @__PURE__ */ new Set(["useOnMobile", "isFullscreenActive", "isVideoView", "playbackReady", "isMobile"]));

// node_modules/@vime/react/dist/esm/components/DefaultControls.jsx
define("vm-default-controls", VmDefaultControls);
define("vm-caption-control", VmCaptionControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
define("vm-control-group", VmControlGroup);
define("vm-control-spacer", VmControlSpacer);
define("vm-controls", VmControls);
define("vm-current-time", VmCurrentTime);
define("vm-time", VmTime);
define("vm-end-time", VmEndTime);
define("vm-fullscreen-control", VmFullscreenControl);
define("vm-live-indicator", VmLiveIndicator);
define("vm-mute-control", VmMuteControl);
define("vm-pip-control", VmPipControl);
define("vm-playback-control", VmPlaybackControl);
define("vm-scrim", VmScrim);
define("vm-scrubber-control", VmScrubberControl);
define("vm-slider", VmSlider);
define("vm-settings-control", VmSettingsControl);
define("vm-time-progress", VmTimeProgress);
define("vm-volume-control", VmVolumeControl);
var DefaultControls_default = createComponent("vm-default-controls", /* @__PURE__ */ new Set(["activeDuration", "waitForPlaybackStart", "hideWhenPaused", "hideOnMouseLeave", "theme", "isMobile", "isLive", "isAudioView", "isVideoView"]));

// node_modules/@vime/react/dist/esm/components/DefaultSettings.jsx
define("vm-default-settings", VmDefaultSettings);
define("vm-icon", VmIcon);
define("vm-menu", VmMenu);
define("vm-menu-item", VmMenuItem);
define("vm-menu-radio", VmMenuRadio);
define("vm-menu-radio-group", VmMenuRadioGroup);
define("vm-settings", VmSettings);
define("vm-submenu", VmSubmenu);
var DefaultSettings_default = createComponent("vm-default-settings", /* @__PURE__ */ new Set(["pin", "i18n", "playbackReady", "playbackRate", "playbackRates", "isVideoView", "playbackQuality", "playbackQualities", "textTracks", "currentTextTrack", "audioTracks", "currentAudioTrack", "isTextTrackVisible"]));

// node_modules/@vime/react/dist/esm/components/DefaultUi.jsx
define("vm-default-ui", VmDefaultUi);
define("vm-caption-control", VmCaptionControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
define("vm-captions", VmCaptions);
define("vm-click-to-play", VmClickToPlay);
define("vm-control-group", VmControlGroup);
define("vm-control-spacer", VmControlSpacer);
define("vm-controls", VmControls);
define("vm-current-time", VmCurrentTime);
define("vm-time", VmTime);
define("vm-dbl-click-fullscreen", VmDblClickFullscreen);
define("vm-default-controls", VmDefaultControls);
define("vm-end-time", VmEndTime);
define("vm-fullscreen-control", VmFullscreenControl);
define("vm-live-indicator", VmLiveIndicator);
define("vm-mute-control", VmMuteControl);
define("vm-pip-control", VmPipControl);
define("vm-playback-control", VmPlaybackControl);
define("vm-scrim", VmScrim);
define("vm-scrubber-control", VmScrubberControl);
define("vm-slider", VmSlider);
define("vm-settings-control", VmSettingsControl);
define("vm-time-progress", VmTimeProgress);
define("vm-volume-control", VmVolumeControl);
define("vm-default-settings", VmDefaultSettings);
define("vm-menu", VmMenu);
define("vm-menu-item", VmMenuItem);
define("vm-menu-radio", VmMenuRadio);
define("vm-menu-radio-group", VmMenuRadioGroup);
define("vm-settings", VmSettings);
define("vm-submenu", VmSubmenu);
define("vm-loading-screen", VmLoadingScreen);
define("vm-poster", VmPoster);
define("vm-spinner", VmSpinner);
define("vm-ui", VmUi);
var DefaultUi_default = createComponent("vm-default-ui", /* @__PURE__ */ new Set(["noClickToPlay", "noDblClickFullscreen", "noCaptions", "noPoster", "noSpinner", "noControls", "noSettings", "noLoadingScreen"]));

// node_modules/@vime/react/dist/esm/components/Embed.jsx
define("vm-embed", VmEmbed);
var Embed_default = createComponent("vm-embed", /* @__PURE__ */ new Set(["embedSrc", "mediaTitle", "params", "origin", "preconnections", "decoder"]));

// node_modules/@vime/react/dist/esm/components/EndTime.jsx
define("vm-end-time", VmEndTime);
define("vm-time", VmTime);
var EndTime_default = createComponent("vm-end-time", /* @__PURE__ */ new Set(["duration", "i18n", "alwaysShowHours"]));

// node_modules/@vime/react/dist/esm/components/File.jsx
define("vm-file", VmFile);
var File_default = createComponent("vm-file", /* @__PURE__ */ new Set(["willAttach", "crossOrigin", "preload", "poster", "mediaTitle", "controlsList", "autoPiP", "disablePiP", "disableRemotePlayback", "viewType", "playbackRates", "language", "autoplay", "controls", "logger", "loop", "muted", "playsinline", "noConnect", "paused", "currentTime", "volume", "playbackReady", "playbackStarted", "currentTextTrack", "hasCustomTextManager", "isTextTrackVisible", "shouldRenderNativeTextTracks"]));

// node_modules/@vime/react/dist/esm/components/FullscreenControl.jsx
define("vm-fullscreen-control", VmFullscreenControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
var FullscreenControl_default = createComponent("vm-fullscreen-control", /* @__PURE__ */ new Set(["enterIcon", "exitIcon", "icons", "tooltipPosition", "tooltipDirection", "hideTooltip", "keys", "isFullscreenActive", "i18n", "playbackReady"]));

// node_modules/@vime/react/dist/esm/components/Hls.jsx
define("vm-hls", VmHls);
define("vm-file", VmFile);
define("vm-video", VmVideo);
var Hls_default = createComponent("vm-hls", /* @__PURE__ */ new Set(["version", "libSrc", "config", "crossOrigin", "preload", "poster", "controlsList", "autoPiP", "disablePiP", "disableRemotePlayback", "playbackReady", "mediaTitle"]));

// node_modules/@vime/react/dist/esm/components/Icon.jsx
define("vm-icon", VmIcon);
var Icon_default = createComponent("vm-icon", /* @__PURE__ */ new Set(["name", "src", "label", "library", "icons"]));

// node_modules/@vime/react/dist/esm/components/IconLibrary.jsx
define("vm-icon-library", VmIconLibrary);
var IconLibrary_default = createComponent("vm-icon-library", /* @__PURE__ */ new Set(["name", "resolver", "icons"]));

// node_modules/@vime/react/dist/esm/components/LiveIndicator.jsx
define("vm-live-indicator", VmLiveIndicator);
var LiveIndicator_default = createComponent("vm-live-indicator", /* @__PURE__ */ new Set(["isLive", "i18n"]));

// node_modules/@vime/react/dist/esm/components/LoadingScreen.jsx
define("vm-loading-screen", VmLoadingScreen);
var LoadingScreen_default = createComponent("vm-loading-screen", /* @__PURE__ */ new Set(["playbackReady", "hideDots"]));

// node_modules/@vime/react/dist/esm/components/Menu.jsx
define("vm-menu", VmMenu);
var Menu_default = createComponent("vm-menu", /* @__PURE__ */ new Set(["active", "identifier", "controller", "slideInDirection"]));

// node_modules/@vime/react/dist/esm/components/MenuItem.jsx
define("vm-menu-item", VmMenuItem);
define("vm-icon", VmIcon);
var MenuItem_default = createComponent("vm-menu-item", /* @__PURE__ */ new Set(["identifier", "hidden", "label", "menu", "expanded", "checked", "hint", "badge", "checkIcon", "icons", "isTouch"]));

// node_modules/@vime/react/dist/esm/components/MenuRadio.jsx
define("vm-menu-radio", VmMenuRadio);
define("vm-icon", VmIcon);
define("vm-menu-item", VmMenuItem);
var MenuRadio_default = createComponent("vm-menu-radio", /* @__PURE__ */ new Set(["label", "value", "checked", "badge", "checkIcon", "icons"]));

// node_modules/@vime/react/dist/esm/components/MenuRadioGroup.jsx
define("vm-menu-radio-group", VmMenuRadioGroup);
var MenuRadioGroup_default = createComponent("vm-menu-radio-group", /* @__PURE__ */ new Set(["value"]));

// node_modules/@vime/react/dist/esm/components/MuteControl.jsx
define("vm-mute-control", VmMuteControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
var MuteControl_default = createComponent("vm-mute-control", /* @__PURE__ */ new Set(["lowVolumeIcon", "highVolumeIcon", "mutedIcon", "icons", "tooltipPosition", "tooltipDirection", "hideTooltip", "keys", "volume", "muted", "i18n"]));

// node_modules/@vime/react/dist/esm/components/PipControl.jsx
define("vm-pip-control", VmPipControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
var PipControl_default = createComponent("vm-pip-control", /* @__PURE__ */ new Set(["enterIcon", "exitIcon", "icons", "tooltipPosition", "tooltipDirection", "hideTooltip", "keys", "isPiPActive", "i18n", "playbackReady"]));

// node_modules/@vime/react/dist/esm/components/PlaybackControl.jsx
define("vm-playback-control", VmPlaybackControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
var PlaybackControl_default = createComponent("vm-playback-control", /* @__PURE__ */ new Set(["playIcon", "pauseIcon", "icons", "tooltipPosition", "tooltipDirection", "hideTooltip", "keys", "paused", "i18n"]));

// node_modules/@vime/react/dist/esm/components/Player.jsx
define("vm-player", VmPlayer);
var Player_default = createComponent("vm-player", /* @__PURE__ */ new Set(["logger", "theme", "icons", "paused", "playing", "duration", "mediaTitle", "currentProvider", "currentSrc", "currentPoster", "currentTime", "autoplay", "ready", "playbackReady", "loop", "muted", "buffered", "playbackRate", "playbackRates", "playbackQuality", "playbackQualities", "seeking", "debug", "playbackStarted", "playbackEnded", "buffering", "controls", "isControlsActive", "isSettingsActive", "volume", "isFullscreenActive", "aspectRatio", "viewType", "isAudioView", "isVideoView", "mediaType", "isAudio", "isVideo", "isLive", "isMobile", "isTouch", "isPiPActive", "textTracks", "currentTextTrack", "isTextTrackVisible", "shouldRenderNativeTextTracks", "audioTracks", "currentAudioTrack", "autopause", "playsinline", "language", "translations", "languages", "i18n"]));

// node_modules/@vime/react/dist/esm/components/Poster.jsx
define("vm-poster", VmPoster);
var Poster_default = createComponent("vm-poster", /* @__PURE__ */ new Set(["fit", "isVideoView", "currentPoster", "mediaTitle", "playbackStarted", "currentTime"]));

// node_modules/@vime/react/dist/esm/components/Scrim.jsx
define("vm-scrim", VmScrim);
var Scrim_default = createComponent("vm-scrim", /* @__PURE__ */ new Set(["gradient", "isVideoView", "isControlsActive"]));

// node_modules/@vime/react/dist/esm/components/ScrubberControl.jsx
define("vm-scrubber-control", VmScrubberControl);
define("vm-slider", VmSlider);
define("vm-tooltip", VmTooltip);
var ScrubberControl_default = createComponent("vm-scrubber-control", /* @__PURE__ */ new Set(["alwaysShowHours", "hideTooltip", "currentTime", "duration", "noKeyboard", "buffering", "buffered", "i18n"]));

// node_modules/@vime/react/dist/esm/components/Settings.jsx
define("vm-settings", VmSettings);
define("vm-menu", VmMenu);
var Settings_default = createComponent("vm-settings", /* @__PURE__ */ new Set(["pin", "active", "isMobile", "isAudioView"]));

// node_modules/@vime/react/dist/esm/components/SettingsControl.jsx
define("vm-settings-control", VmSettingsControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-tooltip", VmTooltip);
var SettingsControl_default = createComponent("vm-settings-control", /* @__PURE__ */ new Set(["icon", "icons", "tooltipPosition", "tooltipDirection", "menu", "expanded", "i18n"]));

// node_modules/@vime/react/dist/esm/components/Skeleton.jsx
define("vm-skeleton", VmSkeleton);
var Skeleton_default = createComponent("vm-skeleton", /* @__PURE__ */ new Set(["effect", "ready"]));

// node_modules/@vime/react/dist/esm/components/Slider.jsx
define("vm-slider", VmSlider);
var Slider_default = createComponent("vm-slider", /* @__PURE__ */ new Set(["step", "min", "max", "value", "valueText", "label"]));

// node_modules/@vime/react/dist/esm/components/Spinner.jsx
define("vm-spinner", VmSpinner);
var Spinner_default = createComponent("vm-spinner", /* @__PURE__ */ new Set(["isVideoView", "currentProvider", "showWhenMediaLoading", "playbackReady", "buffering"]));

// node_modules/@vime/react/dist/esm/components/Submenu.jsx
define("vm-submenu", VmSubmenu);
define("vm-icon", VmIcon);
define("vm-menu", VmMenu);
define("vm-menu-item", VmMenuItem);
var Submenu_default = createComponent("vm-submenu", /* @__PURE__ */ new Set(["label", "hint", "slideInDirection", "active"]));

// node_modules/@vime/react/dist/esm/components/Time.jsx
define("vm-time", VmTime);
var Time_default = createComponent("vm-time", /* @__PURE__ */ new Set(["label", "seconds", "alwaysShowHours"]));

// node_modules/@vime/react/dist/esm/components/TimeProgress.jsx
define("vm-time-progress", VmTimeProgress);
define("vm-current-time", VmCurrentTime);
define("vm-time", VmTime);
define("vm-end-time", VmEndTime);
var TimeProgress_default = createComponent("vm-time-progress", /* @__PURE__ */ new Set(["separator", "alwaysShowHours"]));

// node_modules/@vime/react/dist/esm/components/Tooltip.jsx
define("vm-tooltip", VmTooltip);
var Tooltip_default = createComponent("vm-tooltip", /* @__PURE__ */ new Set(["hidden", "active", "position", "direction", "isTouch", "isMobile"]));

// node_modules/@vime/react/dist/esm/components/Ui.jsx
define("vm-ui", VmUi);
var Ui_default = createComponent("vm-ui", /* @__PURE__ */ new Set(["isVideoView", "playsinline", "isFullscreenActive"]));

// node_modules/@vime/react/dist/esm/components/Video.jsx
define("vm-video", VmVideo);
define("vm-file", VmFile);
var Video_default = createComponent("vm-video", /* @__PURE__ */ new Set(["willAttach", "hasCustomTextManager", "crossOrigin", "preload", "poster", "controlsList", "autoPiP", "disablePiP", "disableRemotePlayback", "mediaTitle"]));

// node_modules/@vime/react/dist/esm/components/Vimeo.jsx
define("vm-vimeo", VmVimeo);
define("vm-embed", VmEmbed);
var Vimeo_default = createComponent("vm-vimeo", /* @__PURE__ */ new Set(["videoId", "byline", "color", "portrait", "noAutoAspectRatio", "poster", "cookies", "language", "aspectRatio", "autoplay", "controls", "logger", "loop", "muted", "playsinline"]));

// node_modules/@vime/react/dist/esm/components/VolumeControl.jsx
define("vm-volume-control", VmVolumeControl);
define("vm-control", VmControl);
define("vm-icon", VmIcon);
define("vm-mute-control", VmMuteControl);
define("vm-tooltip", VmTooltip);
define("vm-slider", VmSlider);
var VolumeControl_default = createComponent("vm-volume-control", /* @__PURE__ */ new Set(["lowVolumeIcon", "highVolumeIcon", "mutedIcon", "icons", "tooltipPosition", "tooltipDirection", "hideTooltip", "muteKeys", "noKeyboard", "muted", "volume", "isMobile", "i18n"]));

// node_modules/@vime/react/dist/esm/components/Youtube.jsx
define("vm-youtube", VmYoutube);
define("vm-embed", VmEmbed);
var Youtube_default = createComponent("vm-youtube", /* @__PURE__ */ new Set(["cookies", "videoId", "showFullscreenControl", "poster", "language", "autoplay", "controls", "logger", "loop", "muted", "playsinline"]));

// node_modules/@vime/react/dist/esm/components/index.js
var Audio2 = Audio_default;
var CaptionControl2 = CaptionControl_default;
var Captions2 = Captions_default;
var ClickToPlay2 = ClickToPlay_default;
var Control2 = Control_default;
var ControlGroup = ControlGroup_default;
var ControlSpacer2 = ControlSpacer_default;
var Controls2 = Controls_default;
var CurrentTime2 = CurrentTime_default;
var Dailymotion2 = Dailymotion_default;
var Dash2 = Dash_default;
var DblClickFullscreen2 = DblClickFullscreen_default;
var DefaultControls2 = DefaultControls_default;
var DefaultSettings2 = DefaultSettings_default;
var DefaultUi = DefaultUi_default;
var Embed2 = Embed_default;
var EndTime2 = EndTime_default;
var File2 = File_default;
var FullscreenControl2 = FullscreenControl_default;
var Hls = Hls_default;
var Icon2 = Icon_default;
var IconLibrary2 = IconLibrary_default;
var LiveIndicator2 = LiveIndicator_default;
var LoadingScreen2 = LoadingScreen_default;
var Menu2 = Menu_default;
var MenuItem2 = MenuItem_default;
var MenuRadio2 = MenuRadio_default;
var MenuRadioGroup2 = MenuRadioGroup_default;
var MuteControl2 = MuteControl_default;
var PipControl = PipControl_default;
var PlaybackControl2 = PlaybackControl_default;
var Player2 = Player_default;
var Poster2 = Poster_default;
var Scrim2 = Scrim_default;
var ScrubberControl2 = ScrubberControl_default;
var Settings2 = Settings_default;
var SettingsControl2 = SettingsControl_default;
var Skeleton2 = Skeleton_default;
var Slider2 = Slider_default;
var Spinner2 = Spinner_default;
var Submenu2 = Submenu_default;
var Time2 = Time_default;
var TimeProgress2 = TimeProgress_default;
var Tooltip2 = Tooltip_default;
var Ui = Ui_default;
var Video2 = Video_default;
var Vimeo2 = Vimeo_default;
var VolumeControl2 = VolumeControl_default;
var Youtube = Youtube_default;

// node_modules/@vime/react/dist/esm/hooks.js
var import_react2 = __toESM(require_react());
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var noop2 = () => {
};
var usePlayer = (ref) => {
  const [player, setPlayer] = (0, import_react2.useState)(null);
  (0, import_react2.useLayoutEffect)(() => {
    function find() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        setPlayer(ref.current ? (_a2 = yield findPlayer(ref.current)) !== null && _a2 !== void 0 ? _a2 : null : null);
      });
    }
    find();
  }, [ref.current]);
  return player;
};
var usePlayerContext2 = (ref, prop, defaultValue) => {
  const [value, setValue2] = (0, import_react2.useState)(defaultValue);
  const dispatch = (0, import_react2.useCallback)(ref.current === null ? noop2 : createDispatcher(ref.current), [ref.current]);
  const setter = (0, import_react2.useCallback)((value2) => {
    dispatch(prop, value2);
  }, [dispatch, prop]);
  (0, import_react2.useLayoutEffect)(() => {
    if (ref.current === null)
      return void 0;
    let cleanup;
    function connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        cleanup = yield usePlayerContext(ref.current, [prop], (_, newValue) => {
          setValue2(newValue);
        });
      });
    }
    connect();
    return () => {
      cleanup === null || cleanup === void 0 ? void 0 : cleanup();
    };
  }, [ref.current, prop]);
  return [value, setter];
};
export {
  Audio2 as Audio,
  CaptionControl2 as CaptionControl,
  Captions2 as Captions,
  ClickToPlay2 as ClickToPlay,
  Control2 as Control,
  ControlGroup,
  ControlSpacer2 as ControlSpacer,
  Controls2 as Controls,
  CurrentTime2 as CurrentTime,
  Dailymotion2 as Dailymotion,
  Dash2 as Dash,
  DblClickFullscreen2 as DblClickFullscreen,
  DefaultControls2 as DefaultControls,
  DefaultSettings2 as DefaultSettings,
  DefaultUi,
  Embed2 as Embed,
  EndTime2 as EndTime,
  File2 as File,
  FullscreenControl2 as FullscreenControl,
  Hls,
  Icon2 as Icon,
  IconLibrary2 as IconLibrary,
  LiveIndicator2 as LiveIndicator,
  LoadingScreen2 as LoadingScreen,
  Menu2 as Menu,
  MenuItem2 as MenuItem,
  MenuRadio2 as MenuRadio,
  MenuRadioGroup2 as MenuRadioGroup,
  MuteControl2 as MuteControl,
  PipControl,
  PlaybackControl2 as PlaybackControl,
  Player2 as Player,
  Poster2 as Poster,
  Provider,
  Scrim2 as Scrim,
  ScrubberControl2 as ScrubberControl,
  Settings2 as Settings,
  SettingsControl2 as SettingsControl,
  Skeleton2 as Skeleton,
  Slider2 as Slider,
  Spinner2 as Spinner,
  Submenu2 as Submenu,
  Time2 as Time,
  TimeProgress2 as TimeProgress,
  Tooltip2 as Tooltip,
  Ui,
  Video2 as Video,
  ViewType,
  Vimeo2 as Vimeo,
  VolumeControl2 as VolumeControl,
  Youtube,
  usePlayer,
  usePlayerContext2 as usePlayerContext,
  watchComponentRegistry
};
//# sourceMappingURL=@vime_react.js.map
